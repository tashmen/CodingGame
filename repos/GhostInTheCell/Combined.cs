/*
 * File generated by SourceCombiner.exe using 16 source files.
 * Created On: 5/1/2021 7:08:59 PM
*/
using GameSolution.Arrivals;
using GameSolution.Entities;
using GameSolution.Moves;
using GameSolution.Utility;
using static GameSolution.Constants;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
//*** SourceCombiner -> original file BombArrival.cs ***
namespace GameSolution.Arrivals
{
    /// <summary>
    /// Class for determining the potential target of an enemy bomb
    /// </summary>
    public class BombArrival
    {
        //A value of 1 should mean the bomb arrives next turn
        public List<int> TurnsUntilArrival { get; private set; }
        public bool HasIncomingBomb
        {
            get
            {
                return TurnsUntilArrival.Where(a => a > 0).Any();
            }
        }
        public bool HasIncomingBombNextTurn
        {
            get
            {
                return TurnsUntilArrival.Contains(1);
            }
        }
        public BombArrival(List<BombEntity> bombs, Dictionary<int, int> sentBombs, int factoryId, FactoryLinks links)
        {
            TurnsUntilArrival = new List<int>();
            foreach(BombEntity bomb in bombs)
            {
                if (bomb.IsEnemy())
                {
                    if(bomb.SourceFactoryId != factoryId)
                    {
                        var distance = links.GetDistance(bomb.SourceFactoryId, factoryId);
                        var time = Math.Max(distance - sentBombs[bomb.Id], 0);
                        TurnsUntilArrival.Add(time);
                        //Console.Error.WriteLine($"Bomb Arrival:{factoryId} in {time}");
                    }
                }
                else if(bomb.TargetFactoryId == factoryId)
                {
                    TurnsUntilArrival.Add(bomb.TurnsToArrive);
                }
            }
        }
    }
}
//*** SourceCombiner -> original file Constants.cs ***
namespace GameSolution
{
    public class Constants
    {
        public enum Owner
        {
            Opponent = -1,
            Neutral = 0,
            Me = 1
        }
        public class EntityTypes
        {
            public const string Factory = "FACTORY";
            public const string Troop = "TROOP";
            public const string Bomb = "BOMB";
        }
        public class MoveType
        {
            public const string Move = "MOVE";
            public const string Bomb = "BOMB";
            public const string Wait = "WAIT";
            public const string Message = "MSG";
            public const string Upgrade = "INC";
        }
    }
}
//*** SourceCombiner -> original file BombEntity.cs ***
namespace GameSolution.Entities
{
    public class BombEntity : Entity
    {
        public int SourceFactoryId
        {
            get { return Arg2; }
        }
        public int TargetFactoryId
        {
            get { return Arg3; }
        }
        public int TurnsToArrive
        {
            get { return Arg4; }
        }
        /// <summary>
        /// Creates a new Bomb Entity
        /// </summary>
        /// <param name="id">Unique Identifier</param>
        /// <param name="arg1">Owner</param>
        /// <param name="arg2">Source Factory Id</param>
        /// <param name="arg3">Target Factory Id (-1 if enemy)</param>
        /// <param name="arg4">Number of turns until bomb hits the target (-1 if enemy)</param>
        /// <param name="arg5">unused</param>
        public BombEntity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        : base(id, arg1, arg2, arg3, arg4, arg5)
        {
        }
        public BombEntity(BombEntity entity) : base(entity)
        {
        }
    }
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
    public class Entity
    {
        public int Id { get; set; }
        public Owner Owner { get; set; }
        protected int Arg2 { get; set; }
        protected int Arg3 { get; set; }
        protected int Arg4 { get; set; }
        protected int Arg5 { get; set; }
        public Entity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        {
            Id = id;
            Owner = (Owner)arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
        }
        public Entity(Entity entity)
        {
            Id = entity.Id;
            Owner = entity.Owner;
            Arg2 = entity.Arg2;
            Arg3 = entity.Arg3;
            Arg4 = entity.Arg4;
            Arg5 = entity.Arg5;
        }
        public bool IsFriendly()
        {
            return Owner == Owner.Me;
        }
        public bool IsEnemy()
        {
            return Owner == Owner.Opponent;
        }
        public bool IsNeutral()
        {
            return Owner == Owner.Neutral;
        }
    }
}
//*** SourceCombiner -> original file EntityFactory.cs ***
namespace GameSolution.Entities
{
    public static class EntityFactory
    {
        public static Entity CreateEntity(string type, int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        {
            return type switch
            {
                EntityTypes.Factory => new FactoryEntity(id, arg1, arg2, arg3, arg4, arg5),
                EntityTypes.Troop => new TroopEntity(id, arg1, arg2, arg3, arg4, arg5),
                EntityTypes.Bomb => new BombEntity(id, arg1, arg2, arg3, arg4, arg5),
                _ => null
            };
        }
        public static Entity CreateEntity(Entity entity)
        {
            if(entity is FactoryEntity)
            {
                return new FactoryEntity(entity as FactoryEntity);
            }
            else if(entity is TroopEntity)
            {
                return new TroopEntity(entity as TroopEntity);
            }
            else if(entity is BombEntity)
            {
                return new BombEntity(entity as BombEntity);
            }
            return null;
        }
    }
}
//*** SourceCombiner -> original file FactoryEntity.cs ***
namespace GameSolution.Entities
{
    public class FactoryEntity : Entity
    {
        public int NumberOfCyborgs
        {
            get { return Arg2; }
            private set 
            { 
                Arg2 = value;
                if (NumberOfCyborgs < 0)
                {
                    throw new InvalidOperationException("Not enough troops!");
                }
            }
        }
        public int ProductionCount
        {
            get { return Arg3; }
            private set 
            { 
                Arg3 = value;
                if (ProductionCount > 3)
                {
                    throw new InvalidOperationException("At maximum production!");
                }
            }
        }
        public int TurnsTillProduction
        {
            get { return Arg4; }
        }
        public int CyborgsRequiredToDefend { get; set; }
        public TroopArrival TroopArrival { get; private set; }
        public BombArrival BombArrival { get; private set; }
        /// <summary>
        /// Creates a new Factory Entity
        /// </summary>
        /// <param name="id">Unique Identifier</param>
        /// <param name="arg1">Owner</param>
        /// <param name="arg2">Number of cyborgs in the factory</param>
        /// <param name="arg3">Factory Production</param>
        /// <param name="arg4">Number of turns till production</param>
        /// <param name="arg5">unused</param>
        public FactoryEntity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        : base(id, arg1, arg2, arg3, arg4, arg5)
        {
        }
        public FactoryEntity(FactoryEntity entity) : base(entity)
        {
        }
        public void Move(int cyborgCount)
        {
            NumberOfCyborgs = NumberOfCyborgs - cyborgCount;
        }
        public void Upgrade()
        {
            ProductionCount++;
            NumberOfCyborgs -= 10;
        }
        public bool IsProducing()
        {
            return TurnsTillProduction == 0;
        }
        public void BuildArrivals(List<TroopEntity> troops, List<BombEntity> bombs, Dictionary<int, int> sentBombs, FactoryLinks links)
        {
            TroopArrival = new TroopArrival(troops, bombs.Where(b => b.IsFriendly()).ToList(), this);
            BombArrival = new BombArrival(bombs, sentBombs, Id, links);
        }
    }
}
//*** SourceCombiner -> original file FactoryLinks.cs ***
namespace GameSolution.Utility
{
    public class FactoryLinks
    {
        Dictionary<int, List<Node>> Links { get; set; }
        Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        public FactoryLinks()
        {
            Links = new Dictionary<int, List<Node>>();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="factory1">First factory id</param>
        /// <param name="factory2">Second factory id</param>
        /// <param name="distance">The distance between the two factories</param>
        public void AddLink(int factory1, int factory2, int distance)
        {
            Console.Error.WriteLine(factory1 + " " + factory2 + " " + distance);
            AddLinkInternal(factory1, factory2, distance);
            AddLinkInternal(factory2, factory1, distance);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the factory links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting factory id</param>
        /// <param name="vertexCount">The number of factories</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            int currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                int minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            continue;//skip factories already in minimum spanning tree
                        }
                        int distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent > lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given factory
        /// </summary>
        /// <param name="factory">The factory id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int factoryId)
        {
            return Links[factoryId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The distance from start to end</returns>
        public int GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance + 1;//All commands are issued from this turn which is always turn 1.
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The distance along the shortest path</returns>
        public int GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            endPoints.TryGetValue(endId, out List<Node> paths);
            /*
            if(endId == 2){
                foreach(Node n in paths){
                    Console.Error.WriteLine($"Path: {n.FactoryId}, dist: {n.Distance}");
                }
            }
            Console.Error.WriteLine($"From start {startId} to {endId} path length: {paths.Count}.");
            */
            return paths.Last().Distance;//Shortest path distance already takes into account the 1 turn to send a troop
        }
        /// <summary>
        /// Retrieves the next factory along the path from start to end
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                return endId;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                return endId;
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        //Adds links to the factory links
        private void AddLinkInternal(int startFactory, int destinationFactory, int distance)
        {
            List<Node> factoryLinks = null;
            if (Links.ContainsKey(startFactory))
            {
                factoryLinks = Links[startFactory];
            }
            else
            {
                factoryLinks = new List<Node>();
                Links[startFactory] = factoryLinks;
            }
            factoryLinks.Add(new Node(destinationFactory, distance));
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Utility
{
    public class GameHelper
    {
        private GameState _pristineState;
        private GameState _internalState;
        public GameHelper(GameState state)
        {
            _pristineState = state;
            _internalState = new GameState(state);
        }
        public MoveList PickMoves()
        {
            MoveList moves = new MoveList();
            List<FactoryEntity> allFactories = _internalState.Factories;
            List<FactoryEntity> friendlyFactories = _internalState.MyFactories;
            int globalCyborgsAvailableToSend =  _internalState.MyTotalCyborgsAvailableToSend;
            Console.Error.WriteLine($"Global cyborgs available:{globalCyborgsAvailableToSend}");
            Dictionary<int, int> factoryIdToCyborgsToTakeover = new Dictionary<int, int>();
            List<MoveOption> multiFactoryTakeoverMoves = new List<MoveOption>();
            Dictionary<int, int> sourceFactoryToCyborgsAvailableToSend = new Dictionary<int, int>();
            foreach (FactoryEntity sourceFactory in friendlyFactories)
            {
                //Console.Error.WriteLine(sourceFactory.ToString());
                int cyborgsAvailableToSend = CalculateCyborgsAvailableToSend(sourceFactory);
                globalCyborgsAvailableToSend -= (sourceFactory.NumberOfCyborgs - cyborgsAvailableToSend);
                //Condition for holding onto troops in factory to get to an upgrade
                if (!IsFrontLineFactory(sourceFactory) && sourceFactory.ProductionCount < 3 && (_internalState.MyIncome < _internalState.EnemyIncome || _internalState.MyTroopsCount > (_internalState.EnemyTroopsCount - 5)))
                {
                    if (_internalState.EnemyBombs.Count == 0 || sourceFactory.ProductionCount <= 1)
                    {
                        List<FactoryEntity> neutralFactories = _internalState.NeutralFactories.Where(e => e.ProductionCount != 0 && e.NumberOfCyborgs != 0).ToList();
                        int totalNeutralCyborgs = 0;
                        //Find the number of neutral cyborgs where production of that factory is greater than 0 where we are closer than the enemy
                        //(it would be better to take these over as it would cost less than 10 troops)
                        foreach (FactoryEntity neutralFactory in neutralFactories)
                        {
                            if (neutralFactory.ProductionCount == 0)
                                continue;
                            int minFriendly = 9999;
                            int minEnemy = 9999;
                            foreach (FactoryEntity myFactory in _internalState.MyFactories)
                            {
                                int dist = _internalState.Links.GetShortestPathDistance(neutralFactory.Id, myFactory.Id);
                                if (dist < minFriendly)
                                {
                                    minFriendly = dist;
                                }
                            }
                            foreach (FactoryEntity enemyFactory in _internalState.EnemyFactories)
                            {
                                int dist = _internalState.Links.GetShortestPathDistance(neutralFactory.Id, enemyFactory.Id);
                                if (dist < minEnemy)
                                {
                                    minEnemy = dist;
                                }
                            }
                            if (minFriendly < minEnemy)
                            {
                                totalNeutralCyborgs += CalculateCyborgsRequiredToTakeover(sourceFactory, neutralFactory);
                            }
                        }
                        Console.Error.WriteLine($"Neutrals left:{totalNeutralCyborgs}");
                        if (totalNeutralCyborgs < (globalCyborgsAvailableToSend - 10))
                        {
                            if (sourceFactory.NumberOfCyborgs >= 10)
                            {
                                //At the final upgrade stage so send the rest onward to wherever or we can't wait another turn for the next upgrade
                                if (sourceFactory.ProductionCount == 2 || totalNeutralCyborgs >= (globalCyborgsAvailableToSend - 20))
                                {
                                    globalCyborgsAvailableToSend -= 10;
                                    cyborgsAvailableToSend -= 10;
                                }
                                else if(sourceFactory.ProductionCount < 2)
                                {
                                    Console.Error.WriteLine($"Holding for Upgrade:{sourceFactory.Id} troops:{cyborgsAvailableToSend}");
                                    globalCyborgsAvailableToSend -= cyborgsAvailableToSend;
                                    cyborgsAvailableToSend = 0;
                                }
                                Move move = new Move(sourceFactory.Id);
                                moves.AddMove(move);
                                _internalState.PlayMove(move, Owner.Me);
                            }
                            else
                            {
                                //Don't send troops out of this factory we want to use it to upgrade
                                Console.Error.WriteLine($"Holding for Upgrade:{sourceFactory.Id} troops:{cyborgsAvailableToSend}");
                                globalCyborgsAvailableToSend -= cyborgsAvailableToSend;
                                cyborgsAvailableToSend = 0;
                            }
                        }
                    }
                }
                sourceFactoryToCyborgsAvailableToSend[sourceFactory.Id] = cyborgsAvailableToSend;
            }
            foreach (FactoryEntity sourceFactory in friendlyFactories)
            {
                int cyborgsAvailableToSend = sourceFactoryToCyborgsAvailableToSend[sourceFactory.Id];
                Console.Error.WriteLine($"***Src: {sourceFactory.Id} Dfns: {sourceFactory.CyborgsRequiredToDefend} Available: {cyborgsAvailableToSend} Glbl:{globalCyborgsAvailableToSend}");
                bool hasTarget = true;//Assume a target will be found
                //As long as there are cyborgs to send let's see if there are any targets
                while (cyborgsAvailableToSend > 0 && hasTarget)
                {
                    FactoryEntity bestTarget = null;
                    int bestValue = -99999;
                    int cyborgsToSend = 0;
                    int cyborgsLeftToTakeover = 0;
                    bool isCompleteTakeover = false;
                    bool isLeftover = false;
                    foreach (FactoryEntity targetFactory in allFactories)
                    {
                        int val = 0;
                        if (targetFactory.Id == sourceFactory.Id)
                        {
                            continue;//Can't send to self
                        }
                        int cyborgsToTakeover = -1;
                        if (factoryIdToCyborgsToTakeover.ContainsKey(targetFactory.Id))
                        {
                            cyborgsToTakeover = factoryIdToCyborgsToTakeover[targetFactory.Id];
                        }
                        int cyborgsToTakeoverComplete = 0;
                        if (cyborgsToTakeover > 0)
                        {
                            val += 25;//we already said this was a good target so commit to it.
                            cyborgsToTakeoverComplete = CalculateCyborgsRequiredToTakeover(sourceFactory, targetFactory);
                            isLeftover = true;
                        }
                        else if(cyborgsToTakeover == -1)
                        {
                            cyborgsToTakeover = CalculateCyborgsRequiredToTakeover(sourceFactory, targetFactory);
                            cyborgsToTakeoverComplete = cyborgsToTakeover;
                            isLeftover = false;
                        }
                        if (cyborgsToTakeover <= 0)
                        {
                            continue;//skip places where we are already on track to take over
                        }
                        int distance = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, targetFactory.Id);
                        if (distance >= 9)
                        {
                            continue;
                        }
                        if (targetFactory.IsNeutral())
                        {
                            var enemyFactories = allFactories.Where(f => f.IsEnemy()).ToList();
                            int minDist = 9999;
                            foreach (FactoryEntity enemy in enemyFactories)
                            {
                                int dist = _internalState.Links.GetDistance(targetFactory.Id, enemy.Id);
                                if (dist < minDist)
                                {
                                    minDist = dist;
                                }
                            }
                            //Console.Error.WriteLine($"Min Dist to Enemy:{minDist}");
                            val += minDist * 5;//neutral factories that are farther from the enemy are worth more
                        }
                        val += cyborgsToTakeover * -1;//factories that take a lot of borgs to take over aren't as good of a choice
                        val += targetFactory.IsProducing() ? targetFactory.ProductionCount * 10 : 0;//lots of bonus for high yield factories
                        val += targetFactory.Owner == Owner.Opponent ? targetFactory.ProductionCount * 5 : 0;
                        val += targetFactory.Owner == Owner.Me && targetFactory.IsProducing() ? targetFactory.ProductionCount * 20 : 0;//Defend places that are producing
                        val += distance * -20;
                        if (!isLeftover)
                        {
                            Console.Error.WriteLine($"Trgt:{targetFactory.Id} Tkvr:{cyborgsToTakeover} Vl:{val} Dst:{distance}");
                        }
                        else
                        {
                            Console.Error.WriteLine($"Trgt:{targetFactory.Id} Tkvr lft:{cyborgsToTakeover} Vl:{val} Dst:{distance}");
                        }
                        if (val > bestValue)
                        {
                            //Only target items where we have enough to take over or the best target is not the target and there are no potential incoming bombs
                            int bestTargetId = _internalState.Links.GetShortestPath(sourceFactory.Id, targetFactory.Id);
                            int bestDistance = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, bestTargetId);
                            var bestTargetFactory = _internalState.Factories.First(f => f.Id == bestTargetId);
                            if(bestTargetFactory.BombArrival.TurnsUntilArrival.Contains(bestDistance))
                            {
                                Console.Error.WriteLine($"Bomb might explode arriving at {bestTargetId} from {sourceFactory.Id}");
                                continue;//Skip locations where a bomb is going to explode
                            }
                            if ((cyborgsToTakeover <= globalCyborgsAvailableToSend || bestTargetId != targetFactory.Id))
                            {
                                cyborgsLeftToTakeover = 0;
                                isCompleteTakeover = false;
                                if (cyborgsToTakeover > cyborgsAvailableToSend)
                                {
                                    cyborgsLeftToTakeover = cyborgsToTakeover - sourceFactory.NumberOfCyborgs;
                                    Console.Error.WriteLine("Not enough cyborgs at this factory!");
                                }
                                else if(cyborgsToTakeoverComplete > 0 && cyborgsToTakeoverComplete < cyborgsAvailableToSend)
                                {
                                    cyborgsToTakeover = cyborgsToTakeoverComplete;
                                    isCompleteTakeover = true;
                                    Console.Error.WriteLine($"Factory: {sourceFactory.Id} can take over {targetFactory.Id} by itself.");
                                }
                                bestValue = val;
                                bestTarget = targetFactory;
                                cyborgsToSend = Math.Min(Math.Min(cyborgsToTakeover, sourceFactory.NumberOfCyborgs), cyborgsAvailableToSend);
                                Console.Error.WriteLine("Value:" + val + " Current Best Target:" + targetFactory.Id + " Send:" + cyborgsToSend);
                            }
                            else 
                            {
                                bestValue = val;
                                bestTarget = null;
                                Console.Error.WriteLine("Best target is no target!");
                            }
                        }
                    }
                    if (bestTarget != null)
                    {
                        int bestTargetId = _internalState.Links.GetShortestPath(sourceFactory.Id, bestTarget.Id);
                        //If the best target is being sent to a non-friendly factory that has troops then take the long way
                        if (allFactories.Where(e => e.Id == bestTargetId && !e.IsFriendly() && CalculateCyborgsRequiredToTakeover(sourceFactory, e) > 1).Any())
                        {
                            Console.Error.WriteLine($"Found a non-friendly factory: {bestTargetId} with troops");
                            bestTargetId = bestTarget.Id;
                        }
                        cyborgsAvailableToSend -= cyborgsToSend;
                        globalCyborgsAvailableToSend -= cyborgsToSend;
                        if (!isCompleteTakeover && (cyborgsLeftToTakeover > 0 || multiFactoryTakeoverMoves.Where(m => m.TargetFactory.Id == bestTarget.Id || m.SourceFactory.Id == sourceFactory.Id).Any()))
                        {
                            factoryIdToCyborgsToTakeover[bestTarget.Id] = cyborgsLeftToTakeover;
                            Console.Error.WriteLine($"Leftover to send: {cyborgsLeftToTakeover} at {bestTarget.Id}");
                            MoveOption move = new MoveOption(sourceFactory, bestTarget, cyborgsToSend, bestTargetId);
                            multiFactoryTakeoverMoves.Add(move);
                        }
                        else
                        {
                            Console.Error.WriteLine("Best Target Acquired: " + bestTarget.Id + " to send " + cyborgsToSend);
                            factoryIdToCyborgsToTakeover[bestTarget.Id] = 0;
                            Move move = new Move(sourceFactory.Id, bestTargetId, cyborgsToSend);
                            moves.AddMove(move);
                            _internalState.PlayMove(move, Owner.Me);
                        }
                    }
                    else
                    {
                        hasTarget = false;//No targets so abort
                        if ((sourceFactory.ProductionCount < 3 && cyborgsAvailableToSend >= 10) && (_internalState.MyTroopsCount - _internalState.EnemyTroopsCount) > -10 && _internalState.GameCounter > 5)
                        {
                            Move move = new Move(sourceFactory.Id);
                            moves.AddMove(move);
                            cyborgsAvailableToSend -= 10;
                            globalCyborgsAvailableToSend -= 10;
                            _internalState.PlayMove(move, Owner.Me);
                            continue;
                        }
                        //If there are no targets then spew out borgs to facilities that need to grow
                        bool isFrontLineFactory = IsFrontLineFactory(sourceFactory);
                        if (sourceFactory.ProductionCount == 3 && !isFrontLineFactory)
                        {
                            Console.Error.WriteLine("Evacuating 3 production facility");
                            FactoryEntity friendlySourceTarget = null;
                            int bestFriendlyValue = -9999;
                            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories;
                            foreach (FactoryEntity friendlySource in friendlyFactories)
                            {
                                if (sourceFactory.Id == friendlySource.Id)
                                    continue;
                                int friendlyVal = 0;
                                //score points for closeness to the soure
                                friendlyVal += _internalState.Links.GetShortestPathDistance(sourceFactory.Id, friendlySource.Id) * -5;
                                foreach(FactoryEntity enemyFactory in _internalState.EnemyFactories)
                                {
                                    //score more points the closer the factory is to the enemy
                                    friendlyVal += _internalState.Links.GetShortestPathDistance(friendlySource.Id, enemyFactory.Id) * -10;
                                }
                                if (friendlySource.NumberOfCyborgs > 20)
                                {
                                    friendlyVal += -100;
                                }
                                if (friendlySource.ProductionCount == 3)
                                {
                                    friendlyVal += -200;
                                }
                                //less points for being close to the enemy
                                foreach (FactoryEntity enemyFactory in enemyFactories)
                                {
                                    friendlyVal += _internalState.Links.GetShortestPathDistance(friendlySource.Id, enemyFactory.Id) * -1;
                                }
                                if (friendlyVal > bestFriendlyValue)
                                {
                                    friendlySourceTarget = friendlySource;
                                    bestFriendlyValue = friendlyVal;
                                }
                            }
                            if (friendlySourceTarget != null)
                            {
                                Console.Error.WriteLine("Evacuation Target: " + friendlySourceTarget.Id);
                                int shortestId = _internalState.Links.GetShortestPath(sourceFactory.Id, friendlySourceTarget.Id);
                                moves.AddMove(new Move(sourceFactory.Id, shortestId, cyborgsAvailableToSend));
                                cyborgsAvailableToSend -= cyborgsAvailableToSend;
                                globalCyborgsAvailableToSend -= cyborgsAvailableToSend;
                            }
                            else
                            {
                                Console.Error.WriteLine("Could not find any targets!");
                            }
                        }
                        else
                        {
                            //Check if any bombs in play and evacuate
                            BombEvacuation(moves, sourceFactory);
                        }
                    }
                }
            }
            if (multiFactoryTakeoverMoves.Any())
            {
                PlayMultiFactoryTakeoverMoves(moves, multiFactoryTakeoverMoves);
            }
            if (_internalState.MyBombCount > 0)
            {
                UseBomb(moves);
            }
            if (!moves.Moves.Any())
            {
                Console.Error.WriteLine("No moves to make!");
                moves.AddMove(new Move());
            }
            return moves;
        }
        /// <summary>
        /// Calculate the number of cyborgs that can be used to send elsewhere taking defense into consideration
        /// </summary>
        /// <param name="sourceFactory">The source factory to check</param>
        /// <returns>The number of cyborgs available</returns>
        public int CalculateCyborgsAvailableToSend(FactoryEntity sourceFactory)
        {
            int cyborgsToDefend = GetCyborgDefense(sourceFactory);
            int available = 0;
            if (cyborgsToDefend < sourceFactory.NumberOfCyborgs)
                available = sourceFactory.NumberOfCyborgs - cyborgsToDefend;
            sourceFactory.CyborgsRequiredToDefend = cyborgsToDefend;
            return available;
        }
        //Checks for bombs in play and evacuates the source factory
        public void BombEvacuation(MoveList moves, FactoryEntity sourceFactory)
        {
            //Check for enemy bombs that are going to arrive this turn
            if (_internalState.EnemyBombs.Any() && sourceFactory.BombArrival.TurnsUntilArrival.Contains(1))
            {
                List<FactoryEntity> friendlyFactories = _internalState.MyFactories;
                int minDist = 9999;
                int minDistNon3 = 9999;
                FactoryEntity bestNon3ProductionFactory = null;
                FactoryEntity bestFactory = null;
                foreach (Node n in _internalState.Links.GetLinks(sourceFactory.Id))
                {
                    FactoryEntity factory = friendlyFactories.FirstOrDefault(f => f.Id == n.Id);
                    if (factory != null)
                    {
                        if (n.Distance < minDist)
                        {
                            minDist = n.Distance;
                            bestFactory = factory;
                        }
                        if (n.Distance < minDistNon3 && factory.ProductionCount < 3)
                        {
                            bestNon3ProductionFactory = factory;
                            minDistNon3 = n.Distance;
                        }
                    }
                }
                if (bestNon3ProductionFactory != null)
                {
                    Console.Error.WriteLine("Evacuating " + sourceFactory.Id + " to " + bestNon3ProductionFactory.Id);
                    Move move = new Move(sourceFactory.Id, bestNon3ProductionFactory.Id, CalculateCyborgsAvailableToSend(sourceFactory));
                    moves.AddMove(move);
                    _internalState.PlayMove(move, Owner.Me);
                }
                else if (bestFactory != null)
                {
                    Console.Error.WriteLine("Evacuating " + sourceFactory.Id + " to " + bestFactory.Id);
                    moves.AddMove(new Move(sourceFactory.Id, bestFactory.Id, CalculateCyborgsAvailableToSend(sourceFactory)));
                }
                else
                {
                    Console.Error.WriteLine("No factory found to evacuate to...");
                }
            }
        }
        public void PlayMultiFactoryTakeoverMoves(MoveList moves, List<MoveOption> moveOptions)
        {
            //Might need to handle 2 different multi-factory takeovers against more than 1 target; currently assumes that if all are on target then we fulfilled the amount to take over
            Dictionary<int, bool> didPlayMoveForTarget = new Dictionary<int, bool>();
            foreach (MoveOption move in moveOptions)
            {
                //Play every move that isn't at the target;
                if (move.TargetFactory.Id != move.BestTargetId)
                {
                    Console.Error.WriteLine("Move not on target: " + move.TargetFactory.Id + " adapted: " + move.BestTargetId);
                    moves.AddMove(move.GenerateMove());
                    didPlayMoveForTarget[move.TargetFactory.Id] = true;
                }
            }
            foreach (MoveOption move in moveOptions)
            {
                didPlayMoveForTarget.TryGetValue(move.TargetFactory.Id, out bool didPlayMove);
                if (!didPlayMove)//If all moves go to target then play all of them.
                {
                    Console.Error.WriteLine("Playing all multifactory target moves.");
                    moves.AddMove(move.GenerateMove());
                }
            }            
        }
        public bool IsFrontLineFactory(FactoryEntity factory)
        {
            FactoryEntity closestEnemy = GetClosestFactory(_internalState.EnemyFactories, factory);
            FactoryEntity closestFriendly = GetClosestFactory(_internalState.MyFactories, closestEnemy);
            if(closestFriendly.Id == factory.Id)
            {
                Console.Error.WriteLine("Factory: " + factory.Id + " is frontline.  ");
                return true;
            }
            //Console.Error.WriteLine("Factory: " + factory.Id + " is not frontline.");
            return false;
        }
        /// <summary>
        /// Gets the total number of cyborgs required to keep control of a factory
        /// </summary>
        /// <param name="sourceFactory">The factory we currently have under our control</param>
        /// <returns>The number of cyborgs required to stay in control</returns>
        public int GetCyborgDefense(FactoryEntity sourceFactory)
        {
            int cyborgsToDefend = 0;
            List<TroopEntity> enemyTroops = _internalState.EnemyTroops;
            if (sourceFactory.ProductionCount == 0)
            {
                return 0;//do not defend 0 production sites..
            }
            if (sourceFactory.BombArrival.HasIncomingBombNextTurn)
            {
                return 0;//No defense for potentially bombed sites
            }
            int minArrival = 9999;
            foreach (TroopEntity enemyTroop in enemyTroops)
            {
                if (enemyTroop.TargetFactory == sourceFactory.Id)
                {
                    cyborgsToDefend += enemyTroop.NumberOfCyborgs;
                    if (minArrival > enemyTroop.TurnsToArrive)
                    {
                        minArrival = enemyTroop.TurnsToArrive;
                    }
                }
            }
            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories;
            foreach (FactoryEntity enemyFactory in enemyFactories)
            {
                int dist = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, enemyFactory.Id);
                if (dist <= 2 && dist <= minArrival)
                {
                    cyborgsToDefend += enemyFactory.NumberOfCyborgs;
                    minArrival = dist;
                }
            }
            if (cyborgsToDefend != 0)
            {
                Console.Error.WriteLine("Source: " + sourceFactory.Id + " Incoming: " + cyborgsToDefend + " arrival: " + minArrival);
            }
            int productionTime = Math.Max(minArrival - sourceFactory.TurnsTillProduction, 0);
            cyborgsToDefend -= productionTime * sourceFactory.ProductionCount;
            cyborgsToDefend = cyborgsToDefend < 0 ? 0 : cyborgsToDefend;
            return cyborgsToDefend;
        }
        //Decides whether or not to use bomb after all movements have been declared
        public void UseBomb(MoveList moves)
        {
            List<BombEntity> bombs = _internalState.MyBombs;
            List<TroopEntity> friendlyTroops = _internalState.MyTroops;
            List<FactoryEntity> allFactories = _internalState.Factories;
            FactoryEntity bestTargetFactory = null;
            int bestVal = -9999;
            foreach (FactoryEntity targetFactory in allFactories)
            {
                int val = 0;
                /*
                bool targetHasTroops = false;
                int troopCount = 0;
                foreach (TroopEntity troop in friendlyTroops)
                {
                    if (troop.TargetFactory == targetFactory.Id)
                    {
                        troopCount += troop.NumberOfCyborgs;
                    }
                }
                if (troopCount > 0)
                {
                    targetHasTroops = true;
                }
                */
                bool isEnemy = targetFactory.IsEnemy();
                FactoryEntity bestSource = GetClosestFactory(_internalState.MyFactories, targetFactory);
                int numberOfCyborgs = targetFactory.NumberOfCyborgs;
                int level2CyborgCount = 5;
                if (bestSource != null)
                {
                    int dist = _internalState.Links.GetDistance(bestSource.Id, targetFactory.Id);
                    level2CyborgCount += dist * 2;
                    var ownerAndCount = targetFactory.TroopArrival.TimeTofactoryOwnershipAndCyborgCount[dist];
                    Owner owner = ownerAndCount.Item1;
                    numberOfCyborgs = ownerAndCount.Item2;
                    isEnemy = owner == Owner.Opponent;
                }
                else
                {
                    Console.Error.WriteLine("Could not find a friendly source factory!");
                }
                bool targetHasBomb = bombs.Any() && bombs.First().TargetFactoryId == targetFactory.Id;
                bool targetLevel2 = targetFactory.ProductionCount == 2 && numberOfCyborgs > level2CyborgCount && targetFactory.IsProducing();
                bool targetLevel3 = targetFactory.ProductionCount == 3 && targetFactory.IsProducing();
                if ((targetLevel3 || targetLevel2) && !targetHasBomb && isEnemy)
                {
                    val += targetFactory.NumberOfCyborgs;
                    val += targetFactory.ProductionCount * 5;
                    if (val > bestVal)
                    {
                        bestTargetFactory = targetFactory;
                    }
                }
            }
            if (bestTargetFactory != null)
            {
                Console.Error.WriteLine("Bombing: " + bestTargetFactory.Id + " with production: " + bestTargetFactory.ProductionCount);
                List<FactoryEntity> friendlyFactories = _internalState.MyFactories;
                FactoryEntity bestSource = GetClosestFactory(friendlyFactories, bestTargetFactory);
                if (bestSource != null)
                {
                    Move move = new Move(bestSource.Id, bestTargetFactory.Id);
                    moves.AddMove(move);
                    _internalState.PlayMove(move, Owner.Me);
                }
            }
        }
        public FactoryEntity GetClosestFactory(List<FactoryEntity> sourceFactories, FactoryEntity targetFactory)
        {
            FactoryEntity bestSource = null;
            int minDist = 99999;
            foreach (FactoryEntity sourceFactory in sourceFactories)
            {
                if(sourceFactory.Id == targetFactory.Id)
                {
                    continue;
                }
                int currentDistance = _internalState.Links.GetDistance(sourceFactory.Id, targetFactory.Id);
                if (currentDistance < minDist)
                {
                    minDist = currentDistance;
                    bestSource = sourceFactory;
                }
            }
            return bestSource;
        }
        //Calculates the number of cyborgs required to takeover a factory
        public int CalculateCyborgsRequiredToTakeover(FactoryEntity sourceFactory, FactoryEntity targetFactory)
        {
            //Console.Error.WriteLine(" Target: " + targetFactory.Id);
            int cyborgs = 1;//minimum to takeover is 1
            List<TroopEntity> troops = _internalState.Troops;
            //Check the incoming troop count.  This should be expanded to look at troops that are incoming along shortest paths.
            Dictionary<int, int> timeToEnemyTroops = targetFactory.TroopArrival.EnemyTroopArrival;
            Dictionary<int, int> timeToFriendlyTroops = targetFactory.TroopArrival.MyTroopArrival;
            //Add check for cyborgs sitting in factories that could be sent and assume they will be sent...
            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories.Where(e => e.Id != targetFactory.Id).ToList();
            foreach (FactoryEntity enemyFactory in enemyFactories)
            {
                int time = _internalState.Links.GetShortestPathDistance(targetFactory.Id, enemyFactory.Id);
                if (targetFactory.IsEnemy())
                {
                    if (timeToEnemyTroops.ContainsKey(time))
                    {
                        timeToEnemyTroops[time] += enemyFactory.NumberOfCyborgs;
                    }
                    else
                    {
                        timeToEnemyTroops[time] = enemyFactory.NumberOfCyborgs;
                    }
                }
            }
            int distance = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, targetFactory.Id);
            Owner currentOwner = targetFactory.Owner;
            List<BombEntity> friendlyBombs = _internalState.MyBombs;
            BombEntity friendlyBomb = null;
            if (friendlyBombs.Any())
            {
                friendlyBomb = friendlyBombs.First() as BombEntity;
                if (friendlyBomb.TurnsToArrive >= distance && friendlyBomb.TargetFactoryId == targetFactory.Id)
                {
                    return 999999;//Don't send troops where a bomb is going to explode after we send troops
                }
                //Console.Error.WriteLine("Bomb: " + friendlyBomb.Id + " Target: " + friendlyBomb.TargetFactory + " Time: " + friendlyBomb.TurnsToArrive);
            }
            //Calculate the number of cyborgs in the factory up to the distance of the source factory
            int cyborgsInFactory = targetFactory.NumberOfCyborgs;
            int bombCount = 0;
            for (int i = 1; i <= distance; i++)
            {
                timeToFriendlyTroops.TryGetValue(i, out int friendlyCount);
                timeToEnemyTroops.TryGetValue(i, out int enemyCount);
                if (targetFactory.Id == 5)
                {
                    //Console.Error.WriteLine("Own: " + currentOwner + " Borg: " + cyborgsInFactory + " Dist: " + distance);
                    //Console.Error.WriteLine("Friend: " + friendlyCount + " Enemy: " + enemyCount + " Time: " + i);
                }
                currentOwner = DetermineFactoryOwnership(ref cyborgsInFactory, ref bombCount, currentOwner, targetFactory, friendlyBomb, i, friendlyCount, enemyCount);
            }
            if (currentOwner == Owner.Me)
            {
                return 0;//I already own it; no more borgs required to takeover
            }
            cyborgs += cyborgsInFactory;
            return cyborgs;
        }
        public static Owner DetermineFactoryOwnership(ref int cyborgsInFactory, ref int bombCount, Owner currentOwner, FactoryEntity targetFactory, BombEntity friendlyBomb, int time, int friendlyCount, int enemyCount)
        {
            bool isBomb = false;
            if (friendlyBomb != null && friendlyBomb.TargetFactoryId == targetFactory.Id && friendlyBomb.TurnsToArrive == time)
            {
                bombCount = 5;//bombs disrupt production for 5 turns starting with the turn it goes off
                isBomb = true;
            }
            switch (currentOwner)
            {
                case Owner.Me:
                    if ((targetFactory.IsProducing() || targetFactory.TurnsTillProduction - time < 1) && bombCount <= 0)
                    {
                        cyborgsInFactory += targetFactory.ProductionCount;
                    }
                    cyborgsInFactory += friendlyCount - enemyCount;
                    if (isBomb)
                    {
                        int cyborgsLost = (int)Math.Floor(cyborgsInFactory / 2.0);
                        cyborgsLost = cyborgsLost < 10 ? Math.Min(10, cyborgsInFactory) : cyborgsLost;
                        cyborgsInFactory -= cyborgsLost;
                    }
                    if (cyborgsInFactory < 0)
                    {
                        currentOwner = Owner.Opponent;
                        cyborgsInFactory *= -1;
                        //Console.Error.WriteLine("We own the factory by " + time);
                    }
                    break;
                case Owner.Neutral:
                    cyborgsInFactory -= Math.Abs(friendlyCount - enemyCount);
                    if (cyborgsInFactory < 0)
                    {
                        currentOwner = friendlyCount > enemyCount ? Owner.Me : Owner.Opponent;
                        cyborgsInFactory *= -1;
                    }
                    break;
                case Owner.Opponent:
                    if ((targetFactory.IsProducing() || targetFactory.TurnsTillProduction - time < 1) && bombCount <= 0)
                    {
                        cyborgsInFactory += targetFactory.ProductionCount;
                    }
                    cyborgsInFactory += enemyCount - friendlyCount;
                    if (isBomb)
                    {
                        int cyborgsLost = (int)Math.Floor(cyborgsInFactory / 2.0);
                        cyborgsLost = cyborgsLost < 10 ? Math.Min(10, cyborgsInFactory) : cyborgsLost;
                        cyborgsInFactory -= cyborgsLost;
                        //Console.Error.WriteLine("Target: " + targetFactory.Id + " Current: " + cyborgsInFactory + " Bomb: " + cyborgsLost);
                    }
                    if (cyborgsInFactory < 0)
                    {
                        currentOwner = Owner.Me;
                        cyborgsInFactory *= -1;
                        //Console.Error.WriteLine("Enemy owns the factory by " + i);
                    }
                    break;
            }
            bombCount--;
            return currentOwner;
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Moves
{
    public class Move
    {
        private readonly int source;
        private readonly int destination;
        private readonly int count;
        private readonly string moveType;
        private readonly string message;
        public Move()
        {
            moveType = MoveType.Wait;
        }
        public Move(int factoryId)
        {
            source = factoryId;
            moveType = MoveType.Upgrade;
        }
        public Move(int sourceFactory, int destinationFactory, int cyborgCount)
        {
            source = sourceFactory;
            destination = destinationFactory;
            count = cyborgCount;
            moveType = MoveType.Move;
        }
        public Move(int sourceFactory, int destinationFactory)
        {
            moveType = MoveType.Bomb;
            source = sourceFactory;
            destination = destinationFactory;
        }
        public Move(string message)
        {
            moveType = MoveType.Message;
            this.message = message;
        }
        public string GetMove()
        {
            string move = moveType switch
            {
                MoveType.Move => MoveType.Move + " " + source + " " + destination + " " + count,
                MoveType.Wait => MoveType.Wait,
                MoveType.Bomb => MoveType.Bomb + " " + source + " " + destination,
                MoveType.Message => MoveType.Message + " " + message,
                MoveType.Upgrade => MoveType.Upgrade + " " + source,
                _ => MoveType.Wait
            };
            return move;
        }
        public void PlayMove()
        {
            Console.Write(GetMove());
        }
    }
}
//*** SourceCombiner -> original file MoveList.cs ***
namespace GameSolution.Moves
{
    public class MoveList
    {
        public List<Move> Moves { get; set; }
        public MoveList()
        {
            Moves = new List<Move>();
        }
        public void AddMove(Move move)
        {
            Moves.Add(move);
        }
        public void PlayMoves()
        {
            bool isFirst = true;
            foreach (Move move in Moves)
            {
                if (!isFirst)
                {
                    Console.Write(";");
                }
                move.PlayMove();
                isFirst = false;
            }
            Console.WriteLine();
        }
    }
}
//*** SourceCombiner -> original file MoveOption.cs ***
namespace GameSolution.Moves
{
    public class MoveOption
    {
        public FactoryEntity SourceFactory { get; set; }
        public FactoryEntity TargetFactory { get; set; }
        public int SendCount { get; set; }
        public int BestTargetId { get; set; }
        public MoveOption(FactoryEntity sourceFactory, FactoryEntity targetFactory, int sendCount, int bestTargetId)
        {
            SourceFactory = sourceFactory;
            TargetFactory = targetFactory;
            SendCount = sendCount;
            BestTargetId = bestTargetId;
        }
        public Move GenerateMove()
        {
            return new Move(SourceFactory.Id, BestTargetId, SendCount);
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
public class Player
{
    static void Main(string[] args)
    {
        FactoryLinks links = new FactoryLinks();
        string[] inputs;
        int factoryCount = int.Parse(Console.ReadLine()); // the number of factories
        int linkCount = int.Parse(Console.ReadLine()); // the number of links between factories
        for (int i = 0; i < linkCount; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int factory1 = int.Parse(inputs[0]);
            int factory2 = int.Parse(inputs[1]);
            int distance = int.Parse(inputs[2]);
            links.AddLink(factory1, factory2, distance);
        }
        Console.Error.WriteLine(factoryCount);
        Console.Error.WriteLine(linkCount);
        links.CalculateShortestPaths();
        GameState gs = new GameState(links);
        // game loop
        while (true)
        {
            Stopwatch watch = new Stopwatch();
            watch.Start();
            int entityCount = int.Parse(Console.ReadLine()); // the number of entities (e.g. factories and troops)
            List<Entity> entities = new List<Entity>();
            Console.Error.WriteLine(entities.Count);
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int entityId = int.Parse(inputs[0]);
                string entityType = inputs[1];
                int arg1 = int.Parse(inputs[2]);
                int arg2 = int.Parse(inputs[3]);
                int arg3 = int.Parse(inputs[4]);
                int arg4 = int.Parse(inputs[5]);
                int arg5 = int.Parse(inputs[6]);
                entities.Add(EntityFactory.CreateEntity(entityType, entityId, arg1, arg2, arg3, arg4, arg5));
            }
            Console.Error.WriteLine($"Found invalid entities: {entities.Where(e => e.Id == -1).Count()}");
            gs.SetEntities(entities);
            gs.ShowStats();
            GameHelper gh = new GameHelper(gs);
            MoveList moves = gh.PickMoves();
            watch.Stop();
            moves.AddMove(new Move($"{watch.ElapsedMilliseconds} ms"));
            moves.PlayMoves();
        }
    }
}
//*** SourceCombiner -> original file TroopEntity.cs ***
namespace GameSolution.Entities
{
    public class TroopEntity : Entity
    {
        public int SourceFactory
        {
            get { return Arg2; }
        }
        public int TargetFactory
        {
            get { return Arg3; }
        }
        public int NumberOfCyborgs
        {
            get { return Arg4; }
        }
        public int TurnsToArrive
        {
            get { return Arg5; }
        }
        /// <summary>
        /// Creates a new Troop Entity
        /// </summary>
        /// <param name="id">Unique Identifier</param>
        /// <param name="arg1">Owner</param>
        /// <param name="arg2">Source factory Id</param>
        /// <param name="arg3">Target factory Id</param>
        /// <param name="arg4">Number of cyborgs in the troop</param>
        /// <param name="arg5">Number of turns until arrival</param>
        public TroopEntity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        : base(id, arg1, arg2, arg3, arg4, arg5)
        {
        }
        public TroopEntity(TroopEntity entity) : base(entity)
        {
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Utility
{
    public class GameState
    {
        public int EnemyBombCount { get; private set; } = 2;
        public int MyBombCount { get; private set; } = 2;
        public int GameCounter { get; private set; } = 0;
        public int EnemyTroopsCount { get; private set; } = 0;
        public int MyTroopsCount { get; private set; } = 0;
        public int EnemyIncome { get; private set; } = 0;
        public int MyIncome { get; private set; } = 0;
        public int MyTotalCyborgsAvailableToSend { get; private set; } = 0;
        public FactoryLinks Links { get; private set; }
        public List<Entity> Entities { get; private set; }
        public List<FactoryEntity> Factories { get; private set; }
        public List<FactoryEntity> MyFactories { get; private set; }
        public List<FactoryEntity> EnemyFactories { get; private set; }
        public List<FactoryEntity> NeutralFactories { get; private set; }
        public List<BombEntity> Bombs { get; private set; }
        public List<BombEntity> MyBombs { get; private set; }
        public List<BombEntity> EnemyBombs { get; private set; }
        public List<TroopEntity> Troops { get; private set; }
        public List<TroopEntity> MyTroops { get; private set; }
        public List<TroopEntity> EnemyTroops { get; private set; }
        //Track bombs that have been sent along with the number of turns the bomb has been on the board
        private Dictionary<int, int> _bombsSent = new Dictionary<int, int>();
        public GameState(FactoryLinks links)
        {
            Links = links;
        }
        public GameState(GameState state)
        {
            //Because we are already tracking bombs that have been sent we have to copy over the bomb counts
            MyBombCount = state.MyBombCount;
            EnemyBombCount = state.EnemyBombCount;
            GameCounter = state.GameCounter;
            Links = state.Links;//Shouldn't be modified
            Entities = state.Entities.Select(e => EntityFactory.CreateEntity(e)).ToList();//Clone the entities as we want to update this
            _bombsSent = new Dictionary<int, int>(state._bombsSent);
            UpdateGameState();
            CalculateStats();
        }
        public void PlayMove(Move move, Owner owner)
        {
            //Should we check if it's legal??
            string strMove = move.GetMove();
            List<string> moveArgs = strMove.Split(' ').ToList();
            int source, target;
            FactoryEntity sourceFactory;
            switch (moveArgs[0])
            {
                case MoveType.Bomb:
                    source = Convert.ToInt32(moveArgs[1]);
                    target = Convert.ToInt32(moveArgs[2]);
                    Entities.Add(EntityFactory.CreateEntity(EntityTypes.Bomb, -1, (int)owner, source, target, Links.GetDistance(source, target), 0));
                    break;
                case MoveType.Move:
                    source = Convert.ToInt32(moveArgs[1]);
                    target = Convert.ToInt32(moveArgs[2]);
                    int cyborgCount = Convert.ToInt32(moveArgs[3]);
                    sourceFactory = Factories.First(e => e.Id == source);
                    sourceFactory.Move(cyborgCount);
                    Entities.Add(EntityFactory.CreateEntity(EntityTypes.Troop, -1, (int)owner, source, target, cyborgCount, Links.GetDistance(source, target)));
                    break;
                case MoveType.Upgrade:
                    source = Convert.ToInt32(moveArgs[1]);
                    sourceFactory = Factories.First(e => e.Id == source);
                    sourceFactory.Upgrade();
                    break;
            }
            UpdateGameState();
            CalculateStats();
        }
        /// <summary>
        /// Setup entities for this turn
        /// </summary>
        /// <param name="entites">The entities to fill the game state</param>
        public void SetEntities(List<Entity> entites)
        {
            Entities = entites;
            UpdateGameState();
            CalculateStats(true);
            GameCounter++;
        }
        /// <summary>
        /// Updates the various shortcut lists.
        /// </summary>
        private void UpdateGameState()
        {
            Factories = Entities.Where(e => e is FactoryEntity).Select(e => e as FactoryEntity).ToList();
            MyFactories = Factories.Where(e => e.IsFriendly()).ToList();
            EnemyFactories = Factories.Where(e => e.IsEnemy()).ToList();
            NeutralFactories = Factories.Where(e => e.IsNeutral()).ToList();
            Bombs = Entities.Where(e => e is BombEntity).Select(e => e as BombEntity).ToList();
            MyBombs = Bombs.Where(e => e.IsFriendly()).ToList();
            EnemyBombs = Bombs.Where(e => e.IsEnemy()).ToList();
            Troops = Entities.Where(e => e is TroopEntity).Select(e => e as TroopEntity).ToList();
            MyTroops = Troops.Where(e => e.IsFriendly()).ToList();
            EnemyTroops = Troops.Where(e => e.IsEnemy()).ToList();
        }
        /// <summary>
        /// Calculates the various statistics
        /// </summary>
        private void CalculateStats(bool advanceBombs = false)
        {
            EnemyIncome = 0;
            MyIncome = 0;
            MyTroopsCount = 0;
            EnemyTroopsCount = 0;
            MyTotalCyborgsAvailableToSend = 0;
            foreach (BombEntity bomb in Bombs)
            {
                if (!_bombsSent.ContainsKey(bomb.Id))
                {
                    _bombsSent[bomb.Id] = 1;//By the time bombs are seen they are moving
                    Console.Error.WriteLine($"Bomb was used {bomb.Id} on target {bomb.TargetFactoryId}.");
                    if (bomb.IsFriendly())
                    {
                        MyBombCount--;
                    }
                    else if (bomb.IsEnemy())
                    {
                        EnemyBombCount--;
                    }
                }
                else if (advanceBombs)//skip incrementing unless we are doing a new turn.
                {
                    _bombsSent[bomb.Id]++;
                }
            }
            foreach (FactoryEntity factory in Factories)
            {
                factory.BuildArrivals(Troops, Bombs, _bombsSent, Links);
                if (factory.IsFriendly())
                {
                    if (factory.IsProducing())
                    {
                        MyIncome += factory.ProductionCount;
                    }
                    MyTotalCyborgsAvailableToSend += factory.NumberOfCyborgs;
                    MyTroopsCount += factory.NumberOfCyborgs;
                }
                else if (factory.IsEnemy())
                {
                    if (factory.IsProducing())
                    {
                        EnemyIncome += factory.ProductionCount;
                    }
                    EnemyTroopsCount += factory.NumberOfCyborgs;
                }
            }
            foreach (TroopEntity troop in Troops)
            {
                if (troop.IsFriendly())
                {
                    MyTroopsCount += troop.NumberOfCyborgs;
                }
                else if (troop.IsEnemy())
                {
                    EnemyTroopsCount += troop.NumberOfCyborgs;
                }
            }
        }
        /// <summary>
        /// Shows the stats in the error log
        /// </summary>
        public void ShowStats()
        {
            Console.Error.WriteLine("Diff: " + (MyTroopsCount - EnemyTroopsCount) + " My Troops: " + MyTroopsCount + " Enemy Troops: " + EnemyTroopsCount);
            Console.Error.WriteLine("Diff: " + (MyIncome - EnemyIncome) + " My Income: " + MyIncome + " Enemy Income: " + EnemyIncome);
            Console.Error.WriteLine($"My Bombs: {MyBombCount}, Enemy Bombs: {EnemyBombCount}");
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace GameSolution.Utility
{
    public class Node
    {
        public int Id { get; set; }
        public int Distance { get; set; }
        public Node(int factory, int distance)
        {
            Id = factory;
            Distance = distance;
        }
        /// <summary>
        /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
        /// </summary>
        /// <param name="currentDist">The current distance from the starting factory</param>
        /// <returns>A clone of the node with the proper distance</returns>
        public Node CreateAtDistance(int currentDist)
        {
            return new Node(Id, currentDist + Distance + 1);//It takes an additional turn on every hop to re-route troops
        }
    }
}
//*** SourceCombiner -> original file TroopArrival.cs ***
namespace GameSolution.Arrivals
{
    public class TroopArrival
    {
        //# of Turns to Troop Count
        public Dictionary<int, int> MyTroopArrival { get; private set; }
        public Dictionary<int, int> EnemyTroopArrival { get; private set; }
        /// <summary>
        /// Tracks who will own the factory by the specified time with current troop movements
        /// </summary>
        public Dictionary<int, Tuple<Owner, int>> TimeTofactoryOwnershipAndCyborgCount { get; private set; }
        public TroopArrival(List<TroopEntity> troops, List<BombEntity> friendlyBombs, FactoryEntity targetFactory)
        {
            MyTroopArrival = new Dictionary<int, int>();
            EnemyTroopArrival = new Dictionary<int, int>();
            //Calculate the time until troops arrive at the target factory
            foreach (TroopEntity troop in troops)
            {
                if (troop.TargetFactory == targetFactory.Id)
                {
                    if (troop.IsFriendly())
                    {
                        if (MyTroopArrival.ContainsKey(troop.TurnsToArrive))
                        {
                            MyTroopArrival[troop.TurnsToArrive] += troop.NumberOfCyborgs;
                        }
                        else
                        {
                            MyTroopArrival[troop.TurnsToArrive] = troop.NumberOfCyborgs;
                        }
                    }
                    else if (troop.IsEnemy())
                    {
                        //Console.Error.WriteLine("Enemy troop count: " + troop.NumberOfCyborgs + " arrives: " + troop.TurnsToArrive);
                        if (EnemyTroopArrival.ContainsKey(troop.TurnsToArrive))
                        {
                            EnemyTroopArrival[troop.TurnsToArrive] += troop.NumberOfCyborgs;
                        }
                        else
                        {
                            EnemyTroopArrival[troop.TurnsToArrive] = troop.NumberOfCyborgs;
                        }
                    }
                }
            }
            TimeTofactoryOwnershipAndCyborgCount = new Dictionary<int, Tuple<Owner, int>>();
            int cyborgsInFactory = targetFactory.NumberOfCyborgs;
            Owner currentOwner = targetFactory.Owner;
            int bombCount = 0;
            var friendlyBomb = friendlyBombs.FirstOrDefault(b => b.TargetFactoryId == targetFactory.Id);
            for (int time = 1; time <= 20; time++)
            {
                MyTroopArrival.TryGetValue(time, out int friendlyCount);
                EnemyTroopArrival.TryGetValue(time, out int enemyCount);
                currentOwner = GameHelper.DetermineFactoryOwnership(ref cyborgsInFactory, ref bombCount, currentOwner, targetFactory, friendlyBomb, time, friendlyCount, enemyCount);
                TimeTofactoryOwnershipAndCyborgCount[time] = new Tuple<Owner, int>(currentOwner, cyborgsInFactory);
            }
        }
    }
}
