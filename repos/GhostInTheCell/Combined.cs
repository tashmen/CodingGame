/*
 * File generated by SourceCombiner.exe using 14 source files.
 * Created On: 4/5/2021 11:03:16 PM
*/
using GameSolution.Entities;
using GameSolution.Moves;
using GameSolution.Utility;
using static GameSolution.Constants;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file Constants.cs ***
namespace GameSolution
{
    public class Constants
    {
        public enum Owner
        {
            Opponent = -1,
            Neutral = 0,
            Me = 1
        }
        public class EntityTypes
        {
            public const string Factory = "FACTORY";
            public const string Troop = "TROOP";
            public const string Bomb = "BOMB";
        }
        public class MoveType
        {
            public const string Move = "MOVE";
            public const string Bomb = "BOMB";
            public const string Wait = "WAIT";
            public const string Message = "MSG";
            public const string Upgrade = "INC";
        }
    }
}
//*** SourceCombiner -> original file BombEntity.cs ***
namespace GameSolution.Entities
{
    public class BombEntity : Entity
    {
        public int SourceFactoryId
        {
            get { return Arg2; }
        }
        public int TargetFactoryId
        {
            get { return Arg3; }
        }
        public int TurnsToArrive
        {
            get { return Arg4; }
        }
        /// <summary>
        /// Creates a new Bomb Entity
        /// </summary>
        /// <param name="id">Unique Identifier</param>
        /// <param name="arg1">Owner</param>
        /// <param name="arg2">Source Factory Id</param>
        /// <param name="arg3">Target Factory Id (-1 if enemy)</param>
        /// <param name="arg4">Number of turns until bomb hits the target (-1 if enemy)</param>
        /// <param name="arg5">unused</param>
        public BombEntity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        : base(id, arg1, arg2, arg3, arg4, arg5)
        {
        }
        public BombEntity(BombEntity entity) : base(entity)
        {
        }
    }
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
    public class Entity
    {
        public int Id { get; set; }
        public Owner Owner { get; set; }
        protected int Arg2 { get; set; }
        protected int Arg3 { get; set; }
        protected int Arg4 { get; set; }
        protected int Arg5 { get; set; }
        public Entity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        {
            Id = id;
            Owner = (Owner)arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
        }
        public Entity(Entity entity)
        {
            Id = entity.Id;
            Owner = entity.Owner;
            Arg2 = entity.Arg2;
            Arg3 = entity.Arg3;
            Arg4 = entity.Arg4;
            Arg5 = entity.Arg5;
        }
        public bool IsFriendly()
        {
            return Owner == Owner.Me;
        }
        public bool IsEnemy()
        {
            return Owner == Owner.Opponent;
        }
        public bool IsNeutral()
        {
            return Owner == Owner.Neutral;
        }
    }
}
//*** SourceCombiner -> original file EntityFactory.cs ***
namespace GameSolution.Entities
{
    public static class EntityFactory
    {
        public static Entity CreateEntity(string type, int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        {
            return type switch
            {
                EntityTypes.Factory => new FactoryEntity(id, arg1, arg2, arg3, arg4, arg5),
                EntityTypes.Troop => new TroopEntity(id, arg1, arg2, arg3, arg4, arg5),
                EntityTypes.Bomb => new BombEntity(id, arg1, arg2, arg3, arg4, arg5),
                _ => null
            };
        }
        public static Entity CreateEntity(Entity entity)
        {
            if(entity is FactoryEntity)
            {
                return new FactoryEntity(entity as FactoryEntity);
            }
            else if(entity is TroopEntity)
            {
                return new TroopEntity(entity as TroopEntity);
            }
            else if(entity is BombEntity)
            {
                return new BombEntity(entity as BombEntity);
            }
            return null;
        }
    }
}
//*** SourceCombiner -> original file FactoryEntity.cs ***
namespace GameSolution.Entities
{
    public class FactoryEntity : Entity
    {
        public int NumberOfCyborgs
        {
            get { return Arg2; }
            private set 
            { 
                Arg2 = value;
                if (NumberOfCyborgs < 0)
                {
                    throw new InvalidOperationException("Not enough troops!");
                }
            }
        }
        public int ProductionCount
        {
            get { return Arg3; }
            private set 
            { 
                Arg3 = value;
                if (ProductionCount > 3)
                {
                    throw new InvalidOperationException("At maximum production!");
                }
            }
        }
        public int TurnsTillProduction
        {
            get { return Arg4; }
        }
        /// <summary>
        /// Creates a new Factory Entity
        /// </summary>
        /// <param name="id">Unique Identifier</param>
        /// <param name="arg1">Owner</param>
        /// <param name="arg2">Number of cyborgs in the factory</param>
        /// <param name="arg3">Factory Production</param>
        /// <param name="arg4">Number of turns till production</param>
        /// <param name="arg5">unused</param>
        public FactoryEntity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        : base(id, arg1, arg2, arg3, arg4, arg5)
        {
        }
        public FactoryEntity(FactoryEntity entity) : base(entity)
        {
        }
        public void Move(int cyborgCount)
        {
            NumberOfCyborgs = NumberOfCyborgs - cyborgCount;
        }
        public void Upgrade()
        {
            ProductionCount++;
            NumberOfCyborgs -= 10;
        }
        public bool IsProducing()
        {
            return TurnsTillProduction == 0;
        }
    }
}
//*** SourceCombiner -> original file FactoryLinks.cs ***
namespace GameSolution.Utility
{
    public class FactoryLinks
    {
        Dictionary<int, List<Node>> Links { get; set; }
        Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        public FactoryLinks()
        {
            Links = new Dictionary<int, List<Node>>();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="factory1">First factory id</param>
        /// <param name="factory2">Second factory id</param>
        /// <param name="distance">The distance between the two factories</param>
        public void AddLink(int factory1, int factory2, int distance)
        {
            Console.Error.WriteLine(factory1 + " " + factory2 + " " + distance);
            AddLinkInternal(factory1, factory2, distance);
            AddLinkInternal(factory2, factory1, distance);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the factory links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting factory id</param>
        /// <param name="vertexCount">The number of factories</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            int currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                int minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.FactoryId))
                    {
                        if (minimumSpanningTree.Where(n => n.FactoryId == adjacent.FactoryId).Any())
                        {
                            continue;//skip factories already in minimum spanning tree
                        }
                        int distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            //When the distances are equivalent pick the one with the longest path
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)
                        {
                            Paths[startNode].TryGetValue(currentNode.FactoryId, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.FactoryId, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent > lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.FactoryId != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.FactoryId, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.FactoryId, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given factory
        /// </summary>
        /// <param name="factory">The factory id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int factoryId)
        {
            return Links[factoryId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The distance from start to end</returns>
        public int GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.FactoryId == endId).First().Distance + 1;//All commands are issued from this turn which is always turn 1.
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The distance along the shortest path</returns>
        public int GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            endPoints.TryGetValue(endId, out List<Node> paths);
            /*
            if(endId == 2){
                foreach(Node n in paths){
                    Console.Error.WriteLine($"Path: {n.FactoryId}, dist: {n.Distance}");
                }
            }
            Console.Error.WriteLine($"From start {startId} to {endId} path length: {paths.Count}.");
            */
            return paths.Last().Distance + 1;//All commands are issued from this turn which is always turn 1.
        }
        /// <summary>
        /// Retrieves the next factory along the path from start to end
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                return endId;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                return endId;
            }
            int shortest = paths.First().FactoryId;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        //Adds links to the factory links
        private void AddLinkInternal(int startFactory, int destinationFactory, int distance)
        {
            List<Node> factoryLinks = null;
            if (Links.ContainsKey(startFactory))
            {
                factoryLinks = Links[startFactory];
            }
            else
            {
                factoryLinks = new List<Node>();
                Links[startFactory] = factoryLinks;
            }
            factoryLinks.Add(new Node(destinationFactory, distance));
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Utility
{
    public class GameHelper
    {
        private GameState _pristineState;
        private GameState _internalState;
        public GameHelper(GameState state)
        {
            _pristineState = state;
            _internalState = new GameState(state);
        }
        public MoveList PickMoves()
        {
            MoveList moves = new MoveList();
            List<FactoryEntity> otherFactories = _internalState.Factories;
            List<FactoryEntity> friendlyFactories = _internalState.MyFactories;
            int globalCyborgsAvailableToSend = CalculateTotalCyborgsAvailableToSend();
            Dictionary<int, int> factoryIdToCyborgsToTakeover = new Dictionary<int, int>();
            List<MoveOption> multiFactoryTakeoverMoves = new List<MoveOption>();
            foreach (FactoryEntity sourceFactory in friendlyFactories)
            {
                //Console.Error.WriteLine(sourceFactory.ToString());
                int cyborgsAvailableToSend = CalculateCyborgsAvailableToSend(sourceFactory);
                bool hasTarget = true;//Assume a target will be found
                globalCyborgsAvailableToSend -= (sourceFactory.NumberOfCyborgs - cyborgsAvailableToSend);
                //Condition for holding onto troops in factory to get to an upgrade
                if (!IsFrontLineFactory(sourceFactory) && sourceFactory.ProductionCount < 3 && (_internalState.MyIncome < _internalState.EnemyIncome || _internalState.MyTroopsCount > (_internalState.EnemyTroopsCount - 5)))
                {
                    List<FactoryEntity> neutralFactories = _internalState.NeutralFactories.Where(e => e.ProductionCount != 0 && e.NumberOfCyborgs != 0).ToList();
                    int totalCyborgs = 0;
                    foreach(FactoryEntity neutralFactory in neutralFactories)
                    {
                        int minFriendly = 9999;
                        int minEnemy = 9999;
                        foreach (FactoryEntity myFactory in _internalState.MyFactories)
                        {
                            int dist = _internalState.Links.GetShortestPathDistance(neutralFactory.Id, myFactory.Id);
                            if(dist < minFriendly)
                            {
                                minFriendly = dist;
                            }
                        }
                        foreach (FactoryEntity enemyFactory in _internalState.EnemyFactories)
                        {
                            int dist = _internalState.Links.GetShortestPathDistance(neutralFactory.Id, enemyFactory.Id);
                            if (dist < minEnemy)
                            {
                                minEnemy = dist;
                            }
                        }
                        if(minFriendly < minEnemy)
                        {
                            totalCyborgs += neutralFactory.NumberOfCyborgs;
                        }
                    }
                    if (totalCyborgs < (globalCyborgsAvailableToSend - 10))
                    {
                        //Don't send troops out of this factory we want to use it to upgrade; unless we can't wait another turn
                        if (sourceFactory.ProductionCount < 2 && totalCyborgs < (globalCyborgsAvailableToSend - 20))
                        {
                            globalCyborgsAvailableToSend -= cyborgsAvailableToSend;
                            cyborgsAvailableToSend = 0;
                        }
                        if (sourceFactory.NumberOfCyborgs >= 10)
                        {
                            //At the final upgrade stage so send the rest onward to wherever
                            if (sourceFactory.ProductionCount == 2 || totalCyborgs >= (globalCyborgsAvailableToSend - 20))
                            {
                                globalCyborgsAvailableToSend -= 10;
                                cyborgsAvailableToSend -= 10;
                            }
                            Move move = new Move(sourceFactory.Id);
                            moves.AddMove(move);
                            _internalState.PlayMove(move, Owner.Me);
                        }
                    }
                }
                //As long as there are cyborgs to send let's see if there are any targets
                while (cyborgsAvailableToSend > 0 && hasTarget)
                {
                    FactoryEntity bestTarget = null;
                    int bestValue = -99999;
                    int cyborgsToSend = 0;
                    int cyborgsLeftToTakeover = 0;
                    bool isCompleteTakeover = false;
                    foreach (FactoryEntity targetFactory in otherFactories)
                    {
                        int val = 0;
                        if (targetFactory.Id == sourceFactory.Id)
                        {
                            continue;//Can't send to self
                        }
                        factoryIdToCyborgsToTakeover.TryGetValue(targetFactory.Id, out int cyborgsToTakeover);
                        int cyborgsToTakeoverComplete = 0;
                        if (cyborgsToTakeover > 0)
                        {
                            val += 25;//we already said this was a good target so commit to it.
                            Console.Error.WriteLine("Target: " + targetFactory.Id + " Takeover left: " + cyborgsToTakeover);
                            cyborgsToTakeoverComplete = CalculateCyborgsRequiredToTakeover(sourceFactory, targetFactory);
                        }
                        else
                        {
                            cyborgsToTakeover = CalculateCyborgsRequiredToTakeover(sourceFactory, targetFactory);
                            if (cyborgsToTakeover > 0)
                            {
                                Console.Error.WriteLine("Target: " + targetFactory.Id + " Takeover: " + cyborgsToTakeover);
                            }
                        }
                        if (cyborgsToTakeover <= 0)
                        {
                            continue;//skip places where we are already on track to take over
                        }
                        int distance = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, targetFactory.Id);
                        if (distance >= 9)
                        {
                            continue;
                        }
                        if (targetFactory.IsNeutral())
                        {
                            var enemyFactories = otherFactories.Where(f => f.IsEnemy()).ToList();
                            int minDist = 9999;
                            foreach (FactoryEntity enemy in enemyFactories)
                            {
                                int dist = _internalState.Links.GetDistance(targetFactory.Id, enemy.Id);
                                if (distance < minDist)
                                {
                                    minDist = distance;
                                }
                            }
                            val += minDist * 5;//neutral factories that are farther from the enemy are worth more
                        }
                        val += cyborgsToTakeover * -1;//factories that take a lot of borgs to take over aren't as good of a choice
                        val += targetFactory.IsProducing() ? targetFactory.ProductionCount * 10 : 0;//lots of bonus for high yield factories
                        val += targetFactory.Owner == Owner.Opponent ? targetFactory.ProductionCount * 5 : 0;
                        val += distance * -20;
                        if (val > bestValue)
                        {
                            //If we don't have enough troops for a takeover then it's not the best target
                            //Need to adjust the multi-source takeover to include synchronization on time or put it into a holding that will only execute if fulfilled
                            if (cyborgsToTakeover <= globalCyborgsAvailableToSend)
                            {
                                cyborgsLeftToTakeover = 0;
                                isCompleteTakeover = false;
                                if (cyborgsToTakeover > cyborgsAvailableToSend)
                                {
                                    cyborgsLeftToTakeover = cyborgsToTakeover - sourceFactory.NumberOfCyborgs;
                                    Console.Error.WriteLine("Not enough cyborgs at this factory!");
                                }
                                else if(cyborgsToTakeoverComplete > 0 && cyborgsToTakeoverComplete < cyborgsAvailableToSend)
                                {
                                    cyborgsToTakeover = cyborgsToTakeoverComplete;
                                    isCompleteTakeover = true;
                                    Console.Error.WriteLine($"Factory: {sourceFactory.Id} can take over {targetFactory.Id} by itself.");
                                }
                                bestValue = val;
                                bestTarget = targetFactory;
                                cyborgsToSend = Math.Min(Math.Min(cyborgsToTakeover, sourceFactory.NumberOfCyborgs), cyborgsAvailableToSend);
                                //Console.Error.WriteLine("Value: " + val + " Best Target: " + targetFactory.Id + " to send " + cyborgsToSend);
                            }
                        }
                    }
                    if (bestTarget != null)
                    {
                        int bestTargetId = _internalState.Links.GetShortestPath(sourceFactory.Id, bestTarget.Id);
                        //If the best target is being sent to a non-friendly factory that has troops then take the long way
                        if (otherFactories.Where(e => e.Id == bestTargetId && e.IsNeutral() && CalculateCyborgsRequiredToTakeover(sourceFactory, e) != 0).Any())
                        {
                            Console.Error.WriteLine($"Found a non-friendly factory: {bestTargetId} with troops");
                            bestTargetId = bestTarget.Id;
                        }
                        cyborgsAvailableToSend -= cyborgsToSend;
                        globalCyborgsAvailableToSend -= cyborgsToSend;
                        if (!isCompleteTakeover && (cyborgsLeftToTakeover > 0 || multiFactoryTakeoverMoves.Where(m => m.TargetFactory.Id == bestTarget.Id || m.SourceFactory.Id == sourceFactory.Id).Any()))
                        {
                            factoryIdToCyborgsToTakeover[bestTarget.Id] = cyborgsLeftToTakeover;
                            Console.Error.WriteLine($"Leftover to send: {cyborgsLeftToTakeover} at {bestTarget.Id}");
                            MoveOption move = new MoveOption(sourceFactory, bestTarget, cyborgsToSend, bestTargetId);
                            multiFactoryTakeoverMoves.Add(move);
                        }
                        else
                        {
                            Console.Error.WriteLine("Best Target Acquired: " + bestTarget.Id + " to send " + cyborgsToSend);
                            factoryIdToCyborgsToTakeover[bestTarget.Id] = 0;
                            Move move = new Move(sourceFactory.Id, bestTargetId, cyborgsToSend);
                            moves.AddMove(move);
                            _internalState.PlayMove(move, Owner.Me);
                        }
                    }
                    else
                    {
                        hasTarget = false;//No targets so abort
                        if ((sourceFactory.ProductionCount < 3 && cyborgsAvailableToSend >= 10) && (_internalState.MyTroopsCount - _internalState.EnemyTroopsCount) > -10 && _internalState.GameCounter > 5)
                        {
                            Move move = new Move(sourceFactory.Id);
                            moves.AddMove(move);
                            cyborgsAvailableToSend -= 10;
                            globalCyborgsAvailableToSend -= 10;
                            _internalState.PlayMove(move, Owner.Me);
                            continue;
                        }
                        //If there are no targets then spew out borgs to facilities that need to grow
                        bool isFrontLineFactory = IsFrontLineFactory(sourceFactory);
                        if (sourceFactory.ProductionCount == 3 && !isFrontLineFactory)
                        {
                            Console.Error.WriteLine("Evacuating 3 production facility");
                            FactoryEntity friendlySourceTarget = null;
                            int bestFriendlyValue = -9999;
                            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories;
                            foreach (FactoryEntity friendlySource in friendlyFactories)
                            {
                                if (sourceFactory.Id == friendlySource.Id)
                                    continue;
                                int friendlyVal = 0;
                                //score points for closeness to the soure
                                friendlyVal += _internalState.Links.GetShortestPathDistance(sourceFactory.Id, friendlySource.Id) * -5;
                                foreach(FactoryEntity enemyFactory in _internalState.EnemyFactories)
                                {
                                    //score more points the closer the factory is to the enemy
                                    friendlyVal += _internalState.Links.GetShortestPathDistance(friendlySource.Id, enemyFactory.Id) * -10;
                                }
                                if (friendlySource.NumberOfCyborgs > 20)
                                {
                                    friendlyVal += -100;
                                }
                                if (friendlySource.ProductionCount == 3)
                                {
                                    friendlyVal += -200;
                                }
                                //less points for being close to the enemy
                                foreach (FactoryEntity enemyFactory in enemyFactories)
                                {
                                    friendlyVal += _internalState.Links.GetShortestPathDistance(friendlySource.Id, enemyFactory.Id) * -1;
                                }
                                if (friendlyVal > bestFriendlyValue)
                                {
                                    friendlySourceTarget = friendlySource;
                                    bestFriendlyValue = friendlyVal;
                                }
                            }
                            if (friendlySourceTarget != null)
                            {
                                Console.Error.WriteLine("Evacuation Target: " + friendlySourceTarget.Id);
                                int shortestId = _internalState.Links.GetShortestPath(sourceFactory.Id, friendlySourceTarget.Id);
                                moves.AddMove(new Move(sourceFactory.Id, shortestId, cyborgsAvailableToSend));
                                cyborgsAvailableToSend -= cyborgsAvailableToSend;
                                globalCyborgsAvailableToSend -= cyborgsAvailableToSend;
                            }
                            else
                            {
                                Console.Error.WriteLine("Could not find any targets!");
                            }
                        }
                        else
                        {
                            //Check if any bombs in play and evacuate
                            BombEvacuation(moves, sourceFactory);
                        }
                    }
                }
            }
            if (multiFactoryTakeoverMoves.Any())
            {
                PlayMultiFactoryTakeoverMoves(moves, multiFactoryTakeoverMoves);
            }
            if (_internalState.MyBombCount > 0)
            {
                UseBomb(moves);
            }
            if (!moves.Moves.Any())
            {
                Console.Error.WriteLine("No moves to make!");
                moves.AddMove(new Move());
            }
            return moves;
        }
        /// <summary>
        /// Calculates the total number of cyborgs that can be sent
        /// </summary>
        /// <returns>The total number of cyborgs available</returns>
        public int CalculateTotalCyborgsAvailableToSend()
        {
            int cyborgsAvailableToSend = 0;
            foreach (FactoryEntity sourceFactory in _internalState.MyFactories)
            {
                cyborgsAvailableToSend += sourceFactory.NumberOfCyborgs;
            }
            return cyborgsAvailableToSend;
        }
        /// <summary>
        /// Calculate the number of cyborgs that can be used to send elsewhere taking defense into consideration
        /// </summary>
        /// <param name="sourceFactory">The source factory to check</param>
        /// <returns>The number of cyborgs available</returns>
        public int CalculateCyborgsAvailableToSend(FactoryEntity sourceFactory)
        {
            int cyborgsToDefend = GetCyborgDefense(sourceFactory);
            int available = 0;
            if (cyborgsToDefend < sourceFactory.NumberOfCyborgs)
                available = sourceFactory.NumberOfCyborgs - cyborgsToDefend;
            Console.Error.WriteLine($"***Source: {sourceFactory.Id} Defense: {cyborgsToDefend} Available: {available}");
            return available;
        }
        //Checks for bombs in play and evacuates the source factory
        public void BombEvacuation(MoveList moves, FactoryEntity sourceFactory)
        {
            if (_internalState.EnemyBombs.Any())
            {
                List<FactoryEntity> friendlyFactories = _internalState.MyFactories;
                int minDist = 9999;
                int minDistNon3 = 9999;
                FactoryEntity bestNon3ProductionFactory = null;
                FactoryEntity bestFactory = null;
                foreach (Node n in _internalState.Links.GetLinks(sourceFactory.Id))
                {
                    FactoryEntity factory = friendlyFactories.FirstOrDefault(f => f.Id == n.FactoryId);
                    if (factory != null)
                    {
                        if (n.Distance < minDist)
                        {
                            minDist = n.Distance;
                            bestFactory = factory;
                        }
                        if (n.Distance < minDistNon3 && factory.ProductionCount < 3)
                        {
                            bestNon3ProductionFactory = factory;
                            minDistNon3 = n.Distance;
                        }
                    }
                }
                if (bestNon3ProductionFactory != null)
                {
                    Console.Error.WriteLine("Evacuating " + sourceFactory.Id + " to " + bestNon3ProductionFactory.Id);
                    Move move = new Move(sourceFactory.Id, bestNon3ProductionFactory.Id, CalculateCyborgsAvailableToSend(sourceFactory));
                    moves.AddMove(move);
                    _internalState.PlayMove(move, Owner.Me);
                }
                else if (bestFactory != null)
                {
                    Console.Error.WriteLine("Evacuating " + sourceFactory.Id + " to " + bestFactory.Id);
                    moves.AddMove(new Move(sourceFactory.Id, bestFactory.Id, CalculateCyborgsAvailableToSend(sourceFactory)));
                }
                else
                {
                    Console.Error.WriteLine("No factory found to evacuate to...");
                }
            }
        }
        public void PlayMultiFactoryTakeoverMoves(MoveList moves, List<MoveOption> moveOptions)
        {
            //Might need to handle 2 different multi-factory takeovers against more than 1 target; currently assumes that if all are on target then we fulfilled the amount to take over
            bool didPlayMove = false;
            foreach (MoveOption move in moveOptions)
            {
                //Play every move that isn't at the target;
                if (move.TargetFactory.Id != move.BestTargetId)
                {
                    Console.Error.WriteLine("Move not on target: " + move.TargetFactory.Id + " adapted: " + move.BestTargetId);
                    moves.AddMove(move.GenerateMove());
                    didPlayMove = true;
                }
            }
            //If all moves go to target then play all of them.
            if (!didPlayMove)
            {
                Console.Error.WriteLine("Playing all multifactory target moves.");
                foreach (MoveOption move in moveOptions)
                {
                    moves.AddMove(move.GenerateMove());
                }
            }
        }
        public bool IsFrontLineFactory(FactoryEntity factory)
        {
            List<Node> adjacentFactories = _internalState.Links.GetLinks(factory.Id);
            foreach (Node n in adjacentFactories)
            {
                if (n.Distance < 5 && _internalState.EnemyFactories.Where(e => e.Id == n.FactoryId).Any())
                {
                    //Console.Error.WriteLine("Factory: " + factory.Id + " is frontline.  Distance: " + n.Distance + " to " + n.FactoryId);
                    return true;
                }
            }
            //Console.Error.WriteLine("Factory: " + factory.Id + " is not frontline.");
            return false;
        }
        /// <summary>
        /// Gets the total number of cyborgs required to keep control of a factory
        /// </summary>
        /// <param name="sourceFactory">The factory we currently have under our control</param>
        /// <returns>The number of cyborgs required to stay in control</returns>
        public int GetCyborgDefense(FactoryEntity sourceFactory)
        {
            int cyborgsToDefend = 0;
            List<TroopEntity> enemyTroops = _internalState.EnemyTroops;
            if (sourceFactory.ProductionCount == 0)
            {
                return 0;//do not defend 0 production sites..
            }
            int minArrival = 9999;
            foreach (TroopEntity enemyTroop in enemyTroops)
            {
                if (enemyTroop.TargetFactory == sourceFactory.Id)
                {
                    cyborgsToDefend += enemyTroop.NumberOfCyborgs;
                    if (minArrival > enemyTroop.TurnsToArrive)
                    {
                        minArrival = enemyTroop.TurnsToArrive;
                    }
                }
            }
            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories;
            foreach (FactoryEntity enemyFactory in enemyFactories)
            {
                int dist = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, enemyFactory.Id);
                if (dist <= 2 && dist <= minArrival)
                {
                    cyborgsToDefend += enemyFactory.NumberOfCyborgs;
                    minArrival = dist;
                }
            }
            if (cyborgsToDefend != 0)
            {
                Console.Error.WriteLine("Source: " + sourceFactory.Id + " Incoming: " + cyborgsToDefend + " arrival: " + minArrival);
            }
            cyborgsToDefend -= minArrival * sourceFactory.ProductionCount;
            cyborgsToDefend = cyborgsToDefend < 0 ? 0 : cyborgsToDefend;
            return cyborgsToDefend;
        }
        //Decides whether or not to use bomb after all movements have been declared
        public void UseBomb(MoveList moves)
        {
            List<BombEntity> bombs = _internalState.MyBombs;
            List<TroopEntity> friendlyTroops = _internalState.MyTroops;
            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories;
            FactoryEntity bestTargetFactory = null;
            int bestVal = -9999;
            foreach (FactoryEntity targetFactory in enemyFactories)
            {
                bool targetHasTroops = false;
                int val = 0;
                int troopCount = 0;
                foreach (TroopEntity troop in friendlyTroops)
                {
                    if (troop.TargetFactory == targetFactory.Id)
                    {
                        troopCount += troop.NumberOfCyborgs;
                    }
                }
                if (troopCount > 0)
                {
                    targetHasTroops = true;
                }
                bool targetHasBomb = bombs.Any() && bombs.First().TargetFactoryId == targetFactory.Id;
                bool targetLevel2 = targetFactory.ProductionCount == 2 && targetFactory.NumberOfCyborgs > 5 && targetFactory.IsProducing();
                bool targetLevel3 = targetFactory.ProductionCount == 3 && targetFactory.IsProducing();
                if ((targetLevel3 || targetLevel2) && !targetHasBomb && !targetHasTroops)
                {
                    val += targetFactory.NumberOfCyborgs;
                    val += targetFactory.ProductionCount * 5;
                    if (val > bestVal)
                    {
                        bestTargetFactory = targetFactory;
                    }
                }
            }
            if (bestTargetFactory != null)
            {
                Console.Error.WriteLine("Bombing: " + bestTargetFactory.Id + " with production: " + bestTargetFactory.ProductionCount);
                List<FactoryEntity> friendlyFactories = _internalState.MyFactories;
                FactoryEntity bestSource = null;
                int minDist = 99999;
                foreach (FactoryEntity sourceFactory in friendlyFactories)
                {
                    int currentDistance = _internalState.Links.GetDistance(sourceFactory.Id, bestTargetFactory.Id);
                    if (currentDistance < minDist)//Distance can't be limited; just pick the best option...
                    {
                        minDist = currentDistance;
                        bestSource = sourceFactory;
                    }
                }
                if (bestSource != null)
                {
                    Move move = new Move(bestSource.Id, bestTargetFactory.Id);
                    moves.AddMove(move);
                    _internalState.PlayMove(move, Owner.Me);
                }
            }
        }
        //Calculates the number of cyborgs required to takeover a factory
        public int CalculateCyborgsRequiredToTakeover(FactoryEntity sourceFactory, FactoryEntity targetFactory)
        {
            int cyborgs = 1;//minimum to takeover is 1
            List<TroopEntity> troops = _internalState.Troops;
            Dictionary<int, int> timeToEnemyTroops = new Dictionary<int, int>();
            Dictionary<int, int> timeToFriendlyTroops = new Dictionary<int, int>();
            //Console.Error.WriteLine(" Target: " + targetFactory.Id);
            //Check the incoming troop count
            foreach (TroopEntity troop in troops)
            {
                if (troop.TargetFactory == targetFactory.Id)
                {
                    if (troop.IsFriendly())
                    {
                        if (timeToFriendlyTroops.ContainsKey(troop.TurnsToArrive))
                        {
                            timeToFriendlyTroops[troop.TurnsToArrive] += troop.NumberOfCyborgs;
                        }
                        else
                        {
                            timeToFriendlyTroops[troop.TurnsToArrive] = troop.NumberOfCyborgs;
                        }
                    }
                    else if (troop.IsEnemy())
                    {
                        //Console.Error.WriteLine("Enemy troop count: " + troop.NumberOfCyborgs + " arrives: " + troop.TurnsToArrive);
                        if (timeToEnemyTroops.ContainsKey(troop.TurnsToArrive))
                        {
                            timeToEnemyTroops[troop.TurnsToArrive] += troop.NumberOfCyborgs;
                        }
                        else
                        {
                            timeToEnemyTroops[troop.TurnsToArrive] = troop.NumberOfCyborgs;
                        }
                    }
                }
            }
            //Add check for cyborgs sitting in factories that could be sent and assume they will be sent...
            List<FactoryEntity> enemyFactories = _internalState.EnemyFactories.Where(e => e.Id != targetFactory.Id).ToList();
            foreach (FactoryEntity enemyFactory in enemyFactories)
            {
                int time = _internalState.Links.GetShortestPathDistance(targetFactory.Id, enemyFactory.Id);
                if (targetFactory.IsEnemy())
                {
                    if (timeToEnemyTroops.ContainsKey(time))
                    {
                        timeToEnemyTroops[time] += enemyFactory.NumberOfCyborgs;
                    }
                    else
                    {
                        timeToEnemyTroops[time] = enemyFactory.NumberOfCyborgs;
                    }
                }
            }
            int distance = _internalState.Links.GetShortestPathDistance(sourceFactory.Id, targetFactory.Id);
            Owner previousOwnership = targetFactory.Owner;
            List<BombEntity> friendlyBombs = _internalState.MyBombs;
            BombEntity friendlyBomb = null;
            if (friendlyBombs.Any())
            {
                friendlyBomb = friendlyBombs.First() as BombEntity;
                if (friendlyBomb.TurnsToArrive >= distance && friendlyBomb.TargetFactoryId == targetFactory.Id)
                {
                    return 999999;//Don't send troops where a bomb is going to explode after we send troops
                }
                //Console.Error.WriteLine("Bomb: " + friendlyBomb.Id + " Target: " + friendlyBomb.TargetFactory + " Time: " + friendlyBomb.TurnsToArrive);
            }
            //Calculate the number of cyborgs in the factory up to the distance of the source factory
            int cyborgsInFactory = targetFactory.NumberOfCyborgs;
            int bombCount = 0;
            for (int i = 1; i <= distance; i++)
            {
                timeToFriendlyTroops.TryGetValue(i, out int friendlyCount);
                timeToEnemyTroops.TryGetValue(i, out int enemyCount);
                bool isBomb = false;
                if (targetFactory.Id == 2)
                {
                    //Console.Error.WriteLine("Own: " + previousOwnership + " Borg: " + cyborgsInFactory + " Dist: " + distance);
                    //Console.Error.WriteLine("Friend: " + friendlyCount + " Enemy: " + enemyCount + " Time: " + i);
                }
                if (friendlyBomb != null && friendlyBomb.TargetFactoryId == targetFactory.Id && friendlyBomb.TurnsToArrive == i)
                {
                    bombCount = 5;//bombs disrupt production for 5 turns starting with the turn it goes off
                    isBomb = true;
                }
                switch (previousOwnership)
                {
                    case Owner.Me:
                        if ((targetFactory.IsProducing() || targetFactory.TurnsTillProduction - i < 1) && bombCount <= 0)
                        {
                            cyborgsInFactory += targetFactory.ProductionCount;
                        }
                        cyborgsInFactory += friendlyCount - enemyCount;
                        if (isBomb)
                        {
                            int cyborgsLost = (int)Math.Floor(cyborgsInFactory / 2.0);
                            cyborgsLost = cyborgsLost < 10 ? Math.Min(10, cyborgsInFactory) : cyborgsLost;
                            cyborgsInFactory -= cyborgsLost;
                        }
                        if (cyborgsInFactory < 0)
                        {
                            previousOwnership = Owner.Opponent;
                            cyborgsInFactory *= -1;
                            //Console.Error.WriteLine("We own the factory by " + i);
                        }
                        break;
                    case Owner.Neutral:
                        cyborgsInFactory -= Math.Abs(friendlyCount - enemyCount);
                        if (cyborgsInFactory < 0)
                        {
                            previousOwnership = friendlyCount > enemyCount ? Owner.Me : Owner.Opponent;
                            cyborgsInFactory *= -1;
                        }
                        break;
                    case Owner.Opponent:
                        if ((targetFactory.IsProducing() || targetFactory.TurnsTillProduction - i < 1) && bombCount <= 0)
                        {
                            cyborgsInFactory += targetFactory.ProductionCount;
                        }
                        cyborgsInFactory += enemyCount - friendlyCount;
                        if (isBomb)
                        {
                            int cyborgsLost = (int)Math.Floor(cyborgsInFactory / 2.0);
                            cyborgsLost = cyborgsLost < 10 ? Math.Min(10, cyborgsInFactory) : cyborgsLost;
                            cyborgsInFactory -= cyborgsLost;
                            //Console.Error.WriteLine("Target: " + targetFactory.Id + " Current: " + cyborgsInFactory + " Bomb: " + cyborgsLost);
                        }
                        if (cyborgsInFactory < 0)
                        {
                            previousOwnership = Owner.Me;
                            cyborgsInFactory *= -1;
                            //Console.Error.WriteLine("Enemy owns the factory by " + i);
                        }
                        break;
                }
                bombCount--;
            }
            if (previousOwnership == Owner.Me)
            {
                return 0;//I already own it; no more borgs required to takeover
            }
            cyborgs += cyborgsInFactory;
            return cyborgs;
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Moves
{
    public class Move
    {
        private readonly int source;
        private readonly int destination;
        private readonly int count;
        private readonly string moveType;
        private readonly string message;
        public Move()
        {
            moveType = MoveType.Wait;
        }
        public Move(int factoryId)
        {
            source = factoryId;
            moveType = MoveType.Upgrade;
        }
        public Move(int sourceFactory, int destinationFactory, int cyborgCount)
        {
            source = sourceFactory;
            destination = destinationFactory;
            count = cyborgCount;
            moveType = MoveType.Move;
        }
        public Move(int sourceFactory, int destinationFactory)
        {
            moveType = MoveType.Bomb;
            source = sourceFactory;
            destination = destinationFactory;
        }
        public Move(string message)
        {
            moveType = MoveType.Message;
            this.message = message;
        }
        public string GetMove()
        {
            string move = moveType switch
            {
                MoveType.Move => MoveType.Move + " " + source + " " + destination + " " + count,
                MoveType.Wait => MoveType.Wait,
                MoveType.Bomb => MoveType.Bomb + " " + source + " " + destination,
                MoveType.Message => MoveType.Message + " " + message,
                MoveType.Upgrade => MoveType.Upgrade + " " + source,
                _ => MoveType.Wait
            };
            return move;
        }
        public void PlayMove()
        {
            Console.Write(GetMove());
        }
    }
}
//*** SourceCombiner -> original file MoveList.cs ***
namespace GameSolution.Moves
{
    public class MoveList
    {
        public List<Move> Moves { get; set; }
        public MoveList()
        {
            Moves = new List<Move>();
        }
        public void AddMove(Move move)
        {
            Moves.Add(move);
        }
        public void PlayMoves()
        {
            bool isFirst = true;
            foreach (Move move in Moves)
            {
                if (!isFirst)
                {
                    Console.Write(";");
                }
                move.PlayMove();
                isFirst = false;
            }
            Console.WriteLine();
        }
    }
}
//*** SourceCombiner -> original file MoveOption.cs ***
namespace GameSolution.Moves
{
    public class MoveOption
    {
        public FactoryEntity SourceFactory { get; set; }
        public FactoryEntity TargetFactory { get; set; }
        public int SendCount { get; set; }
        public int BestTargetId { get; set; }
        public MoveOption(FactoryEntity sourceFactory, FactoryEntity targetFactory, int sendCount, int bestTargetId)
        {
            SourceFactory = sourceFactory;
            TargetFactory = targetFactory;
            SendCount = sendCount;
            BestTargetId = bestTargetId;
        }
        public Move GenerateMove()
        {
            return new Move(SourceFactory.Id, BestTargetId, SendCount);
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
public class Player
{
    static void Main(string[] args)
    {
        FactoryLinks links = new FactoryLinks();
        string[] inputs;
        int factoryCount = int.Parse(Console.ReadLine()); // the number of factories
        int linkCount = int.Parse(Console.ReadLine()); // the number of links between factories
        for (int i = 0; i < linkCount; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int factory1 = int.Parse(inputs[0]);
            int factory2 = int.Parse(inputs[1]);
            int distance = int.Parse(inputs[2]);
            links.AddLink(factory1, factory2, distance);
        }
        Console.Error.WriteLine(factoryCount);
        Console.Error.WriteLine(linkCount);
        links.CalculateShortestPaths();
        GameState gs = new GameState(links);
        // game loop
        while (true)
        {
            int entityCount = int.Parse(Console.ReadLine()); // the number of entities (e.g. factories and troops)
            List<Entity> entities = new List<Entity>();
            Console.Error.WriteLine(entities.Count);
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int entityId = int.Parse(inputs[0]);
                string entityType = inputs[1];
                int arg1 = int.Parse(inputs[2]);
                int arg2 = int.Parse(inputs[3]);
                int arg3 = int.Parse(inputs[4]);
                int arg4 = int.Parse(inputs[5]);
                int arg5 = int.Parse(inputs[6]);
                entities.Add(EntityFactory.CreateEntity(entityType, entityId, arg1, arg2, arg3, arg4, arg5));
            }
            Console.Error.WriteLine($"Found invalid entities: {entities.Where(e => e.Id == -1).Count()}");
            gs.SetEntities(entities);
            gs.ShowStats();
            GameHelper gh = new GameHelper(gs);
            MoveList moves = gh.PickMoves();
            moves.PlayMoves();
        }
    }
}
//*** SourceCombiner -> original file TroopEntity.cs ***
namespace GameSolution.Entities
{
    public class TroopEntity : Entity
    {
        public int SourceFactory
        {
            get { return Arg2; }
        }
        public int TargetFactory
        {
            get { return Arg3; }
        }
        public int NumberOfCyborgs
        {
            get { return Arg4; }
        }
        public int TurnsToArrive
        {
            get { return Arg5; }
        }
        /// <summary>
        /// Creates a new Troop Entity
        /// </summary>
        /// <param name="id">Unique Identifier</param>
        /// <param name="arg1">Owner</param>
        /// <param name="arg2">Source factory Id</param>
        /// <param name="arg3">Target factory Id</param>
        /// <param name="arg4">Number of cyborgs in the troop</param>
        /// <param name="arg5">Number of turns until arrival</param>
        public TroopEntity(int id, int arg1, int arg2, int arg3, int arg4, int arg5)
        : base(id, arg1, arg2, arg3, arg4, arg5)
        {
        }
        public TroopEntity(TroopEntity entity) : base(entity)
        {
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Utility
{
    public class GameState
    {
        public int EnemyBombCount { get; private set; } = 2;
        public int MyBombCount { get; private set; } = 2;
        public int GameCounter { get; private set; } = 0;
        public int EnemyTroopsCount { get; private set; } = 0;
        public int MyTroopsCount { get; private set; } = 0;
        public int EnemyIncome { get; private set; } = 0;
        public int MyIncome { get; private set; } = 0;
        public FactoryLinks Links { get; private set; }
        public List<Entity> Entities { get; private set; }
        public List<FactoryEntity> Factories { get; private set; }
        public List<FactoryEntity> MyFactories { get; private set; }
        public List<FactoryEntity> EnemyFactories { get; private set; }
        public List<FactoryEntity> NeutralFactories { get; private set; }
        public List<BombEntity> Bombs { get; private set; }
        public List<BombEntity> MyBombs { get; private set; }
        public List<BombEntity> EnemyBombs { get; private set; }
        public List<TroopEntity> Troops { get; private set; }
        public List<TroopEntity> MyTroops { get; private set; }
        public List<TroopEntity> EnemyTroops { get; private set; }
        //Track bombs that have been sent
        private List<int> _bombIdSent = new List<int>();
        public GameState(FactoryLinks links)
        {
            Links = links;
        }
        public GameState(GameState state)
        {
            _bombIdSent = state.CopyBombsSent();
            //Because we are already tracking bombs that have been sent we have to copy over the bomb counts
            MyBombCount = state.MyBombCount;
            EnemyBombCount = state.EnemyBombCount;
            GameCounter = state.GameCounter;
            Links = state.Links;//Shouldn't be modified
            Entities = state.Entities.Select(e => EntityFactory.CreateEntity(e)).ToList();//Clone the entities as we want to update this
            UpdateGameState();
            CalculateStats();
        }
        public List<int> CopyBombsSent()
        {
            return new List<int>(_bombIdSent);
        }
        public void PlayMove(Move move, Owner owner)
        {
            //Should we check if it's legal??
            string strMove = move.GetMove();
            List<string> moveArgs = strMove.Split(' ').ToList();
            int source, target;
            FactoryEntity sourceFactory;
            switch (moveArgs[0])
            {
                case MoveType.Bomb:
                    source = Convert.ToInt32(moveArgs[1]);
                    target = Convert.ToInt32(moveArgs[2]);
                    Entities.Add(EntityFactory.CreateEntity(EntityTypes.Bomb, -1, (int)owner, source, target, Links.GetDistance(source, target), 0));
                    if (owner == Owner.Me)
                        MyBombCount--;
                    else EnemyBombCount--;
                    UpdateGameState();
                    break;
                case MoveType.Move:
                    source = Convert.ToInt32(moveArgs[1]);
                    target = Convert.ToInt32(moveArgs[2]);
                    int cyborgCount = Convert.ToInt32(moveArgs[3]);
                    sourceFactory = Factories.First(e => e.Id == source);
                    sourceFactory.Move(cyborgCount);
                    Entities.Add(EntityFactory.CreateEntity(EntityTypes.Troop, -1, (int)owner, source, target, cyborgCount, Links.GetDistance(source, target)));
                    UpdateGameState();
                    break;
                case MoveType.Upgrade:
                    source = Convert.ToInt32(moveArgs[1]);
                    sourceFactory = Factories.First(e => e.Id == source);
                    sourceFactory.Upgrade();
                    if (owner == Owner.Me)
                        MyTroopsCount -= 10;
                    else EnemyTroopsCount -= 10;
                    break;
            }
        }
        /// <summary>
        /// Setup entities for this turn
        /// </summary>
        /// <param name="entites">The entities to fill the game state</param>
        public void SetEntities(List<Entity> entites)
        {
            Entities = entites;
            UpdateGameState();
            CalculateStats();
            GameCounter++;
        }
        /// <summary>
        /// Updates the various shortcut lists.
        /// </summary>
        private void UpdateGameState()
        {
            Factories = Entities.Where(e => e is FactoryEntity).Select(e => e as FactoryEntity).ToList();
            MyFactories = Factories.Where(e => e.IsFriendly()).ToList();
            EnemyFactories = Factories.Where(e => e.IsEnemy()).ToList();
            NeutralFactories = Factories.Where(e => e.IsNeutral()).ToList();
            Bombs = Entities.Where(e => e is BombEntity).Select(e => e as BombEntity).ToList();
            MyBombs = Bombs.Where(e => e.IsFriendly()).ToList();
            EnemyBombs = Bombs.Where(e => e.IsEnemy()).ToList();
            Troops = Entities.Where(e => e is TroopEntity).Select(e => e as TroopEntity).ToList();
            MyTroops = Troops.Where(e => e.IsFriendly()).ToList();
            EnemyTroops = Troops.Where(e => e.IsEnemy()).ToList();
        }
        /// <summary>
        /// Calculates the various statistics
        /// </summary>
        private void CalculateStats()
        {
            EnemyIncome = 0;
            MyIncome = 0;
            MyTroopsCount = 0;
            EnemyTroopsCount = 0;
            foreach (FactoryEntity factory in Factories)
            {
                if (factory.IsProducing())
                {
                    if (factory.IsFriendly())
                    {
                        MyIncome += factory.ProductionCount;
                    }
                    else if (factory.IsEnemy())
                    {
                        EnemyIncome += factory.ProductionCount;
                    }
                }
                if (factory.IsFriendly())
                {
                    MyTroopsCount += factory.NumberOfCyborgs;
                }
                else if (factory.IsEnemy())
                {
                    EnemyTroopsCount += factory.NumberOfCyborgs;
                }
            }
            foreach (TroopEntity troop in Troops)
            {
                if (troop.IsFriendly())
                {
                    MyTroopsCount += troop.NumberOfCyborgs;
                }
                else if (troop.IsEnemy())
                {
                    EnemyTroopsCount += troop.NumberOfCyborgs;
                }
            }
            foreach (BombEntity bomb in Bombs)
            {
                if (!_bombIdSent.Contains(bomb.Id))
                {
                    Console.Error.WriteLine($"Bomb was used {bomb.Id} on target {bomb.TargetFactoryId}.");
                    if (bomb.IsFriendly())
                    {
                        MyBombCount--;
                    }
                    else if (bomb.IsEnemy())
                    {
                        EnemyBombCount--;
                    }
                    _bombIdSent.Add(bomb.Id);
                }
            }
        }
        /// <summary>
        /// Shows the stats in the error log
        /// </summary>
        public void ShowStats()
        {
            Console.Error.WriteLine("Diff: " + (MyTroopsCount - EnemyTroopsCount) + " My Troops: " + MyTroopsCount + " Enemy Troops: " + EnemyTroopsCount);
            Console.Error.WriteLine("Diff: " + (MyIncome - EnemyIncome) + " My Income: " + MyIncome + " Enemy Income: " + EnemyIncome);
            Console.Error.WriteLine($"My Bombs: {MyBombCount}, Enemy Bombs: {EnemyBombCount}");
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace GameSolution.Utility
{
    public class Node
    {
        public int FactoryId { get; set; }
        public int Distance { get; set; }
        public Node(int factory, int distance)
        {
            FactoryId = factory;
            Distance = distance;
        }
        /// <summary>
        /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
        /// </summary>
        /// <param name="currentDist">The current distance from the starting factory</param>
        /// <returns>A clone of the node with the proper distance</returns>
        public Node CreateAtDistance(int currentDist)
        {
            return new Node(FactoryId, currentDist + Distance);
        }
    }
}
