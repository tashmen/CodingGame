/*
 * File generated by SourceCombiner.exe using 2 source files.
 * Created On: 8/8/2021 9:39:06 AM
*/
using Algorithms.Graph;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 2 source files.
 * Created On: 8/8/2021 9:28:50 AM
*/
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        private Dictionary<int, List<Node>> Links { get; set; }
        private Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        private bool IsByDirectional;
        public GraphLinks(bool isByDirectional = true)
        {
            Links = new Dictionary<int, List<Node>>();
            IsByDirectional = isByDirectional;
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, double distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            AddLinkInternal(id1, id2, distance);
            if(IsByDirectional)
                AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            double currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        /// <summary>
        /// Retrieves the full path from start to end
        /// </summary>
        /// <param name="startId">the start id</param>
        /// <param name="endId">the end id</param>
        /// <returns>The full path</returns>
        public List<Node> GetShortestPathAll(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        //Adds links to the node links
        private void AddLinkInternal(int startNode, int endNode, double distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace Algorithms.Graph
{
    public class Node
    {
        public int Id { get; set; }
        public double Distance { get; set; }
        public bool IsExplored { get; set; }
        public Node(int id, double distance)
        {
            Id = id;
            Distance = distance;
        }
        /// <summary>
        /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
        /// </summary>
        /// <param name="currentDist">The current distance from the starting node</param>
        /// <returns>A clone of the node with the proper distance</returns>
        public Node CreateAtDistance(double currentDist)
        {
            return new Node(Id, currentDist + Distance);
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Solution
{
    public class TrainStop
    {
        public string Id;
        public string Name;
        public double Latitude;
        public double Longitude;
        public TrainStop(string fullString)
        {
            string[] attributes = fullString.Split(',');
            Id = attributes[0];
            Name = attributes[1].Replace('"', ' ').Trim();
            Latitude = double.Parse(attributes[3]);
            Longitude = double.Parse(attributes[4]);
        }
        public double CalculateDistance(TrainStop stop)
        {
            double distance = 0;
            double x = (stop.Longitude - Longitude) * Math.Cos((Latitude + stop.Latitude) / 2);
            double y = stop.Latitude - Latitude;
            distance = Math.Sqrt(x * x + y * y) * 6371;
            return distance;
        }
    }
    static void Main(string[] args)
    {
        GraphLinks graphLinks = new GraphLinks(false);
        string startPoint = Console.ReadLine();
        string endPoint = Console.ReadLine();
        int N = int.Parse(Console.ReadLine());
        Dictionary<string, TrainStop> trainStops = new Dictionary<string, TrainStop>();
        for (int i = 0; i < N; i++)
        {
            string stopName = Console.ReadLine();
            TrainStop stop = new TrainStop(stopName);
            trainStops[stop.Id] = stop;
        }
        int M = int.Parse(Console.ReadLine());
        for (int i = 0; i < M; i++)
        {
            string route = Console.ReadLine();
            if (!string.IsNullOrEmpty(route))
            {
                string[] stopIds = route.Split(' ');
                TrainStop stop1 = trainStops[stopIds[0]];
                TrainStop stop2 = trainStops[stopIds[1]];
                graphLinks.AddLink(GenerateId(stopIds[0]), GenerateId(stopIds[1]), stop1.CalculateDistance(stop2));
            }
        }
        graphLinks.CalculateShortestPathsFromStartNode(GenerateId(startPoint), 999999999);
        try
        {
            List<Node> path = graphLinks.GetShortestPathAll(GenerateId(startPoint), GenerateId(endPoint));
            Console.WriteLine(trainStops[startPoint].Name);
            foreach (Node n in path)
            {
                TrainStop stop = trainStops[LinkIdToTrainId[n.Id]];
                Console.WriteLine(stop.Name);
            }
        }
        catch(Exception ex)
        {
            if (startPoint == endPoint)
            {
                Console.WriteLine(trainStops[startPoint].Name);
            }
            else
            {
                Console.WriteLine("IMPOSSIBLE");
            }
        }     
    }
    public static Dictionary<int, string> LinkIdToTrainId = new Dictionary<int, string>();
    static int GenerateId(string trainId)
    {
        var code = trainId.GetHashCode();
        LinkIdToTrainId[code] = trainId;
        return code;
    }
}
