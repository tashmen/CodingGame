/*
 * File generated by SourceCombiner.exe using 9 source files.
 * Created On: 10/6/2022 2:58:24 PM
*/
using Algorithms.GameComponent;
using Algorithms.Space;
using Algorithms.Trees;
using Algorithms.Utility;
using GameSolution;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
//*** SourceCombiner -> original file Player.cs ***
/**
 * Convert neutral units and attack enemy ones
 **/
class Player
{
    static void Main(string[] args)
    {
        bool isFirstTurn = true;
        int turn = 0;
        string[] inputs;
        int myId = int.Parse(Console.ReadLine()); // 0 - you are the first player, 1 - you are the second player
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // Width of the board
        int height = int.Parse(inputs[1]); // Height of the board
        string[] strBoard = new string[height];
        for (int i = 0; i < height; i++)
        {
            strBoard[i] = Console.ReadLine(); // A y of the board: "." is empty, "x" is obstacle
            //Console.Error.WriteLine(strBoard[i]);
        }
        Board board = new Board(strBoard);
        MonteCarloTreeSearch monteCarlo = new MonteCarloTreeSearch(true);
        //Minimax miniMax = new Minimax();
        GameState state = new GameState(board);
        //When I am second player then adjust the starting seed and turn
        if(myId == 1)
        {
            turn++;
            InternalRandom.rand(ref state.Seed, 5);
            InternalRandom.rand(ref state.Seed, 5);
        }
        // game loop
        while (true)
        {
            Entity[] entities = new Entity[14];
            int numOfUnits = int.Parse(Console.ReadLine()); // The total number of units on the board
            for (int i = 0; i < numOfUnits; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int unitId = int.Parse(inputs[0]); // The unit's ID
                int unitType = int.Parse(inputs[1]); // The unit's type: 0 = Cultist, 1 = Cult Leader
                int hp = int.Parse(inputs[2]); // Health points of the unit
                int x = int.Parse(inputs[3]); // X coordinate of the unit
                int y = int.Parse(inputs[4]); // Y coordinate of the unit
                int owner = int.Parse(inputs[5]); // id of owner player
                OwnerType isMine = owner == myId ? OwnerType.Max : owner == 2 ? OwnerType.Neutral : OwnerType.Min;
                entities[unitId] = new Entity(unitId, x, y, unitType, hp, (int)isMine);
                //Console.Error.WriteLine(entities[unitId]);
            }
            state.Turn = turn;
            state.SetState(entities);
            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            var limit = isFirstTurn ? 980 : 45;
            GC.Collect();
            Stopwatch watch = new Stopwatch();
            watch.Start();
            try
            {
                monteCarlo.SetState(state);
            }
            catch (Exception ex)
            {
                GameState currentState = (GameState)monteCarlo.GetRootState();
                for (int i = 0; i < height; i++)
                {
                    Console.Error.WriteLine($"\"{strBoard[i]}\",");
                }
                for(int i = 0; i< currentState.Entities.Length; i++)
                {
                    if(entities[i] != null)
                        Console.Error.WriteLine($"new Entity({currentState.Entities[i]}),");
                    else Console.Error.WriteLine($"null,");
                }
                Console.Error.WriteLine("Last Move: " + Move.ToString(currentState.LastMove));
                Console.Error.WriteLine("Last Neutral Move: " + Move.ToString(currentState.NeutralLastMove));
                Console.Error.WriteLine("Seed: " + currentState.Seed);
                monteCarlo.SetState(state, true, false);
            }
            //miniMax.SetState(state);
            long move;
            move = (long)monteCarlo.GetNextMove(watch, limit, 40, 5, 0.5);
            //move = (Move)miniMax.GetNextMove(watch, limit, 5);
            watch.Stop();
            Console.Error.WriteLine($"MS: {watch.ElapsedMilliseconds}");
            /*
            var cloneState = (GameState)monteCarlo.GetRootState().Clone();
            cloneState.ApplyMove(move, true);
            Console.Error.WriteLine($"Neutral move: {Move.ToString(cloneState.NeutralLastMove)}");
            var moves = (List<long>)cloneState.GetPossibleMoves(false);
            foreach (long oppMove in moves)
            {
                var cs = (GameState)cloneState.Clone();
                cs.ApplyMove(oppMove, false);
                Console.Error.WriteLine($"Neutral move for opponent: {Move.ToString(cs.NeutralLastMove)} for move {Move.ToString(oppMove)}");
            }
            */
            turn += 2;
            Console.WriteLine(Move.ToString(move));
            isFirstTurn = false;
        }
    }
}
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 5/20/2022 6:19:03 PM
*/
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms.GameComponent
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        IList GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(object move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        object GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        double? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
        /// <summary>
        /// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
        /// </summary>
        /// <param name="isMax">true if it is max's turn else false</param>
        /// <returns>A number between [-1, 1]</returns>
        double Evaluate(bool isMax);
    }
}
//*** SourceCombiner -> original file Graph.cs ***
namespace Algorithms.Graph
{
    public class Graph
    {
        private List<INode> Nodes;
        //Will hold shortest paths from a start node id to an end node id
        private Dictionary<int, Dictionary<int, List<ILink>>> Paths;
        public Graph()
        {
            Nodes = new List<INode>();
        }
        public void AddNode(INode node)
        {
            Nodes.Add(node);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            foreach (INode vertex in Nodes)
            {
                InternalBuildShortestPathsFromStartNode(vertex);
            }
        }
        public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            InternalBuildShortestPathsFromStartNode(startNode, maxDistance);
        }
        private void InternalBuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            foreach (INode node in Nodes)
            {
                node.IsExplored = false;
            }
            List<ILink> minimumSpanningTree = new List<ILink>();
            Paths[startNode.Id] = new Dictionary<int, List<ILink>>();
            Paths[startNode.Id][startNode.Id] = new List<ILink>();
            minimumSpanningTree.Add(new Link(startNode, startNode, 0));
            int vertexCount = Nodes.Count;
            double currentDist;
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                ILink bestLink = null;
                ILink parentLink = null;
                foreach (ILink currentLink in minimumSpanningTree)
                {
                    INode currentNode = currentLink.EndNode;
                    currentDist = currentLink.GetDistance(Paths[startNode.Id][currentNode.Id]);
                    foreach (ILink adjacent in currentNode.GetLinks())
                    {
                        INode adjacentNode = adjacent.EndNode;
                        if (adjacentNode.IsExplored)
                        {
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestLink = adjacent;
                            parentLink = currentLink;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode.Id].TryGetValue(currentNode.Id, out List<ILink> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode.Id].TryGetValue(parentLink.EndNode.Id, out List<ILink> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestLink = adjacent;
                                parentLink = currentLink;
                            }
                        }
                    }
                }
                if (parentLink == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestLink);
                bestLink.EndNode.IsExplored = true;
                List<ILink> currentPath = null;
                if (!parentLink.EndNode.Equals(startNode))
                {
                    Paths[startNode.Id].TryGetValue(parentLink.EndNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<ILink>();
                }
                else
                {
                    currentPath = new List<ILink>(currentPath);
                }
                Paths[startNode.Id].Add(bestLink.EndNode.Id, currentPath);
                currentPath.Add(bestLink);
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The next node in the path</returns>
        public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startNode.Id);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
                throw new InvalidOperationException();
            }
            INode shortest = paths.First().EndNode;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
            return shortest;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                return double.MaxValue;
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                return double.MaxValue;
            }
            return paths.First().GetDistance(paths);
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(Node startNode, Node endNode)
        {
            return startNode.GetLinks().Where(l => l.EndNode.Equals(endNode)).First().Distance;
        }
    }
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        public class Node
        {
            public int Id;
            public double Distance;
            public bool IsExplored;
            public Node(int id, double distance)
            {
                Id = id;
                Distance = distance;
            }
            /// <summary>
            /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
            /// </summary>
            /// <param name="currentDist">The current distance from the starting node</param>
            /// <returns>A clone of the node with the proper distance</returns>
            public Node CreateAtDistance(double currentDist)
            {
                return new Node(Id, currentDist + Distance);
            }
        }
        private Dictionary<int, List<Node>> Links;
        private Dictionary<int, Dictionary<int, List<Node>>> Paths;
        private bool IsByDirectional;
        public GraphLinks(bool isByDirectional = true)
        {
            Links = new Dictionary<int, List<Node>>();
            IsByDirectional = isByDirectional;
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, double distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            AddLinkInternal(id1, id2, distance);
            if(IsByDirectional)
                AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            double currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        /// <summary>
        /// Retrieves the full path from start to end
        /// </summary>
        /// <param name="startId">the start id</param>
        /// <param name="endId">the end id</param>
        /// <returns>The full path</returns>
        public List<Node> GetShortestPathAll(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        //Adds links to the node links
        private void AddLinkInternal(int startNode, int endNode, double distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
    public interface INode
    {
        int Id { get; }
        bool IsExplored { get; set; }
        List<ILink> GetLinks();
    }
    public class Node : INode
    {
        public int Id { get; private set; }
        public bool IsExplored { get; set; }
        private List<ILink> Links;
        public Node(int id)
        {
            Id = id;
            IsExplored = false;
            Links = new List<ILink>();
        }
        public void AddLink(ILink link)
        {
            Links.Add(link);
        }
        public List<ILink> GetLinks()
        {
            return Links;
        }
        public bool Equals(INode node)
        {
            return node.Id == Id;
        }
    }
    public interface ILink
    {
        INode StartNode { get; }
        INode EndNode { get; }
        long Distance { get; }
        long GetDistance(List<ILink> currentPath);
    }
    public class Link : ILink
    {
        public INode StartNode { get; private set; }
        public INode EndNode { get; private set; }
        public long Distance { get; private set; }
        public Link(INode startNode, INode endNode, long distance)
        {
            StartNode = startNode;
            EndNode = endNode;
            Distance = distance;
        }
        public long GetDistance(List<ILink> currentPath)
        {
            long distance = 0;
            foreach(ILink link in currentPath)
            {
                distance += link.Distance;
            }
            return distance;
        }
    }
}
//*** SourceCombiner -> original file Point2d.cs ***
namespace Algorithms.Space
{
    public class Point2d
    {
        public int x;
        public int y;
        public Point2d(int x, int y)
        {
            this.x = x; 
            this.y = y;
        }
        public Point2d(Point2d point)
        {
            x = point.x;
            y = point.y;
        }
        public override string ToString()
        {
            return $"({x},{y})";
        }
        public int GetManhattenDistance(Point2d point)
        {
            return (Math.Abs(point.x - x) + Math.Abs(point.y - y));
        }
        public override bool Equals(object objPoint)
        {
            Point2d point = objPoint as Point2d;
            return point.x == this.x && point.y == this.y;
        }
        public override int GetHashCode()
        {
            return Tuple.Create(x, y).GetHashCode();
        }
        public Point2d Clone()
        {
            return new Point2d(x, y);
        }
        public void Fill(Point2d point)
        {
            x = point.x;
            y = point.y;
        }
    }
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
    public class GameTreeNode
    {
        public IGameState state;
        public IList moves;
        public List<GameTreeNode> children;
        public double wins = 0;
        public double loses = 0;
        public int totalPlays = 0;
        public GameTreeNode parent;
        public bool isMax;
        public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
        {
            this.state = state;
            moves = new List<object>(50);
            var possibleMoves = state.GetPossibleMoves(isMax);
            for (int i = 0; i < possibleMoves.Count; i++)
            {
                var obj = possibleMoves[i];
                moves.Add(obj);
            }
            children = new List<GameTreeNode>(50);
            this.parent = parent;
            this.isMax = isMax;
        }
        public double GetScore(bool isMax)
        {
            double totalPlays = TotalPlays();
            if (totalPlays == 0)
                return 0;
            if (isMax)
            {
                return (wins - loses) / totalPlays;
            }
            else
            {
                return (loses - wins) / totalPlays;
            }
        }
        public int TotalPlays()
        {
            return totalPlays;
        }
        public double? GetWinner()
        {
            return state.GetWinner();
        }
        public void ApplyWinner(double? winner)
        {
            if (winner.HasValue)
            {
                if(winner > 0)
                {
                    wins += winner.Value;
                }
                else if(winner < 0)
                {
                    loses += Math.Abs(winner.Value);
                }
                totalPlays++;
            }
        }
        public double Evaluate()
        {
            return state.Evaluate(isMax);
        }
    }
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms.Trees
{
    public class Minimax : TreeAlgorithm
    {
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
        {
            double val = 99999999;
            val *= RootNode.isMax ? -1 : 1;
            object bestMove = null;
            foreach (object move in RootNode.moves)
            {
                GameTreeNode child = Expand(RootNode, move);
                double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
                if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
                {
                    bestMove = move;
                    val = currentVal;
                }
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    break;
                }
            }
            return bestMove;
        }
        public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
        {
            if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
            {
                double eval = currentNode.Evaluate();
                return eval;
            }
            double? winner = currentNode.GetWinner();
            if (winner.HasValue)
            {
                return winner.Value;
            }
            if (currentNode.isMax)
            {
                double value = -99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Max(value, minMax);
                    alpha = Math.Max(alpha, value);
                    if (alpha >= beta)
                    {
                        break;
                    }
                }
                return value;
            }
            else
            {
                double value = 99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Min(value, minMax);
                    beta = Math.Min(beta, value);
                    if (beta <= alpha)
                    {
                        break;
                    }
                }
                return value;
            }
        }
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
    public class MonteCarloTreeSearch : TreeAlgorithm
    {
        private Random rand;
        private bool printErrors;
        private SearchStrategy strategy;
        public enum SearchStrategy
        {
            Random = 0,
            Sequential = 1
        }
        public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random)
        {
            rand = new Random();
            printErrors = showErrors;
            strategy = searchStrategy;
        }
        public IGameState GetRootState()
        {
            return RootNode.state;
        }
        /// <summary>
        /// Get the next move
        /// </summary>
        /// <param name="watch">timer</param>
        /// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
        /// <param name="depth">How deep to run the simulations; does not impact how deep it goes in the game tree.</param>
        /// <param name="numRollouts">The number of roll outs to play per expansion</param>
        /// <returns></returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
        {
            if (exploration == null)
            {
                exploration = Math.Sqrt(2);
            }
            int count = 0;
            do
            {
                GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
                if (selectedNode == null)
                {
                    if (printErrors)
                        Console.Error.WriteLine("Found no more moves!");
                    break;
                }
                object move = SelectMove(selectedNode);
                GameTreeNode childNode = Expand(selectedNode, move);
                double? winner = childNode.GetWinner();
                if (winner.HasValue)
                {
                    BackPropagate(childNode, winner);
                }
                else
                {
                    for (int i = 0; i < numRollouts; i++)
                    {
                        var clonedState = childNode.state.Clone();
                        winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
                        if (!winner.HasValue)
                            break;//We simulated a game, but it didn't end so we are out of time...
                        BackPropagate(childNode, winner);
                        count++;
                    }
                }
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            if (printErrors)
                Console.Error.WriteLine($"Played {count} games!");
            GameTreeNode bestChild = null;
            double bestScore = double.MinValue;
            for (int i = 0; i < RootNode.children.Count; i++)
            {
                var child = RootNode.children[i];
                double score = child.GetScore(RootNode.isMax);
                if (bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                if (printErrors)
                    Console.Error.WriteLine($"w: {child.wins} l: {child.loses} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
            }
            if (printErrors)
                Console.Error.WriteLine($"Best: w: {bestChild.wins} l: {bestChild.loses} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
            return bestChild.state.GetMove(RootNode.isMax);
        }
        private void BackPropagate(GameTreeNode selectedNode, double? winner)
        {
            selectedNode.ApplyWinner(winner);
            GameTreeNode tempNode = selectedNode.parent;
            while (tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
        {
            double? winner;
            do
            {
                object move = SelectMoveAtRandom(state, isMax);
                state.ApplyMove(move, isMax);
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    return null;
                }
                depth--;
                isMax = !isMax;
                winner = state.GetWinner();
            }
            while (!winner.HasValue && depth != 0);
            if (winner.HasValue)
            {
                return winner;
            }
            if (depth == 0)
            {
                double eval = state.Evaluate(isMax);
                if (eval > 1)
                {
                    return 1;
                }
                else if (eval < -1)
                    return -1;
                else return eval;
            }
            throw new InvalidOperationException("Could not find a winner for simulation!");
        }
        private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
        {
            Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
            queue.Enqueue(node);
            GameTreeNode tempNode;
            GameTreeNode bestNode = null;
            double maxValue = -1;
            while (queue.Count > 0)
            {
                tempNode = queue.Dequeue();
                if (tempNode.moves.Count == 0)
                {
                    for (int i = 0; i < tempNode.children.Count; i++)
                    {
                        var child = tempNode.children[i];
                        queue.Enqueue(child);
                    }
                }
                else if (tempNode.parent != null)
                {
                    double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
                    double nodeTotal = tempNode.TotalPlays();
                    double parentTotal = tempNode.parent.TotalPlays();
                    double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
                    if (value > maxValue)
                    {
                        maxValue = value;
                        bestNode = tempNode;
                    }
                }
                else return tempNode;
            }
            return bestNode;
        }
        private object SelectMoveAtRandom(IGameState state, bool isMax)
        {
            IList moves = state.GetPossibleMoves(isMax);
            if (moves.Count == 0)
            {
                throw new Exception("No moves available!");
            }
            int index = rand.Next(0, moves.Count);
            return moves[index];
        }
        private object SelectMove(GameTreeNode node)
        {
            switch (strategy)
            {
                case SearchStrategy.Random:
                    return SelectMoveAtRandom(node);
                case SearchStrategy.Sequential:
                    return SelectMoveSequentially(node);
            }
            throw new InvalidOperationException("strategy not supported");
        }
        private object SelectMoveSequentially(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                move = node.moves[0];
                node.moves.RemoveAt(0);
            }
            return move;
        }
        private object SelectMoveAtRandom(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
    }
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms.Trees
{
    public class TreeAlgorithm
    {
        protected GameTreeNode RootNode;
        public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
        {
            if (RootNode != null && findState)
            {
                //if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
                //find the child that matches the new node
                bool isFound = false;
                //Expand any moves left in the root node (if any)
                for (int i = 0; i < RootNode.moves.Count; i++)
                {
                    var move = RootNode.moves[i];
                    Expand(RootNode, move);
                }
                //Begin scanning the children
                for (int i = 0; i < RootNode.children.Count; i++)
                {
                    var child = RootNode.children[i];
                    if (child.state.Equals(rootState))
                    {
                        RootNode = child;
                        isFound = true;
                        break;
                    }
                    for (int j = 0; j < child.moves.Count; j++)
                    {
                        var move = child.moves[j];
                        Expand(child, move);
                    }
                    for (int j = 0; j < child.children.Count; j++)
                    {
                        var descendent = child.children[j];
                        if (descendent.state.Equals(rootState))
                        {
                            RootNode = descendent;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    throw new Exception("Could not find the next state in tree!  Starting over...");
                    Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
                    RootNode = new GameTreeNode(rootState.Clone(), isMax);
                }
                else
                {
                    RootNode.parent = null;
                }
            }
            else
            {
                RootNode = new GameTreeNode(rootState.Clone(), isMax);
            }
        }
        /// <summary>
        /// Expands the given node by create a clone, applying the move and then adding it to the list of children.
        /// </summary>
        /// <param name="node">The node to expand</param>
        /// <param name="move">The move to play on the expanded node</param>
        /// <returns></returns>
        protected GameTreeNode Expand(GameTreeNode node, object move)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, node.isMax);
            GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
    }
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
    public static class BitFunctions
    {
        public static bool IsBitSet(long value, int location)
        {
            long mask = GetBitMask(location);
            return (value & mask) == mask;
        }
        public static long SetBit(long value, int location)
        {
            return value | (GetBitMask(location));
        }
        public static long ClearBit(long value, int location)
        {
            return value & (~(GetBitMask(location)));
        }
        public static long SetOrClearBit(long value, int location, bool isSet)
        {
            if (isSet)
                return SetBit(value, location);
            return ClearBit(value, location);
        }
        public static int NumberOfSetBits(long i)
        {
            i = i - ((i >> 1) & 0x5555555555555555);
            i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
            return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
        }
        public static long GetBitMask(int index)
        {
            return (long)1 << index;
        }
    }
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
    public enum LocationType
    {
        Empty = -2,
        Obstacle = -1,
    }
    public class Board
    {
        private LocationType[] Locations;
        private Int128 ObstacleBoard;
        private Int128 EmptyBoard;
        public static int MaxHeight = 7;
        public static int MaxWidth = 13;
        private int[][][] BresenhamDictionary;
        private static int[][] ManhattenDictionary = null;
        private int[][] NeighboringLocations = null; 
        public Board(string[] board)
        {
            ObstacleBoard = new Int128();
            EmptyBoard = new Int128();
            Locations = new LocationType[board.Length * board[0].Length];
            int locationIndex = 0;
            for(int r = 0; r <board.Length; r++)
            {
                for(int c = 0; c < board[r].Length; c++)
                {
                    var spot = board[r][c];
                    if(spot == '.')
                    {
                        EmptyBoard.SetBit(locationIndex);
                        Locations[locationIndex++] = LocationType.Empty;
                    }
                    else if(spot == 'x')
                    {
                        ObstacleBoard.SetBit(locationIndex);
                        Locations[locationIndex++] = LocationType.Obstacle;
                    }
                }
            }
            CreateManhattenDictionary();
            CreateBresenhamDictionary();
            CreateNeighboringLocations();
        }
        public static int ConvertPointToLocation(Point2d point)
        {
            return ConvertPointToLocation(point.x, point.y);
        }
        public static int ConvertPointToLocation(int x, int y)
        {
            return y * MaxWidth + x;
        }
        public static Point2d ConvertLocationToPoint(int location)
        {
            return new Point2d(location % MaxWidth, location / MaxWidth);
        }
        public static int GetManhattenDistance(int location, int targetLocation)
        {
            return ManhattenDictionary[location][targetLocation];
        }
        public int[] GetBresenhamPoints(int location, int targetLocation)
        {
            return BresenhamDictionary[location][targetLocation];
        }
        public int[] GetNeighboringLocations(int location)
        {
            return NeighboringLocations[location];
        }
        public LocationType GetLocation(int x, int y)
        {
            return Locations[y * MaxWidth + x]; 
        }
        public bool IsInBounds(int x, int y)
        {
            if (x < 0 || y < 0 || x >= MaxWidth || y >= MaxHeight)
                return false;
            return true;
        }
        private static void CreateManhattenDictionary()
        {
            ManhattenDictionary = new int[MaxWidth * MaxHeight][];
            for (int x = 0; x < MaxWidth; x++)
            {
                for (int y = 0; y < MaxHeight; y++)
                {
                    var point = new Point2d(x, y);
                    ManhattenDictionary[ConvertPointToLocation(x, y)] = new int[MaxWidth * MaxHeight];
                    for (int tx = 0; tx < MaxWidth; tx++)
                    {
                        for (int ty = 0; ty < MaxHeight; ty++)
                        {
                            var targetPoint = new Point2d(tx, ty);
                            ManhattenDictionary[ConvertPointToLocation(x, y)][ConvertPointToLocation(tx, ty)] = point.GetManhattenDistance(targetPoint);
                        }
                    }
                }
            }
        }
        private void CreateBresenhamDictionary()
        {
            BresenhamDictionary = new int[MaxWidth * MaxHeight][][];
            for (int x = 0; x < MaxWidth; x++)
            {
                for (int y = 0; y < MaxHeight; y++)
                {
                    var point = new Point2d(x, y);
                    BresenhamDictionary[ConvertPointToLocation(x, y)] = new int[MaxWidth * MaxHeight][];
                    for (int tx = 0; tx < MaxWidth; tx++)
                    {
                        for (int ty = 0; ty < MaxHeight; ty++)
                        {
                            var targetPoint = new Point2d(tx, ty);
                            if (point.Equals(targetPoint))
                                continue;
                            if (GetManhattenDistance(ConvertPointToLocation(point), ConvertPointToLocation(targetPoint)) > 6)
                                continue;
                            if (y < ty)
                                BresenhamDictionary[ConvertPointToLocation(x, y)][ConvertPointToLocation(tx, ty)] = bresenhamForward(point, targetPoint);
                            else
                                BresenhamDictionary[ConvertPointToLocation(x, y)][ConvertPointToLocation(tx, ty)] = bresenhamBackward(point, targetPoint);
                        }
                    }
                }
            }
        }
        private static int[] X_MODIFIER = new int[] { 0, 1, 0, -1 };
        private static int[] Y_MODIFIER = new int[] { -1, 0, 1, 0 };
        private void CreateNeighboringLocations()
        {
            NeighboringLocations = new int[MaxHeight * MaxWidth][];
            for (int x = 0; x < MaxWidth; x++)
            {
                for (int y = 0; y < MaxHeight; y++)
                {
                    int location = ConvertPointToLocation(x, y);
                    NeighboringLocations[location] = new int[4];
                    for (int i = 0; i < 4; i++)
                    {
                        int cx = x + X_MODIFIER[i];
                        int cy = y + Y_MODIFIER[i];
                        if (IsInBounds(cx, cy))
                        {
                            NeighboringLocations[location][i] = ConvertPointToLocation(cx, cy);
                        }
                        else
                        {
                            NeighboringLocations[location][i] = (int)LocationType.Obstacle;
                        }
                    }
                }
            }
        }
        private int[] bresenhamForward(Point2d startTile, Point2d targetTile)
        {
            List<int> bresenhamPoints = new List<int>();
            int x0, y0, x1, y1;
            x0 = startTile.x;
            y0 = startTile.y;
            x1 = targetTile.x;
            y1 = targetTile.y;
            int dx = Math.Abs(x1 - x0);
            int dy = Math.Abs(y1 - y0);
            int sx = x0 < x1 ? 1 : -1;
            int sy = y0 < y1 ? 1 : -1;
            int err = dx - dy;
            int e2;
            int currentX = x0;
            int currentY = y0;
            while (true)
            {
                e2 = 2 * err;
                if (e2 > -1 * dy)
                {
                    err -= dy;
                    currentX += sx;
                }
                if (e2 < dx)
                {
                    err += dx;
                    currentY += sy;
                }
                bresenhamPoints.Add(ConvertPointToLocation(currentX, currentY));
                if (currentX == x1 && currentY == y1) break;
                if (GetLocation(currentX, currentY) == LocationType.Obstacle)
                {
                    return bresenhamPoints.ToArray();
                }
            }
            return bresenhamPoints.ToArray();
        }
        private int[] bresenhamBackward(Point2d startTile, Point2d targetTile)
        {
            List<int> bresenhamPoints = new List<int>();
            int x0, y0, x1, y1;
            x0 = targetTile.x;
            y0 = targetTile.y;
            x1 = startTile.x;
            y1 = startTile.y;
            bresenhamPoints.Add(ConvertPointToLocation(targetTile));
            int dx = Math.Abs(x1 - x0);
            int dy = Math.Abs(y1 - y0);
            int sx = x0 < x1 ? 1 : -1;
            int sy = y0 < y1 ? 1 : -1;
            int err = dx - dy;
            int e2;
            int currentX = x0;
            int currentY = y0;
            while (true)
            {
                e2 = 2 * err;
                if (e2 > -1 * dy)
                {
                    err -= dy;
                    currentX += sx;
                }
                if (e2 < dx)
                {
                    err += dx;
                    currentY += sy;
                }
                if (currentX == x1 && currentY == y1) break;
                var location = GetLocation(currentX, currentY);
                if (location == LocationType.Obstacle)
                {
                    bresenhamPoints.Clear();
                }
                bresenhamPoints.Add(ConvertPointToLocation(currentX, currentY));
            }
            bresenhamPoints.Reverse();
            return bresenhamPoints.ToArray();
        }
    }
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
    public enum EntityType
    {
        Cultist = 0,
        CultLeader = 1
    };
    public enum OwnerType
    {
        Max = 1,
        Neutral = 0,
        Min = -1
    }
    public class Entity
    {
        public int Location;
        public int Id;
        public EntityType Type;
        public int Hp;
        public OwnerType Owner;
        public Entity(int id, int x, int y, int type, int hp, int isMine)
        {
            Id = id;
            Type = (EntityType)type;
            Hp = hp;
            Owner = (OwnerType)isMine;
            Location = Board.ConvertPointToLocation(x, y);
        }
        public Entity(Entity entity)
        {
            Id = entity.Id;
            Type = entity.Type;
            Hp = entity.Hp;
            Owner = entity.Owner;
            Location = entity.Location;
        }
        public void Move(int targetLocation)
        {
            var distance = Board.GetManhattenDistance(Location, targetLocation);
            if (distance != 1)
            {
                throw new Exception($"Point is not one space away it is: {distance}");
            }
            Location = targetLocation;
        }
        public void Shoot(Entity targetEntity)
        {
            if (Type != EntityType.Cultist)
                throw new Exception("Cult Leaders can't shoot!");
            var distance = Board.GetManhattenDistance(Location, targetEntity.Location);
            if (distance > 6)
                throw new Exception("Unit to far!");
            targetEntity.Damage(7 - distance);
        }
        public void Damage(int damage)
        {
            Hp = Math.Max(Hp - damage, 0);
        }
        public void Convert(Entity targetEntity)
        {
            if (Type != EntityType.CultLeader)
                throw new Exception("Cultists can't convert!");
            var distance = Board.GetManhattenDistance(Location, targetEntity.Location);
            if (distance != 1)
                throw new Exception("Unit is not one space away!");
            if (targetEntity.Type == EntityType.CultLeader)
                throw new Exception("Can't convert a cult leader!");
            targetEntity.Owner = Owner;
        }
        public Entity Clone()
        {
            return new Entity(this);
        }
        public bool Equals(Entity other)
        {
            return other != null && Id == other.Id && Hp == other.Hp && Type == other.Type && Owner == other.Owner && Location == other.Location;
        }
        public bool IsDead()
        {
            return Hp == 0;
        }
        public bool IsOwned(bool isMax)
        {
            if (isMax)
            {
                return Owner == OwnerType.Max;
            }
            else 
                return Owner == OwnerType.Min;
        }
        public override string ToString()
        {
            var point = Board.ConvertLocationToPoint(Location);
            return $"{Id}, {point.x}, {point.y}, {(int)Type}, {Hp}, {(int)Owner}";
            //return $"Id:{Id}, P:{Point}";
        }
    }
}
//*** SourceCombiner -> original file Int128.cs ***
namespace GameSolution.Entities
{
    public class Int128
    {
        private long _low;
        private long _high;
        public Int128()
        {
        }
        public void SetBit(int bitLocation)
        {
            if(bitLocation < 64)
            {
                _low = BitFunctions.SetBit(_low, bitLocation);
            }
            else
            {
                var highLocation = bitLocation - 64;
                _high = BitFunctions.SetBit(_high, highLocation);
            }
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
    public enum MoveType
    {
        Wait = 0,
        Move = 1,
        Shoot = 2,
        Convert = 3
    }
    public static class Move
    {
        public static long UnitIdMask = (long)Math.Pow(2, 4) - 1;
        public static long MoveTypeMask = (long)Math.Pow(2, 6) - 1 - UnitIdMask;
        public static long TargetUnitIdMask = (long)Math.Pow(2, 10) - 1 - MoveTypeMask;
        public static long LocationMask = (long)Math.Pow(2, 17) - 1 - TargetUnitIdMask;
        /*
        public int UnitId;//4 bits
        public MoveType Type;//2 bits
        public int TargetUnitId;//4 bits
        public int Location; //7 bits
        */
        public static int GetUnitId(long move)
        {
            return (int)(move & UnitIdMask);
        }
        public static MoveType GetMoveType(long move)
        {
            return (MoveType)((move & MoveTypeMask) >> 4);
        }
        public static int GetTargetUnitId(long move)
        {
            return (int)((move & TargetUnitIdMask) >> 6);
        }
        public static int GetLocation(long move)
        {
            return (int)((move & LocationMask) >> 10);
        }
        public static long CreateMove(int unitId, MoveType moveType, int targetUnitId, int location)
        {
            return unitId | (int)moveType << 4 | targetUnitId << 6 | location << 10;
        }
        public static long Wait()
        {
            return CreateMove(0, MoveType.Wait, 0, 0);
        }
        public static long MoveUnit(int unitId, int location)
        {
            return CreateMove(unitId, MoveType.Move, 0, location);
        }
        public static long Shoot(int unitId, int targetUnitId)
        {
            return CreateMove(unitId, MoveType.Shoot, targetUnitId, 0);
        }
        public static long Convert(int unitId, int targetUnitId)
        {
            return CreateMove(unitId, MoveType.Convert, targetUnitId, 0);
        }
        public static bool IsWait(long move)
        {
            return GetMoveType(move) == MoveType.Wait;
        }
        public static string ToString(long move)
        {
            switch(GetMoveType(move))
            {
                case MoveType.Move:
                    var point = Board.ConvertLocationToPoint(GetLocation(move));
                    return $"{GetUnitId(move)} MOVE {point.x} {point.y}";
                case MoveType.Wait:
                    return $"WAIT";
                case MoveType.Shoot:
                    return $"{GetUnitId(move)} SHOOT {GetTargetUnitId(move)}";
                case MoveType.Convert:
                    return $"{GetUnitId(move)} CONVERT {GetTargetUnitId(move)}";
            }
            return "";
        }
    }
}
//*** SourceCombiner -> original file CalculatedState.cs ***
namespace GameSolution.Game
{
    public class CalculatedState
    {
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution
{
    public class GameState : IGameState
    {
        public Board Board;
        public Entity?[] Entities;
        public int Turn = 0;
        public int Seed = 42;
        public long LastMove = 0;
        public long NeutralLastMove = 0;
        //Calculated Values
        double numberOfUnitsMine = 0, numberOfUnitsOpponent = 0, hpOfUnitsMine = 0, hpOfUnitsOpponent = 0;
        int[] boardMap = new int[Board.MaxHeight * Board.MaxWidth];
        List<Entity> myEntities;
        List<Entity> oppEntities;
        List<Entity> neutralEntities;
        List<Entity> deadNeutrals = new List<Entity>(12);
        //End Calculated Values
        public GameState(Board board)
        {
            Board = board;
        }
        public GameState(GameState state)
        {
            Board = state.Board;
            Entities = state.Entities.Select(e => e?.Clone()).ToArray();
            Turn = state.Turn;
            LastMove = state.LastMove;
            NeutralLastMove = state.NeutralLastMove;
            Seed = state.Seed;
            deadNeutrals = state.deadNeutrals.Select(e => e.Clone()).ToList();
            Reset();
        }
        public void Reset()
        {
            myEntities = new List<Entity>(14);
            oppEntities = new List<Entity>(14);
            neutralEntities = new List<Entity>(14);
            numberOfUnitsMine = numberOfUnitsOpponent = hpOfUnitsMine = hpOfUnitsOpponent = 0;
            boardMap = new int[Board.MaxHeight * Board.MaxWidth];
            for (int y = 0; y < Board.MaxHeight; y++)
            {
                for (int x = 0; x < Board.MaxWidth; x++)
                {
                    SetLocation(x, y, (int)Board.GetLocation(x, y));
                }
            }
            for(int i = 0; i<Entities.Length; i++)
            {
                var entity = Entities[i];
                if (entity == null)
                    continue;
                if (entity.IsOwned(true))
                {
                    myEntities.Add(entity);
                }
                else if(entity.IsOwned(false))
                {
                    oppEntities.Add(entity);
                }
                else neutralEntities.Add(entity);
                SetBoardMap(entity);
            }
        }
        public void SetState(Entity[] entities)
        {
            Entities = entities;
            Reset();
        }
        public void ApplyMove(object move, bool isMax)
        {
            long m = (long)move;
            switch (Move.GetMoveType(m))
            {
                case MoveType.Wait:
                    break;
                case MoveType.Move:
                    Entity moveEntity = Entities[Move.GetUnitId(m)];
                    ClearBoardMap(moveEntity);
                    moveEntity.Move(Move.GetLocation(m));
                    SetBoardMap(moveEntity);
                    break;
                case MoveType.Shoot:
                    Entity shootEntity = Entities[Move.GetUnitId(m)];
                    Entity shootEntityTarget = Entities[Move.GetTargetUnitId(m)];
                    bool isMine = shootEntityTarget.IsOwned(true);
                    bool isOpp = shootEntityTarget.IsOwned(false);
                    if (isMine)
                        hpOfUnitsMine -= shootEntityTarget.Hp;
                    else if(isOpp)
                        hpOfUnitsOpponent -= shootEntityTarget.Hp;
                    shootEntity.Shoot(shootEntityTarget);
                    if (shootEntityTarget.IsDead())
                    {
                        Entities[Move.GetTargetUnitId(m)] = null;
                        ClearBoardMap(shootEntityTarget);
                        if (isMine)
                            myEntities.Remove(shootEntityTarget);
                        else if(isOpp)
                            oppEntities.Remove(shootEntityTarget);
                        else
                        {
                            neutralEntities.Remove(shootEntityTarget);
                            deadNeutrals.Add(shootEntityTarget);
                        }
                    }
                    else 
                    {
                        if (isMine)
                            hpOfUnitsMine += shootEntityTarget.Hp;
                        else if(isOpp)
                            hpOfUnitsOpponent += shootEntityTarget.Hp;
                    }
                    break;
                case MoveType.Convert:
                    Entity convertEntity = Entities[Move.GetUnitId(m)];
                    Entity convertEntityTarget = Entities[Move.GetTargetUnitId(m)];
                    if(convertEntityTarget.Owner == OwnerType.Neutral)
                    {
                        neutralEntities.Remove(convertEntityTarget);
                        if (isMax)
                        {
                            numberOfUnitsMine++;
                            myEntities.Add(convertEntityTarget);
                        }
                        else
                        {
                            numberOfUnitsOpponent++;
                            oppEntities.Add(convertEntityTarget);
                        }
                    }
                    else
                    {
                        var modifier = isMax ? 1 : -1;
                        numberOfUnitsMine += modifier;
                        numberOfUnitsOpponent -= modifier;
                        if (isMax)
                        {
                            myEntities.Add(convertEntityTarget);
                            oppEntities.Remove(convertEntityTarget);
                        }
                        else
                        {
                            oppEntities.Add(convertEntityTarget);
                            myEntities.Remove(convertEntityTarget);
                        }
                    }
                    convertEntity.Convert(convertEntityTarget);
                    break;
            }
            /*
            for (int y = 0; y < Board.MaxHeight; y++)
            {
                for (int x = 0; x < Board.MaxWidth; x++)
                {
                    if (Board.GetLocation(x, y) == LocationType.Obstacle && GetLocation(x, y) >= 0)
                        throw new Exception("Discrepency in board map.");
                }
            }
            foreach (Entity? entity in Entities)
            {
                if (entity == null)
                    continue;
                if (!entity.IsDead())
                {
                    if (GetLocation(entity.Point.x, entity.Point.y) != entity.Id)
                        throw new Exception("Discrepency in board map.");
                }
            }
            */
            //Reset();
            MoveNeutralUnit();
            Turn++;
            LastMove = m;
        }
        public IGameState Clone()
        {
            return new GameState(this);
        }
        public bool Equals(IGameState state)
        {
            GameState game = (GameState)state;
            if(Turn != game.Turn)
                return false;
            /*
            if (Seed != game.Seed)
                return false;
            */
            //Assumes entities are always in same order...
            for(int i = 0; i<Entities.Length; i++)
            {
                if (Entities[i] == null && game.Entities[i] != null)
                    return false;
                if (!(Entities[i] == game.Entities[i] || Entities[i].Equals(game.Entities[i])))
                    return false;
            }
            return true;
        }
        public void CalculateUnits()
        {
            if (numberOfUnitsMine == 0 && numberOfUnitsOpponent == 0)
            {
                for(int i = 0; i<Entities.Length; i++)
                {
                    var entity = Entities[i];
                    if (entity == null)
                        continue;
                    if (entity.Owner == OwnerType.Max)
                    {
                        numberOfUnitsMine++;
                        hpOfUnitsMine += entity.Hp;
                    }
                    else if(entity.Owner == OwnerType.Min)
                    {
                        numberOfUnitsOpponent++;
                        hpOfUnitsOpponent += entity.Hp;
                    }
                }
            }
        }
        public double Evaluate(bool isMax)
        {
            CalculateUnits();
            double unitValue = (numberOfUnitsMine - numberOfUnitsOpponent) / Math.Max(numberOfUnitsMine, numberOfUnitsOpponent);
            double hpValue = (hpOfUnitsMine - hpOfUnitsOpponent) / Math.Max(hpOfUnitsMine, hpOfUnitsOpponent);
            double value = unitValue * 0.75 + hpValue * 0.25;
            return value;
        }
        public object GetMove(bool isMax)
        {
            return LastMove;
        }
        public int GetLocation(int location)
        {
            return boardMap[location];
        }
        public int GetLocation(int x, int y)
        {
            return boardMap[Board.ConvertPointToLocation(x, y)];
        }
        public void SetLocation(int location, int value)
        {
            boardMap[location] = value;
        }
        public void SetLocation(int x, int y, int value)
        {
            boardMap[Board.ConvertPointToLocation(x, y)] = value;
        }
        public void SetBoardMap(Entity entity)
        {
            SetLocation(entity.Location, entity.Id);
        }
        public void ClearBoardMap(Entity entity)
        {
            SetLocation(entity.Location, (int)LocationType.Empty);
        }
        public bool IsSpaceEmpty(int location)
        {
            return GetLocation(location) == (int)LocationType.Empty;
        }
        public bool IsSpaceEmpty(int x, int y)
        {
            return GetLocation(x, y) == (int)LocationType.Empty;
        }
        public bool IsUnit(int locationType)
        {
            return locationType >= 0;
        }
        public bool HasCultist(int location, bool isMax)
        {
            var spaceId = GetLocation(location);
            if (IsUnit(spaceId))
            {
                var entity = Entities[spaceId];
                if (entity == null)
                    return false;
                return entity.Type == EntityType.Cultist && !entity.IsOwned(isMax);
            }
            return false;
        }
        public bool HasCultist(int x, int y, bool isMax)
        {
            var location = GetLocation(x, y);
            if (IsUnit(location))
            {
                var entity = Entities[location];
                if (entity == null)
                    return false;
                return entity.Type == EntityType.Cultist && !entity.IsOwned(isMax);
            }
            return false;
        }
        public void GetMovesForEntity(ref IList possibleMoves, Entity entity)
        {
            int[] locations = Board.GetNeighboringLocations(entity.Location);
            for (int i = 0; i<4; i++)
            {
                int location = locations[i];                
                if (location != (int)LocationType.Obstacle && IsSpaceEmpty(location))
                {
                    possibleMoves.Add(Move.MoveUnit(entity.Id, location));
                }
            }
        }
        public void GetConvertsForEntity(ref IList possibleMoves, Entity entity, bool isMax)
        {
            int[] locations = Board.GetNeighboringLocations(entity.Location);
            for (int i = 0; i < 4; i++)
            {
                int location = locations[i];
                if (location != (int)LocationType.Obstacle && HasCultist(location, isMax))
                {
                    possibleMoves.Add(Move.Convert(entity.Id, GetLocation(location)));
                }
            }
        }
        public IList GetPossibleMoves(bool isMax)
        {
            var entitiesToCheck = isMax ? myEntities : oppEntities;
            var targetEntitiesToCheck = isMax ? oppEntities : myEntities;
            IList possibleMoves = new List<long>(20);
            if (Turn == 150)
                return possibleMoves;
            for(int i = 0; i< entitiesToCheck.Count; i++)
            {
                var entity = entitiesToCheck[i];
                GetMovesForEntity(ref possibleMoves, entity);
                if (entity.Type == EntityType.CultLeader)
                {
                    GetConvertsForEntity(ref possibleMoves, entity, isMax);
                }
                else
                {
                    for (int ti = 0; ti < targetEntitiesToCheck.Count; ti++)
                    {
                        var targetEntity = targetEntitiesToCheck[ti];
                        if (Board.GetManhattenDistance(entity.Location, targetEntity.Location) <= 6)
                        {
                            var endLocation = CheckBulletPath(entity.Location, targetEntity.Location);
                            if (endLocation == targetEntity.Location)
                            {
                                possibleMoves.Add(Move.Shoot(entity.Id, targetEntity.Id));
                            }
                        }
                    }
                    for (int ti = 0; ti < neutralEntities.Count; ti++)
                    {
                        var targetEntity = neutralEntities[ti];
                        if (Board.GetManhattenDistance(entity.Location, targetEntity.Location) <= 6)
                        {
                            var endLocation = CheckBulletPath(entity.Location, targetEntity.Location);
                            if (endLocation == targetEntity.Location)
                            {
                                possibleMoves.Add(Move.Shoot(entity.Id, targetEntity.Id));
                            }
                        }
                    }
                }
            }
            if (possibleMoves.Count == 0)
                possibleMoves.Add(Move.Wait());
            return possibleMoves;
        }
        public double? GetWinner()
        {
            CalculateUnits();
            if (Turn == 150)
            {
                var diff = numberOfUnitsMine - numberOfUnitsOpponent;
                return diff > 0 ? 1 : diff < 0 ? -1 : 0;
            }
            else
            {
                if (numberOfUnitsOpponent == 0)
                    return 1;
                else if (numberOfUnitsMine == 0)
                    return -1;
            }
            return null;
        }
        public int CheckBulletPath(int startTile, int targetTile)
        {
            var locations = Board.GetBresenhamPoints(startTile, targetTile);
            for (int i = 0; i < locations.Length; i++)
            {
                var location = locations[i];
                var spaceId = GetLocation(location);
                if (IsUnit(spaceId))
                {
                    return location;
                }
            }
            return locations[locations.Length - 1];
        }
        public void MoveNeutralUnit()
        {
            List<Entity> allNeutralEntities = neutralEntities;
            if(deadNeutrals.Count > 0)
            {
                allNeutralEntities = new List<Entity>(neutralEntities);
                allNeutralEntities.AddRange(deadNeutrals);
                allNeutralEntities.Sort((e1, e2) => e1.Id > e2.Id ? 1 : -1);
            }
            NeutralLastMove = -1;
            var neutralCount = allNeutralEntities.Count;
            if (neutralCount > 0)
            {
                int index = InternalRandom.rand(ref Seed, 12);
                if (index < neutralCount)
                {
                    Entity neutralUnit = allNeutralEntities[index];
                    if (neutralUnit.IsDead())
                        return;
                    IList moves = new List<long>();
                    GetMovesForEntity(ref moves, neutralUnit);
                    if (moves.Count > 0)
                    {
                        long action = (long)moves[InternalRandom.rand(ref Seed, moves.Count)];
                        NeutralLastMove = action;
                        ClearBoardMap(neutralUnit);
                        neutralUnit.Move(Move.GetLocation(action));
                        SetBoardMap(neutralUnit);
                    }
                    else
                    {
                        //Seed still moves even if there are no legal move actions; the unit still must 'wait'!
                        InternalRandom.rand(ref Seed, 1);
                    }
                }
            }
        }
    }
}
//*** SourceCombiner -> original file InternalRandom.cs ***
namespace GameSolution.Game
{
    public class InternalRandom
    {
        static int mask = 2_147_483_647;
        public static int rand(ref int seed, int bound)
        {
            seed = (seed * 1_103_515_245 + 12_345) & mask;
            return seed % bound;
        }
    }
}
