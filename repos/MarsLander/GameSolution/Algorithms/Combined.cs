/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 5/20/2022 6:19:03 PM
*/
using Algorithms.GameComponent;
using Algorithms.Genetic;
using Algorithms.Trees;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms.GameComponent
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        IList GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(object move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        object GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        double? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
        /// <summary>
        /// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
        /// </summary>
        /// <param name="isMax">true if it is max's turn else false</param>
        /// <returns>A number between [-1, 1]</returns>
        double Evaluate(bool isMax);
    }
}
//*** SourceCombiner -> original file GeneticAlgorithm.cs ***
namespace Algorithms.Genetic
{
    public class GeneticAlgorithm
    {
        /**The population for the genetic algorithm to choose from*/
        public Population Population;
        private Population HiddenPopulation;
        /**The rate at which mutations occur*/
        private double MutationRate;
        /**The percent of the original population that will be in the new population*/
        private double ElitePercent;
        /**The percent of the chromosome to use from the first parent*/
        private double CrossOver;
        /// <summary>
        /// The number of generations that have been created
        /// </summary>
        public int GenerationCounter;
        /**Sets the initial population and the mutation rate*/
        public GeneticAlgorithm(Population initialPopulation, double mRate, double eP, double cO)
        {
            Population = initialPopulation;
            HiddenPopulation = initialPopulation.Clone();
            MutationRate = mRate;
            ElitePercent = eP;
            CrossOver = cO;
            GenerationCounter = 0;
        }
        /// <summary>
        /// Retrieves the next best move
        /// </summary>
        /// <param name="watch">Timer that is counting the time limit</param>
        /// <param name="timeLimit">How long to run the algorithm for</param>
        /// <param name="maxGeneration">The highest generation to reach</param>
        /// <returns>The best move</returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int maxGeneration = -1)
        {
            do
            {
                var counter = 0;
                foreach(Individual i in Population)
                {
                    if (watch.ElapsedMilliseconds >= timeLimit && counter > 1)
                    {
                        break;
                    }
                    if(i.Fitness == double.MinValue)
                        i.CalculateFitness();
                    counter++;
                }
                GenerateNextGeneration();
            }
            while (watch.ElapsedMilliseconds < timeLimit && GenerationCounter != maxGeneration);
            var bestIndividual = Population.GetBestIndividual();
            return bestIndividual.GetNextMove();
        }
        /// <summary>
        /// Method to run the genetic algorithm once so that it does the following:
        /// 1) Sorts the population based on the fitness of each individual 
        /// 2) Kills off all of the population except for those that were in the top ElitePercent
        /// 3) Select two parents from the population
        /// 4) Create a baby and add him to the new population
        /// 5) Set the old population to the new one
        /// </summary>
        /// <returns>the new population</returns>
        public Population GenerateNextGeneration()
        {
            GenerationCounter++;
            Individual individual1;
            Individual individual2;
            Individual child;
            //1) Sorts the population based on the fitness of each individual
            Population.SortPopulationByFitness();
            //2) keep the top elite percent that are performing well
            for (int x = 0; x < (int)(Population.Count * ElitePercent); x++)
            {
                HiddenPopulation[x] = Population[x];
            }
            double totalFit = Population.GetTotalFitness();
            for (int x = (int)(Population.Count * ElitePercent); x < Population.Count; x++)
            {
                //3) Select two parents from the population
                individual1 = Population.SelectRandomFromPopulation(totalFit);
                individual2 = Population.SelectRandomFromPopulation(totalFit, individual1);
                //4)Create a baby and add him to the new population
                child = HiddenPopulation[x].CreateBaby(individual1, individual2, CrossOver);
                child.Mutate(MutationRate);
                child.Fitness = double.MinValue;
                x++;
                if (x < Population.Count)
                {
                    child = HiddenPopulation[x].CreateBaby(individual2, individual1, CrossOver);
                    child.Mutate(MutationRate);
                    child.Fitness = double.MinValue;
                }
            }
            //5) Set the old population to the new one
            var swap = Population;
            Population = HiddenPopulation;
            HiddenPopulation = swap;
            return Population;
        }
    }
}
//*** SourceCombiner -> original file Individual.cs ***
namespace Algorithms.Genetic
{
    /* Interface for the individuals within the population for a genetic algorithm */
    public interface Individual
    {
        /// <summary>
        /// Fitness should be a postive value (> 0)
        /// </summary>
        public double Fitness { get; set; }
        /** Creates an individual from two parents*/
        Individual CreateBaby(Individual parent1, Individual parent2, double crossOver);
        /** Mutates the individual */
        void Mutate(double mutationRate);
        double CalculateFitness();
        object GetNextMove();
        Individual Clone();
    }
}
//*** SourceCombiner -> original file Population.cs ***
namespace Algorithms.Genetic
{
    public class Population : IEnumerable<Individual>, IList<Individual>
    {
        private List<Individual> Individuals;
        private Random Rand;
        public int Count => Individuals.Count;
        public bool IsReadOnly => throw new NotImplementedException();
        public Individual this[int index] { get { return Individuals[index]; }  set { Individuals[index] = value; } }
        /**
         * Creates an empty population
          * */
        public Population()
        {
            Individuals = new List<Individual>();
            Rand = new Random();
        }
        public Population(Population population)
        {
            Individuals = population.Individuals.Select(i => i.Clone()).ToList();
            Rand = new Random();
        }
        /// <summary>
        /// Sort the population based on fitness
        /// </summary>
        public void SortPopulationByFitness()
        {
            Individuals.Sort(delegate (Individual i1, Individual i2)
            {
                if (i1 == null && i2 == null) return 0;
                else if (i1 == null) return 1;
                else if (i2 == null) return -1;
                else if (i2.Fitness == i1.Fitness) return 0;
                else return i1.Fitness > i2.Fitness ? -1 : 1;
            });
        }
        public double GetTotalFitness()
        {
            return Individuals.Sum(i => i.Fitness);
        }
        /// <summary>
        /// Selects a random Individual from the population in a roulette wheel fashion with individuals who have a higher fitness having a higher chance of being selected.
        /// </summary>
        /// <param name="totalFit">The total fitness of the population</param>
        /// <returns>The selected Individual</returns>
        public Individual SelectRandomFromPopulation(double totalFit, Individual i = null)
        {
            double randNum = Rand.NextDouble() * totalFit;
            int y = 0;
            double totalFitSoFar = Individuals[y].Fitness;
            while (totalFitSoFar < randNum)
            {
                y++;
                totalFitSoFar += Individuals[y].Fitness;
            }
            if(i != null && i == Individuals[y])
            {
                if (y == Individuals.Count - 1)
                {
                    y--;
                }
                else y++;
            }
            return Individuals[y];
        }
        public Individual GetBestIndividual()
        {
            SortPopulationByFitness();
            return Individuals.First();
        }
        public double MaximumFitness()
        {
            SortPopulationByFitness();
            return Individuals[0].Fitness;
        }
        public double MinimumFitness()
        {
            SortPopulationByFitness();
            return Individuals.Last().Fitness;
        }
        public double AverageFitness()
        {
            return Individuals.Average(i => i.Fitness);
        }
        public IEnumerator<Individual> GetEnumerator()
        {
            return Individuals.GetEnumerator();
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return Individuals.GetEnumerator();
        }
        public int IndexOf(Individual item)
        {
            return Individuals.IndexOf(item);
        }
        public void Insert(int index, Individual item)
        {
            Individuals.Insert(index, item);
        }
        public void RemoveAt(int index)
        {
            Individuals.RemoveAt(index);
        }
        public void Add(Individual item)
        {
            Individuals.Add(item);
        }
        public void Clear()
        {
            Individuals.Clear();
        }
        public bool Contains(Individual item)
        {
            return Individuals.Contains(item);
        }
        public void CopyTo(Individual[] array, int arrayIndex)
        {
            Individuals.CopyTo(array, arrayIndex);
        }
        public bool Remove(Individual item)
        {
            return Individuals.Remove(item);
        }
        public Population Clone()
        {
            return new Population(this);
        }
    }
}
//*** SourceCombiner -> original file NeuralNetwork.cs ***
namespace Algorithms.NeuralNetwork
{
    /**The NeuralNetwork Class is used as the 'brain'*/
    public class NeuralNetwork : Individual
    {
        //The array of NeuronLayers keeps track of the neurons within the network
        private NeuronLayer[] neuronLayers;
        //The number of layers of neurons in the network
        private int numLayers;
        //The number of neurons within each layer of the network
        private int[] numNeurons;
        //The number of inputs that go into the first layer of the network
        private int[] numInputs;
        private int nFirstInputs;
        //The total number of weights within the network
        private int totalNumWeightsInNetwork;
        //The fitness of the neural network
        public double Fitness { get; set; }
        Random rand;
        /**Generates all of the layers of the network 
          * @param nLayers- The number of layers of neurons within the network
          * @param nNeurons- The number of neurons within each layer of the network
          * @param nInputs- The number of inputs going into the first layer of the network
          * */
        public NeuralNetwork(int nLayers, int[] nNeurons, int nInputs)
        {
            rand = new Random();
            numLayers = nLayers;
            numNeurons = nNeurons;
            nFirstInputs = nInputs;
            numInputs = new int[nLayers];
            numInputs[0] = nInputs;
            for (int x = 1; x < nLayers; x++)
            {
                numInputs[x] = numNeurons[x - 1];
            }
            neuronLayers = new NeuronLayer[nLayers];
            for (int x = 0; x < nLayers; x++)
            {
                neuronLayers[x] = new NeuronLayer(numNeurons[x], numInputs[x]);
                totalNumWeightsInNetwork += numNeurons[x] * numInputs[x];
            }
            Fitness = 0;
        }
        public NeuralNetwork(NeuralNetwork net)
        {
            rand = new Random();
            numLayers = net.numLayers;
            numNeurons = (int[])net.numNeurons.Clone();
            nFirstInputs = net.nFirstInputs;
            numInputs = (int[])net.numInputs.Clone();
            neuronLayers = new NeuronLayer[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                neuronLayers[x] = new NeuronLayer(numNeurons[x], numInputs[x]);
                totalNumWeightsInNetwork += numNeurons[x] * numInputs[x];
            }
            setWeights(net.getWeights());
            Fitness = 0;
        }
        public NeuralNetwork(BinaryReader reader)
        {
            numLayers = reader.ReadInt32();
            numNeurons = new int[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                numNeurons[x] = reader.ReadInt32();
            }
            numInputs = new int[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                numInputs[x] = reader.ReadInt32();
            }
            nFirstInputs = numInputs[0];
            neuronLayers=new NeuronLayer[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                neuronLayers[x]=new NeuronLayer(numNeurons[x], numInputs[x]);
                totalNumWeightsInNetwork += numNeurons[x] * numInputs[x];
            }
            double[] weights = new double[getNumWeights()];
            for(int i = 0; i<weights.Length; i++)
            {
                weights[i] = reader.ReadDouble();
            }
            setWeights(weights);
            Fitness = reader.ReadDouble();
        }
        public void Save(BinaryWriter writer)
        {
            writer.Write(numLayers);
            for (int x = 0; x < numNeurons.Count(); x++)
            {
                writer.Write(numNeurons[x]);
            }
            for (int x = 0; x < numInputs.Count(); x++)
            {
                writer.Write(numInputs[x]);
            }
            double[] weights = getWeights();
            foreach(double weight in weights)
            {
                writer.Write(weight);
            }
            writer.Write(Fitness);
        }
        /**Gets the NeuronLayer at a specified location
          * @param location- The specified layer that is to be retrieved
          * @return The NeuronLayer at location
          * */
        public NeuronLayer getNeuronLayer(int location)
        {
            return neuronLayers[location];
        }
        /**Gets the number of layers within the network
          * @return The number of layers
          * */
        public int getNumLayers()
        {
            return numLayers;
        }
        /**Gets the number of neurons within the network
          * @return an array that describes how many neurons there are in each layer
          * */
        public int[] getNumNeurons()
        {
            return numNeurons;
        }
        /**Gets the number of inputs going into each layer within the network
          * @return an array that describes the number of inputs going into each layer
          * */
        public int[] getNumInputs()
        {
            return numInputs;
        }
        /**Gets the total number of weights within the network
          * @return the total number of weights
          * */
        public int getNumWeights()
        {
            return totalNumWeightsInNetwork;
        }
        /**Gets all of the current weights being used within the network.  This function goes layer by layer
          * to pull out all of the weights and puts them into a single array.
          * @return an array that contains the value of all of the weights
          * */
        public double[] getWeights()
        {
            double[] weights = new double[totalNumWeightsInNetwork];
            double[] layerWeights;
            int count = 0;
            for (int x = 0; x < getNumLayers(); x++)
            {
                layerWeights = getNeuronLayer(x).getWeights();
                for (int y = 0; y < layerWeights.Count(); y++)
                {
                    weights[count] = layerWeights[y];
                    count++;
                }
            }
            return weights;
        }
        /**Displays all of the current weights in the network
          * */
        public void displayWeights()
        {
            double[] weights = getWeights();
            for (int x = 0; x < weights.Count(); x++)
            {
                Console.Error.Write(weights[x] + ", ");
            }
            Console.Error.WriteLine();
        }
        /**Sets all of the weights within the network going layer by layer
          * @param weights- The weights to be used for the neural network
          * */
        public void setWeights(double[] weights)
        {
            int count = 0;
            for (int x = 0; x < getNumLayers(); x++)
            {
                for (int y = 0; y < neuronLayers[x].getNumNeurons(); y++)
                {
                    for (int z = 0; z < neuronLayers[x].getNeuron(y).getNumWeights(); z++)
                    {
                        neuronLayers[x].getNeuron(y).setWeight(z, weights[count]);
                        count++;
                    }
                }
            }
        }
        /**Determines the output of the network given all of the inputs
          * @param inputs- The inputs to the neural network
          * @return The output of the neural network
          * */
        public double[] output(double[] inputs)
        {
            double[] output = inputs;
            //lets each layer handle its own output and the output of the 
            //previous becomes the input of the next layer
            for (int x = 0; x < getNumLayers(); x++)
            {
                output = getNeuronLayer(x).output(output);
            }
            return output;
        }
        //Individual Methods for the genetic algorithm
        //creates an individual from two parents 
        public Individual CreateBaby(Individual parent1, Individual parent2, double crossOver)
        {
            var p1 = (NeuralNetwork)parent1;
            var p2 = (NeuralNetwork)parent2;
            double[] weights = new double[p1.getNumWeights()];
            double[] p1weights = p1.getWeights();
            double[] p2weights = p2.getWeights();
            for (int x = 0; x < p1.getNumWeights(); x++)
            {
                if (p1.getNumWeights() * crossOver < x)
                    weights[x] = p1weights[x];
                else weights[x] = p2weights[x];
            }
            setWeights(weights);
            return this;
        }
        //mutates the individual 
        public void Mutate(double mutationRate)
        {
            double[] weights = getWeights();
            for(int i = 0; i < weights.Length; i++)
            {
                if(rand.NextDouble() < mutationRate)
                {
                    weights[i] = (rand.NextDouble() * 2 - 1);
                }
            }
            setWeights(weights);
        }
        //checks if two individuals are equal
        public bool Equals(Individual i)
        {
            double[] weights1 = getWeights();
            double[] weights2 = ((NeuralNetwork)i).getWeights();
            for (int x = 0; x < weights1.Count(); x++)
            {
                if (weights1[x] != weights2[x])
                    return false;
            }
            return true;
        }
        public double CalculateFitness()
        {
            throw new NotImplementedException();
        }
        public object GetNextMove()
        {
            throw new NotImplementedException();
        }
        public Individual Clone()
        {
            return new NeuralNetwork(this);
        }
    }
}
//*** SourceCombiner -> original file Neuron.cs ***
namespace Algorithms.NeuralNetwork
{
    public class Neuron
    {
        //The weights for this neuron
        private double[] weights;
        //The number of weights 
        private int numWeights;
        Random rand;
        /**Creates a neuron with starting weights between -1 and 1
          * @param numInputs- The number of weights needed and the number of inputs
          * */
        public Neuron(int numInputs)
        {
            rand = new Random();
            numWeights = numInputs;
            weights = new double[numInputs];
            for (int x = 0; x < numInputs; x++)
            {
                weights[x] = rand.NextDouble() * 2 - 1;
            }
        }
        /**Gets a weight at a particular location
          * @param location- The location of the weight within the array
          * @return the value of the weight at index location
          */
        public double getWeight(int location)
        {
            return weights[location];
        }
        /**Gets the number of weights
          * @return the number of weights
          * */
        public int getNumWeights()
        {
            return numWeights;
        }
        /**Sets the weight at a particular location to the value in weight
          * @param location- The location to put the weight
          * @param weight- The value to put at index location
          * */
        public void setWeight(int location, double weight)
        {
            weights[location] = weight;
        }
    }
}
//*** SourceCombiner -> original file NeuronLayer.cs ***
namespace Algorithms.NeuralNetwork
{
    public class NeuronLayer
    {
        //The neurons within this layer
        private Neuron[] neurons;
        //The number of neurons
        private int numNeurons;
        /**Generates a NeuronLayer from the number of neurons and number of inputs
          * @param nNeurons- The number of neurons in this layer
          * @param numInputs- The number of inputs going into this layer
          * */
        public NeuronLayer(int nNeurons, int numInputs)
        {
            numNeurons = nNeurons;
            neurons = new Neuron[numNeurons];
            for (int x = 0; x < numNeurons; x++)
            {
                neurons[x] = new Neuron(numInputs);
            }
        }
        /**Gets a neuron at index location
          * @param location- The location of the neuron
          * @return the neuron at index location
          * */
        public Neuron getNeuron(int location)
        {
            return neurons[location];
        }
        /**Gets the number of neurons
          * @return the number of neurons
          * */
        public int getNumNeurons()
        {
            return numNeurons;
        }
        /**Gets all of the weights for this layer
          * @return the values of the weights in this layer
          * */
        public double[] getWeights()
        {
            double[] weights = new double[neurons[0].getNumWeights() * numNeurons];
            int count = 0;
            for (int x = 0; x < getNumNeurons(); x++)
            {
                for (int y = 0; y < neurons[x].getNumWeights(); y++)
                {
                    weights[count] = neurons[x].getWeight(y);
                    count++;
                }
            }
            return weights;
        }
        /**Gets the number of weights; calculated by the Number of Neurons times the Number of Inputs going into
          * this layer.
          * @returns The number of weights
          * */
        public int getNumWeights()
        {
            return getNumNeurons() * getNeuron(0).getNumWeights();
        }
        /**Calculates the output of this layer based on the given inputs
          * @param inputs- The values of the inputs
          * @return The responses of each neuron within this layer
          * */
        public double[] output(double[] inputs)
        {
            double[] output = new double[getNumNeurons()];
            double sum = 0;
            int temp = 0;
            for (int x = 0; x < getNumNeurons(); x++)
            {
                for (int y = 0; y < getNeuron(x).getNumWeights() - temp; y++)
                {
                    sum = sum + inputs[y] * getNeuron(x).getWeight(y);
                }
                //System.out.println(sum);
                output[x] = sigmoid(sum);
                sum = 0;
            }
            return output;
        }
        /**Calculates the value of the sigmoid function for a particular x value.  The sigmoid function
          * is an S-shaped graph with f(x)=1/(1+e^(-x)).
          * value- The x value used to calculate the y value
          * */
        public double sigmoid(double value)
        {
            return (1.0 / (1.0 + Math.Exp(-value)));
        }
    }
}
//*** SourceCombiner -> original file Circle2d.cs ***
namespace Algorithms.Space
{
    public class Circle2d : Point2d
    {
        public double radius;
        public Circle2d(double x, double y, double radius) : base(x, y)
        {
            this.radius = radius;
        }
    }
}
//*** SourceCombiner -> original file Point2d.cs ***
namespace Algorithms.Space
{
    public class Point2d
    {
        public double x;
        public double y;
        public Point2d(double x, double y)
        {
            this.x = x; 
            this.y = y;
        }
        public Point2d(Point2d point)
        {
            x = point.x;
            y = point.y;
        }
        public override string ToString()
        {
            return $"({x},{y})";
        }
        public bool Equals(Point2d point)
        {
            return point.x == this.x && point.y == this.y;
        }
        public Point2d GetTruncatedPoint()
        {
            return new Point2d(Math.Truncate(this.x), Math.Truncate(this.y));
        }
        public Point2d GetRoundedPoint()
        {
            return new Point2d(Math.Round(this.x), Math.Round(this.y));
        }
        public Point2d GetCeilingPoint()
        {
            return new Point2d(Math.Ceiling(x), Math.Ceiling(y));
        }
        public int GetTruncatedX()
        {
            return (int)x;
        }
        public int GetTruncatedY()
        {
            return (int)y;
        }
        public double GetAngle(Point2d point)
        {
            return Math.Atan2(point.y - y, point.x - x);
        }
        public double GetDistance(Point2d point)
        {
            return GetDistance(point.x, point.y, x, y);
        }
        public Point2d GetMidPoint(Point2d point)
        {
            return GetMidPoint(point.x, point.y, x, y);
        }
        public double LengthSquared()
        {
            return x * x + y * y;
        }
        public double Length()
        {
            return Math.Sqrt(LengthSquared());
        }
        public Point2d Normalize()
        {
            var length = Length();
            if (length == 0)
            {
                x = 0;
                y = 0;
            }
            else
            {
                x /= length;
                y /= length;
            }
            return this;
        }
        public Point2d Multiply(double scalar)
        {
            x *= scalar;
            y *= scalar;
            return this;
        }
        public Point2d Add(Point2d vector)
        {
            x += vector.x;
            y += vector.y;
            return this;
        }
        public Point2d Subtract(Point2d vector)
        {
            x -= vector.x;
            y -= vector.y;
            return this;
        }
        public Point2d Truncate()
        {
            x = GetTruncatedX();
            y = GetTruncatedY();
            return this;
        }
        public Point2d SymmetricTruncate(Point2d origin)
        {
            Subtract(origin).Truncate().Add(origin);
            return this;
        }
        public Point2d GetRoundedAwayFromZeroPoint()
        {
            return new Point2d(Math.Round(x, MidpointRounding.AwayFromZero), Math.Round(y, MidpointRounding.AwayFromZero));
        }
        public Point2d Clone()
        {
            return new Point2d(x, y);
        }
        public void Fill(Point2d point)
        {
            x = point.x;
            y = point.y;
        }
        public static double GetDistance(double x1, double y1, double x2, double y2)
        {
            return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));
        }
        public static Point2d GetMidPoint(double x1, double y1, double x2, double y2)
        {
            return new Point2d((x1 + x2)/2, (y1+y2)/2);
        }
    }
}
//*** SourceCombiner -> original file Space2d.cs ***
namespace Algorithms.Space
{
    public class Space2d
    {
        /// <summary>
        /// Given a list of points and a circle radius, find the circle location that covers the maximum number of points
        /// </summary>
        /// <param name="points">The list of points to consider</param>
        /// <param name="radius">The radius of the circle</param>
        /// <returns>The number of points covered by the circle that is centered at the point.</returns>
        public static Tuple<int, Point2d> FindCircleWithMaximumPoints(Point2d[] points, double radius)
        {
            Tuple<int, Point2d> maxPoint = null;
            if (points == null)
                return null;
            if (radius <= 0)
                return null;
            var numberOfPoints = points.Count();
            double[,] distance = new double[numberOfPoints, numberOfPoints];
            for (int i = 0; i < numberOfPoints - 1; i++)
            {
                for (int j = i + 1; j < numberOfPoints; j++)
                {
                    distance[i, j] = distance[j, i] = points[i].GetDistance(points[j]);
                }
            }
            for (int i = 0; i < numberOfPoints; i++)
            {
                var currentAnswer = GetPointsInside(distance, points, i, radius, numberOfPoints);
                var nextPoint = new Tuple<int, Point2d>(currentAnswer.Item1, new Point2d(points[i].x + (radius * Math.Round(Math.Cos(currentAnswer.Item2), 15)), points[i].y + (radius * Math.Round(Math.Sin(currentAnswer.Item2), 15))));
                if (maxPoint == null || currentAnswer.Item1 > maxPoint.Item1 || (currentAnswer.Item1 == maxPoint.Item1 && IsInteger(nextPoint.Item2.x) && IsInteger(nextPoint.Item2.y)))
                {
                    maxPoint = nextPoint;
                }
            }
            return maxPoint;
        }
        /// <summary>
        /// Given a list of points and a circle radius, find the circle location that covers the maximum number of points, at point i.
        /// </summary>
        /// <param name="points">The list of points to consider</param>
        /// <param name="radius">The radius of the circle</param>
        /// <param name="i">The index of the point to use for the sweeping circle</param>
        /// <returns>The number of points covered by the circle that is centered at the point.</returns>
        public static Tuple<int, Point2d> FindCircleWithMaximumPoints(Point2d[] points, double radius, int i)
        {
            Tuple<int, Point2d> maxPoint = null;
            if (points == null)
                return null;
            if (radius <= 0)
                return null;
            var numberOfPoints = points.Count();
            double[,] distance = new double[numberOfPoints, numberOfPoints];
            for (int j = 0; j < numberOfPoints; j++)
            {
                distance[i, j] = distance[j, i] = points[i].GetDistance(points[j]);
            }
            var currentAnswer = GetPointsInside(distance, points, i, radius, numberOfPoints);
            maxPoint = new Tuple<int, Point2d>(currentAnswer.Item1, new Point2d(points[i].x + (radius * Math.Round(Math.Cos(currentAnswer.Item2), 15)), points[i].y + (radius * Math.Round(Math.Sin(currentAnswer.Item2), 15))));
            return maxPoint;
        }
        public static double CalculateAreaOfCircle(double radius)
        {
            return Math.PI * Math.Pow(radius, 2);
        }
        public static double CalculateOverlappingArea(Circle2d circle, Circle2d circle2)
        {
            var d = circle.GetDistance(circle2);
            if (d < circle.radius + circle2.radius)
            {
                var a = circle.radius * circle.radius;
                var b = circle2.radius * circle2.radius;
                var x = (a - b + d * d) / (2 * d);
                var z = x * x;
                var y = Math.Sqrt(a - z);
                if (d <= Math.Abs(circle2.radius - circle.radius))
                {
                    return Math.PI * Math.Min(a, b);
                }
                return a * Math.Asin(y / circle.radius) + b * Math.Asin(y / circle2.radius) - y * (x + Math.Sqrt(z + b - a));
            }
            return 0;
        }
        /// <summary>
        /// Moves the point towards the targetPoint with maximum distance
        /// </summary>
        /// <param name="startPoint">Start point</param>
        /// <param name="targetPoint">Target point</param>
        /// <param name="maximumDistance">Maximum distance to translate</param>
        /// <returns>The translated point in direction of target point with maximum distance</returns>
        public static Point2d TranslatePoint(Point2d startPoint, Point2d targetPoint, double maximumDistance)
        {
            var vector = CreateVector(startPoint, targetPoint);
            if (vector.LengthSquared() <= (maximumDistance * maximumDistance))
                return targetPoint;
            else
            {
                vector.Normalize();
                vector.Multiply(maximumDistance);
                return new Point2d(startPoint.x + vector.x, startPoint.y + vector.y);
            }
            /*
            if (point.GetDistance(targetPoint) <= maximumDistance)
                return targetPoint;
            else
            {
                var angle = point.GetAngle(targetPoint);
                var vx = Math.Cos(angle) * maximumDistance;
                var vy = Math.Sin(angle) * maximumDistance;
                return new Point2d(point.x + vx, point.y + vy);
            }
            */
        }
        public static Point2d CreateVector(Point2d startPoint, Point2d targetPoint)
        {
            var x = targetPoint.x - startPoint.x;
            var y = targetPoint.y - startPoint.y;
            return new Point2d(x, y);
        }
        private static bool IsInteger(double d)
        {
            return Math.Abs(d % 1) <= (Double.Epsilon * 100);
        }
        private static Tuple<int, double> GetPointsInside(double[,] distance, Point2d[] points, int i, double radius, int numberOfPoints)
        {
            List<Tuple<double, bool>> angles = new List<Tuple<double, bool>>();
            for (int j = 0; j < numberOfPoints; j++)
            {
                if (i != j && distance[i, j] <= 2 * radius)
                {
                    double B = Math.Acos(distance[i, j] / (2 * radius));
                    Complex c1 = new Complex(points[j].x - points[i].x, points[j].y - points[i].y);
                    double A = c1.Phase;
                    double alpha = A - B;
                    double beta = A + B;
                    angles.Add(new Tuple<double, bool>(alpha, true));
                    angles.Add(new Tuple<double, bool>(beta, false));
                }
            }
            angles = angles.OrderBy(angle => angle.Item1).ToList();
            int count = 1, res = 1;
            double maxAngle = 0;
            foreach (var angle in angles)
            {
                if (angle.Item2)
                    count++;
                else
                    count--;
                if (count > res)
                {
                    res = count;
                    maxAngle = angle.Item1;
                }
            }
            return new Tuple<int, double>(res, maxAngle);
        }
    }
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
    public class GameTreeNode
    {
        public IGameState state;
        public IList moves;
        public List<GameTreeNode> children;
        public double wins = 0;
        public double loses = 0;
        public int totalPlays = 0;
        public GameTreeNode parent;
        public bool isMax;
        public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
        {
            this.state = state;
            moves = new List<object>();
            foreach(object obj in state.GetPossibleMoves(isMax))
            {
                moves.Add(obj);
            }
            children = new List<GameTreeNode>();
            this.parent = parent;
            this.isMax = isMax;
        }
        public double GetScore(bool isMax)
        {
            double totalPlays = TotalPlays();
            if (totalPlays == 0)
                return 0;
            if (isMax)
            {
                return (wins - loses) / totalPlays;
            }
            else
            {
                return (loses - wins) / totalPlays;
            }
        }
        public int TotalPlays()
        {
            return totalPlays;
        }
        public double? GetWinner()
        {
            return state.GetWinner();
        }
        public void ApplyWinner(double? winner)
        {
            if (winner.HasValue)
            {
                if(winner > 0)
                {
                    wins += winner.Value;
                }
                else if(winner < 0)
                {
                    loses += Math.Abs(winner.Value);
                }
                totalPlays++;
            }
        }
        public double Evaluate()
        {
            return state.Evaluate(isMax);
        }
    }
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms.Trees
{
    public class Minimax : TreeAlgorithm
    {
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
        {
            double val = 99999999;
            val *= RootNode.isMax ? -1 : 1;
            object bestMove = null;
            foreach (object move in RootNode.moves)
            {
                GameTreeNode child = Expand(RootNode, move);
                double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
                if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
                {
                    bestMove = move;
                    val = currentVal;
                }
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    break;
                }
            }
            return bestMove;
        }
        public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
        {
            if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
            {
                double eval = currentNode.Evaluate();
                return eval;
            }
            double? winner = currentNode.GetWinner();
            if (winner.HasValue)
            {
                return winner.Value;
            }
            if (currentNode.isMax)
            {
                double value = -99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Max(value, minMax);
                    alpha = Math.Max(alpha, value);
                    if (alpha >= beta)
                    {
                        break;
                    }
                }
                return value;
            }
            else
            {
                double value = 99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Min(value, minMax);
                    beta = Math.Min(beta, value);
                    if (beta <= alpha)
                    {
                        break;
                    }
                }
                return value;
            }
        }
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
    public class MonteCarloTreeSearch : TreeAlgorithm
    {
        private Random rand;
        private bool printErrors;
        private SearchStrategy strategy;
        public enum SearchStrategy
        {
            Random = 0,
            Sequential = 1
        }
        public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random) 
        {
            rand = new Random();
            printErrors = showErrors;
            strategy = searchStrategy;
        }
        /// <summary>
        /// Get the next move
        /// </summary>
        /// <param name="watch">timer</param>
        /// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
        /// <param name="depth">How deep to run the simulations; does not impact how deep it goes in the game tree.</param>
        /// <param name="numRollouts">The number of roll outs to play per expansion</param>
        /// <returns></returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
        {
            if(exploration == null)
            {
                exploration = Math.Sqrt(2);
            }
            int count = 0;
            do
            {
                GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
                if(selectedNode == null)
                {
                    if(printErrors)
                        Console.Error.WriteLine("Found no more moves!");
                    break;
                }
                object move = SelectMove(selectedNode);
                GameTreeNode childNode = Expand(selectedNode, move);
                double? winner = childNode.GetWinner();
                if (winner.HasValue)
                {
                    BackPropagate(childNode, winner);
                }
                else
                {
                    for (int i = 0; i<numRollouts; i++)
                    {
                        var clonedState = childNode.state.Clone();
                        winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
                        if (!winner.HasValue)
                            break;//We simulated a game, but it didn't end so we are out of time...
                        BackPropagate(childNode, winner);
                        count++;
                    }
                }
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            if(printErrors)
                Console.Error.WriteLine($"Played {count} games!");
            GameTreeNode bestChild = null;
            double bestScore = double.MinValue;
            foreach(GameTreeNode child in RootNode.children)
            {
                double score = child.GetScore(RootNode.isMax);
                if(bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                if(printErrors)
                    Console.Error.WriteLine($"w: {child.wins} l: {child.loses} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
            }
            if(printErrors)
                Console.Error.WriteLine($"Best: w: {bestChild.wins} l: {bestChild.loses} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
            return bestChild.state.GetMove(RootNode.isMax);
        }
        private void BackPropagate(GameTreeNode selectedNode, double? winner)
        {
            selectedNode.ApplyWinner(winner);
            GameTreeNode tempNode = selectedNode.parent;
            while(tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
        {
            double? winner;
            do
            {
                object move = SelectMoveAtRandom(state, isMax);
                state.ApplyMove(move, isMax);
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    return null;
                }
                depth--;
                isMax = !isMax;
                winner = state.GetWinner();
            }
            while (!winner.HasValue && depth != 0);
            if (winner.HasValue)
            {
                return winner;
            }
            if (depth == 0)
            {
                double eval = state.Evaluate(isMax);
                if (eval > 1)
                {
                    return 1;
                }
                else if (eval < -1)
                    return -1;
                else return eval;
            }
            throw new InvalidOperationException("Could not find a winner for simulation!");
        }
        private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
        {
            Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
            queue.Enqueue(node);
            GameTreeNode tempNode;
            GameTreeNode bestNode = null;
            double maxValue = -1;
            while (queue.Count > 0)
            {
                tempNode = queue.Dequeue();
                if (tempNode.moves.Count == 0)
                {
                    foreach (GameTreeNode child in tempNode.children)
                    {
                        queue.Enqueue(child);
                    }
                }
                else if(tempNode.parent != null)
                {
                    double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
                    double nodeTotal = tempNode.TotalPlays();
                    double parentTotal = tempNode.parent.TotalPlays();
                    double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
                    if(value > maxValue)
                    {
                        maxValue = value;
                        bestNode = tempNode;
                    }
                }
                else return tempNode;
            }
            return bestNode;
        }
        private object SelectMoveAtRandom(IGameState state, bool isMax)
        {
            IList moves = state.GetPossibleMoves(isMax);
            if (moves.Count == 0)
            {
                throw new Exception("No moves available!");
            }
            int index = rand.Next(0, moves.Count);
            return moves[index];
        }
        private object SelectMove(GameTreeNode node)
        {
            switch (strategy)
            {
                case SearchStrategy.Random:
                    return SelectMoveAtRandom(node);
                case SearchStrategy.Sequential:
                    return SelectMoveSequentially(node);
            }
            throw new InvalidOperationException("strategy not supported");
        }
        private object SelectMoveSequentially(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                move = node.moves[0];
                node.moves.RemoveAt(0);
            }
            return move;
        }
        private object SelectMoveAtRandom(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
    }
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms.Trees
{
    public class TreeAlgorithm
    {
        protected GameTreeNode RootNode;
        public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
        {
            if (RootNode != null && findState)
            {
                //if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
                //find the child that matches the new node
                bool isFound = false;
                //Expand any moves left in the root node (if any)
                foreach (object move in RootNode.moves)
                {
                    Expand(RootNode, move);
                }
                //Begin scanning the children
                foreach (GameTreeNode child in RootNode.children)
                {
                    if (child.state.Equals(rootState))
                    {
                        RootNode = child;
                        isFound = true;
                        break;
                    }
                    foreach (object move in child.moves)
                    {
                        Expand(child, move);
                    }
                    foreach (GameTreeNode descendent in child.children)
                    {
                        if (descendent.state.Equals(rootState))
                        {
                            RootNode = descendent;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
                    RootNode = new GameTreeNode(rootState.Clone(), isMax);
                }
                else
                {
                    RootNode.parent = null;
                }
            }
            else
            {
                RootNode = new GameTreeNode(rootState.Clone(), isMax);
            }
        }
        /// <summary>
        /// Expands the given node by create a clone, applying the move and then adding it to the list of children.
        /// </summary>
        /// <param name="node">The node to expand</param>
        /// <param name="move">The move to play on the expanded node</param>
        /// <returns></returns>
        protected GameTreeNode Expand(GameTreeNode node, object move)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, node.isMax);
            GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
    }
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
    public static class BitFunctions
    {
        public static bool IsBitSet(long value, int location)
        {
            long mask = GetBitMask(location);
            return (value & mask) == mask;
        }
        public static long SetBit(long value, int location)
        {
            return value | (GetBitMask(location));
        }
        public static long ClearBit(long value, int location)
        {
            return value & (~(GetBitMask(location)));
        }
        public static long SetOrClearBit(long value, int location, bool isSet)
        {
            if (isSet)
                return SetBit(value, location);
            return ClearBit(value, location);
        }
        public static int NumberOfSetBits(long i)
        {
            i = i - ((i >> 1) & 0x5555555555555555);
            i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
            return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
        }
        public static long GetBitMask(int index)
        {
            return (long)1 << index;
        }
    }
}
