/*
 * File generated by SourceCombiner.exe using 12 source files.
 * Created On: 5/20/2021 10:28:00 PM
*/
using GameSolution;
using GameSolution.Algorithm;
using GameSolution.Entities;
using GameSolution.Moves;
using GameSolution.Utility;
using static GameSolution.Constants;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file IGameState.cs ***
namespace GameSolution.Algorithm
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        List<IMove> GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(IMove move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        IMove GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        int? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
    }
}
//*** SourceCombiner -> original file IMove.cs ***
namespace GameSolution.Algorithm
{
    public interface IMove
    {
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace GameSolution.Algorithm
{
    public class MonteCarloTreeSearch
    {
        private Node rootNode;
        private Random rand;
        public MonteCarloTreeSearch()
        {
            rand = new Random();
        }
        public void SetState(IGameState rootState, bool isMax = true)
        {
            if (rootNode != null)
            {
                //if we have already started searching then continue to search as we go; 
                //find the child that matches the new node
                bool isFound = false;
                foreach(Node child in rootNode.children)
                {
                    foreach(IMove move in child.moves)
                    {
                        Expand(child, move, child.isMax);
                    }
                    foreach(Node child2 in child.children)
                    {
                        if (child2.state.Equals(rootState))
                        {
                            rootNode = child2;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    throw new Exception("Could not find the next state in tree!");
                }
            }
            else
            {
                rootNode = new Node(rootState.Clone(), isMax);
            }
        }
        public IMove GetNextMove(Stopwatch watch, int timeLimit)
        {
            int count = 0;
            do
            {
                Node selectedNode = SelectNodeWithMoves(rootNode);
                int? winner = SimulateGame(selectedNode, watch, timeLimit, selectedNode.isMax);
                BackPropagate(selectedNode, winner);
                count++;
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            Console.Error.WriteLine($"Played {count} games!");
            Node bestChild = null;
            double bestScore = -1;
            foreach(Node child in rootNode.children)
            {
                double score = child.GetScore(rootNode.isMax);
                if(bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                Console.Error.WriteLine($"w: {child.wins} l: {child.loses} d: {child.draws} move: {child.state.GetMove(rootNode.isMax)}");
            }
            Console.Error.WriteLine($"Best: w: {bestChild.wins} l: {bestChild.loses} d: {bestChild.draws}");
            return bestChild.state.GetMove(rootNode.isMax);
        }
        private void BackPropagate(Node selectedNode, int? winner)
        {
            Node tempNode = selectedNode.parent;
            while(tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private int? SimulateGame(Node node, Stopwatch watch, int timeLimit, bool isMax)
        {
            int? winner = node.GetWinner();
            if (winner.HasValue)
            {
                node.ApplyWinner(winner);
                return winner;
            }
            IMove move = SelectMoveAtRandom(node);
            Node childNode = Expand(node, move, isMax);
            if (watch.ElapsedMilliseconds >= timeLimit)
            {
                childNode.ApplyWinner(0);
                node.ApplyWinner(0);
                return 0;
            }
            winner = SimulateGame(childNode, watch, timeLimit, !isMax);
            node.ApplyWinner(winner);
            return winner;
        }
        private Node Expand(Node node, IMove move, bool isMax)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, isMax);
            Node childNode = new Node(nextState, !isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
        private Node SelectNodeWithMoves(Node node)
        {
            Node tempNode = node;
            while (tempNode.moves.Count == 0)
            {
                tempNode = tempNode.children[rand.Next(0, tempNode.children.Count - 1)];
            }
            return tempNode;
        }
        private IMove SelectMoveAtRandom(Node node)
        {
            IMove move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count - 1);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
        internal class Node
        {
            public IGameState state;
            public List<IMove> moves;
            public List<Node> children;
            public int wins = 0;
            public int loses = 0;
            public int draws = 0;
            public int? winner = -8;
            public Node parent;
            public bool isMax;
            public Node(IGameState state, bool isMax, Node parent = null)
            {
                this.state = state;
                moves = state.GetPossibleMoves(isMax);
                children = new List<Node>();
                this.parent = parent;
                this.isMax = isMax;
            }
            public double GetScore(bool isMax)
            {
                if (isMax)
                {
                    return (wins + draws * 0.5) / (wins + draws + loses);
                }
                else
                {
                    return (loses + draws * 0.5) / (wins + draws + loses);
                }
            }
            public int? GetWinner()
            {
                if (winner == -8)
                {
                    winner = state.GetWinner();
                }
                return winner;
            }
            public void ApplyWinner(int? winner)
            {
                switch (winner)
                {
                    case 1:
                        wins++;
                        break;
                    case 0:
                        draws++;
                        break;
                    case -1:
                        loses++;
                        break;
                    default:
                        break;
                }
            }
        }
    }
}
//*** SourceCombiner -> original file Cell.cs ***
namespace GameSolution.Entities
{
    public class Cell
    {
        public int index;
        public int richness;
        public List<int> neighbours;
        public Tree tree;
        private Dictionary<int, Cell> sunDirectionToCellNeighbour;
        //Calculated value that must be reset!
        public int shadowSize { get; private set; }
        public Cell(int index, int richness, List<int> neighbours)
        {
            this.index = index;
            this.richness = richness;
            this.neighbours = neighbours;
            Reset();
        }
        public Cell(Cell cell)
        {
            index = cell.index;
            richness = cell.richness;
            neighbours = new List<int>(cell.neighbours);
            if (cell.HasTree())
            {
                tree = new Tree(cell.tree);
            }
            shadowSize = cell.shadowSize;
        }
        public int GetBonusScore()
        {
            return (int)Math.Pow(2, richness) - 2;
        }
        public void Reset()
        {
            shadowSize = -1;
        }
        public void SetShadowSize(int size)
        {
            shadowSize = Math.Max(shadowSize, size);
        }
        public void SetCellNeighbors(Dictionary<int, Cell> neighbours)
        {
            sunDirectionToCellNeighbour = neighbours;
        }
        /// <summary>
        /// Retrieves the cell neighbor or null if one doesn't exist
        /// </summary>
        /// <param name="sunDirection">the direction of the sun</param>
        /// <returns>The cell in the direction of the sun from this cell</returns>
        public Cell GetCellNeighbor(int sunDirection)
        {
            return sunDirectionToCellNeighbour[sunDirection];
        }
        public bool IsCorner()
        {
            return index == 19 || index == 22 || index == 25 || index == 28 || index == 31 || index == 34;
        }
        public void AddTree(Tree tree)
        {
            if (tree.cellIndex == index)
            {
                this.tree = tree;
            }
        }
        public void RemoveTree()
        {
            this.tree = null;
        }
        public bool HasTree()
        {
            return tree != null;
        }
        public override string ToString()
        {
            return $"index: {index} rich: {richness} shadow:{shadowSize} tree: {tree?.ToString()}";
        }
        public bool Equals(Cell cell)
        {
            if(cell.index == index && richness == cell.richness)
            {
                if(tree == null && cell.tree == null)
                {
                    return true;
                }
                else if(tree != null && cell.tree != null && tree.Equals(cell.tree))
                {
                    return true;
                }   
            }
            return false;
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
namespace GameSolution.Entities
{
    public class Player
    {
        public int sun;
        public int score;
        public bool isWaiting;
        public bool isMe;
        //Calculated from the game board
        public List<Move> possibleMoves;
        public Move movePlayed;
        public Player(bool isMe)
        {
            possibleMoves = new List<Move>();
            this.isMe = isMe;
            movePlayed = null;
        }
        public Player(Player player)
        {
            sun = player.sun;
            score = player.score;
            isWaiting = player.isWaiting;
            possibleMoves = new List<Move>();
            isMe = player.isMe;
            movePlayed = player.movePlayed;
        }
        public void Reset()
        {
            possibleMoves = new List<Move>();
            isWaiting = false;
        }
        public int GetScore()
        {
            return score + sun / 3;
        }
        public bool Equals(Player player)
        {
            if(player.isMe == isMe && player.isWaiting == isWaiting && player.score == score && player.sun == sun)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
//*** SourceCombiner -> original file SunPower.cs ***
namespace GameSolution.Entities
{
    public class SunPower
    {
        public int mySunPower;
        public int oppSunPower;
        public int GetDifference()
        {
            return mySunPower - oppSunPower;
        }
    }
}
//*** SourceCombiner -> original file Tree.cs ***
namespace GameSolution.Entities
{
    public class Tree
    {
        public int cellIndex;
        public int size;
        public bool isMine;
        public bool isDormant;
        //Calculated value
        public bool isSpookyShadow;
        public Tree(int cellIndex, int size, bool isMine, bool isDormant)
        {
            this.cellIndex = cellIndex;
            this.size = size;
            this.isMine = isMine;
            this.isDormant = isDormant;
            isSpookyShadow = false;
        }
        public Tree(Tree tree)
        {
            cellIndex = tree.cellIndex;
            size = tree.size;
            isMine = tree.isMine;
            isDormant = tree.isDormant;
            isSpookyShadow = tree.isSpookyShadow;
        }
        public void Reset()
        {
            isDormant = false;
        }
        public void Grow()
        {
            isDormant = true;
            size += 1;
        }
        public override string ToString()
        {
            return $"i: {cellIndex} s: {size} me: {isMine} d: {isDormant}";
        }
        public bool Equals(Tree tree)
        {
            if(tree.cellIndex == cellIndex && tree.isDormant == isDormant && tree.isMine == isMine && tree.size == size)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Moves
{
    public class Move : IMove
    {
        public string type;
        public int targetCellIdx;
        public int sourceCellIdx;
        public Move(string type, int sourceCellIdx, int targetCellIdx)
        {
            this.type = type;
            this.targetCellIdx = targetCellIdx;
            this.sourceCellIdx = sourceCellIdx;
        }
        public Move(Move move)
        {
            type = move.type;
            targetCellIdx = move.targetCellIdx;
            sourceCellIdx = move.sourceCellIdx;
        }
        public Move(string type, int targetCellIdx)
            : this(type, 0, targetCellIdx)
        {
        }
        public Move(string type)
            : this(type, 0, 0)
        {
        }
        public override string ToString()
        {
            if (type == Actions.WAIT)
            {
                return Actions.WAIT;
            }
            if (type == Actions.SEED)
            {
                return string.Format("{0} {1} {2}", Actions.SEED, sourceCellIdx, targetCellIdx);
            }
            return string.Format("{0} {1}", type, targetCellIdx);
        }
        public static Move Parse(string action)
        {
            string[] parts = action.Split(' ');
            switch (parts[0])
            {
                case Actions.WAIT:
                    return new Move(Actions.WAIT);
                case Actions.SEED:
                    return new Move(Actions.SEED, int.Parse(parts[1]), int.Parse(parts[2]));
                case Actions.GROW:
                case Actions.COMPLETE:
                default:
                    return new Move(parts[0], int.Parse(parts[1]));
            }
        }
    }
}
//*** SourceCombiner -> original file GamePlayer.cs ***
public class GamePlayer
{
    static void Main(string[] args)
    {
        string[] inputs;
        MonteCarloTreeSearch search = new MonteCarloTreeSearch();
        GameState game = new GameState();
        int numberOfCells = int.Parse(Console.ReadLine()); // 37
        for (int i = 0; i < numberOfCells; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int index = int.Parse(inputs[0]); // 0 is the center cell, the next cells spiral outwards
            int richness = int.Parse(inputs[1]); // 0 if the cell is unusable, 1-3 for usable cells
            int neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            int neigh1 = int.Parse(inputs[3]);
            int neigh2 = int.Parse(inputs[4]);
            int neigh3 = int.Parse(inputs[5]);
            int neigh4 = int.Parse(inputs[6]);
            int neigh5 = int.Parse(inputs[7]);
            List<int> neighs = new List<int>(){ neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 };
            Cell cell = new Cell(index, richness, neighs);
            game.board.Add(cell);
        }
        game.BuildCellNeighbors();
        // game loop
        while (true)
        {
            Stopwatch watch = new Stopwatch();
            watch.Start();
            game.RemoveTrees();
            game.ResetPlayers();
            game.day = int.Parse(Console.ReadLine()); // the game lasts 24 days: 0-23
            game.nutrients = int.Parse(Console.ReadLine()); // the base score you gain from the next COMPLETE action
            inputs = Console.ReadLine().Split(' ');
            game.me.sun = int.Parse(inputs[0]); // your sun points
            game.me.score = int.Parse(inputs[1]); // your current score
            game.me.isWaiting = false;
            inputs = Console.ReadLine().Split(' ');
            game.opponent.sun = int.Parse(inputs[0]); // opponent's sun points
            game.opponent.score = int.Parse(inputs[1]); // opponent's score
            game.opponent.isWaiting = inputs[2] != "0"; // whether your opponent is asleep until the next day
            int numberOfTrees = int.Parse(Console.ReadLine()); // the current amount of trees
            for (int i = 0; i < numberOfTrees; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int cellIndex = int.Parse(inputs[0]); // location of this tree
                int size = int.Parse(inputs[1]); // size of this tree: 0-3
                bool isMine = inputs[2] != "0"; // 1 if this is your tree
                bool isDormant = inputs[3] != "0"; // 1 if this tree is dormant
                Tree tree = new Tree(cellIndex, size, isMine, isDormant);
                Cell cell = game.board.First(c => c.index == tree.cellIndex);
                cell.AddTree(tree);
            }
            List<Move> possibleActions = new List<Move>();
            int numberOfPossibleMoves = int.Parse(Console.ReadLine());
            for (int i = 0; i < numberOfPossibleMoves; i++)
            {
                string possibleMove = Console.ReadLine();
                Move movePlayer = Move.Parse(possibleMove);
                possibleActions.Add(movePlayer);
            }
            game.me.possibleMoves = possibleActions;
            game.UpdateGameState(false);
            /*
            if(game.me.possibleMoves.Count != possibleActions.Count)
            {
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.SEED).Count()}");
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.WAIT).Count()}");
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.COMPLETE).Count()}");
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.GROW).Count()}");
                Console.Error.WriteLine("Calculated Actions:");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.SEED).Count()}");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.WAIT).Count()}");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.COMPLETE).Count()}");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.GROW).Count()}");
                throw new Exception($"Possible moves not matching! ");
            }
            */
            GameHelper gameHelper = new GameHelper(game, possibleActions);
            Move move = gameHelper.GetNextMove();
            int limit = game.day == 0 ? 1000 : 90;
            if(limit - watch.ElapsedMilliseconds > 20)
            {
                search.SetState(game);
                IMove moveToPlay = search.GetNextMove(watch, limit);
                Move movePlayer = moveToPlay as Move;
                Console.Error.WriteLine(movePlayer.ToString());
            }
            watch.Stop();
            Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds} / 100");
            Console.WriteLine(move);
        }
    }
    private static List<T> List<T>()
    {
        throw new NotImplementedException();
    }
}
//*** SourceCombiner -> original file Constants.cs ***
namespace GameSolution
{
    public static class Constants
    {
        public const int maxTurns = 24;
        public const int maxTreeSize = 3;
        public const int sunReset = 6;
        public const int treeCompleteCost = 4;
        public enum Richness
        {
            Unusable = 0,
            Low = 1,
            Medium = 2,
            High = 3
        }
        public enum TreeSize
        {
            Seed = 0,
            Small = 1,
            Medium = 2,
            Large = 3
        }
        public static class Actions
        {
            public const string WAIT = "WAIT";
            public const string SEED = "SEED";
            public const string GROW = "GROW";
            public const string COMPLETE = "COMPLETE";
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Utility
{
    class GameHelper
    {
        private GameState currentState;
        private List<Move> possibleActions;
        public GameHelper(GameState state, List<Move> possibleActions)
        {
            currentState = state;
            this.possibleActions = possibleActions;
        }
        public Move GetNextMove()
        {
            Move bestAction = null;
            Move treeInShadow = FindShadowedTree();
            if (treeInShadow != null)
            {
                bestAction = treeInShadow;
            }
            else if (currentState.day >= maxTurns - 2)
            {
                bestAction = FindBestFinalTurnsCompleteAction();
            }
            if(bestAction == null)
            {
                bestAction = FindBestGrowAction(currentState);
                if (bestAction == null)
                {
                    bestAction = FindBestSeedAction();
                }
            }
            Console.Error.WriteLine($"Move: {bestAction} : {possibleActions.Count}");
            if (bestAction == null)
            {
                return possibleActions.First(a => a.type == Actions.WAIT);
            }
            return bestAction;
        }
        private Move FindBestSeedAction()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.SEED).ToList();
            int treeCount = currentState.trees.Where(t => t.isMine).Count();
            int seedCount = currentState.trees.Where(t => t.isMine && t.size == 0).Count();
            GameState state = new GameState(currentState);
            SunPower totalSunPower = CalculateSunPowerForGame(state);
            state = new GameState(currentState);
            int costToUpgrade = GetCostToUpgradeTrees(state);
            if (seedCount <= 0 && maxTurns - currentState.day > 4 && totalSunPower.mySunPower > costToUpgrade)
            {
                int maxPoints = -9999;
                Move bestSeedAction = null;
                foreach (Move move in actions)
                {
                    Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                    Tree tree = currentState.trees.First(t => t.cellIndex == move.sourceCellIdx);
                    if(tree.size == 1)
                    {
                        continue;
                    }
                    GameState afterMove = new GameState(currentState);
                    afterMove.ApplyMove(move, afterMove.me);
                    afterMove.AdvanceDay();
                    afterMove.ApplyMove(new Move(Actions.GROW, cell.index), afterMove.me);
                    SunPower sunPower = CalculateSunPowerForGame(afterMove);
                    int points = cell.richness;
                    points += sunPower.GetDifference();
                    points -= currentState.GetCostToSeed();
                    if (maxPoints < points)
                    {
                        maxPoints = points;
                        bestSeedAction = move;
                    }
                }
                return bestSeedAction;
            }
            return null;
        }
        /// <summary>
        /// Determines cost in sunpower to upgrade every tree in the most efficient way possible
        /// </summary>
        /// <param name="state">The state of the game.  Note the state will be mutated to perform the calculation</param>
        /// <returns>The minimum upgrade cost</returns>
        private int GetCostToUpgradeTrees(GameState state)
        {
            int totalCost = 0;
            foreach(Tree tree in state.trees)
            {
                if(tree.isMine && tree.size == 2)
                {
                    while (tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(tree);
                        tree.Grow();
                    }
                }
            }
            foreach (Tree tree in state.trees)
            {
                if (tree.isMine && tree.size == 1)
                {
                    while (tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(tree);
                        tree.Grow();
                    }
                }
            }
            foreach (Tree tree in state.trees)
            {
                if (tree.isMine && tree.size == 0)
                {
                    while (tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(tree);
                        tree.Grow();
                    }
                }
            }
            return totalCost;
        }
        /// <summary>
        /// Find trees that are better to cut down then to keep standing
        /// </summary>
        /// <returns></returns>
        private Move FindShadowedTree()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.COMPLETE).ToList();
            SunPower sunPowerWithTree = CalculateSunPowerForGame(new GameState(currentState));
            int countLevel3Tree = currentState.trees.Where(t => t.size == maxTreeSize).Count();
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                int scoreOnCut = currentState.GetTreeCutScore(cell);
                scoreOnCut -= 1;//take away one point for the sunpower cost
                GameState afterComplete = new GameState(currentState);
                afterComplete.ApplyMove(move, afterComplete.me);
                SunPower sunPower = CalculateSunPowerForGame(afterComplete);
                //If the amount of power gained keeping the tree is greater than the score we receive from cutting then keep the tree.
                if ((sunPowerWithTree.mySunPower - sunPower.mySunPower) / 3 > scoreOnCut)
                {
                    continue;
                }
                if(sunPowerWithTree.GetDifference() - countLevel3Tree  <= (sunPower.GetDifference() - 4))//Cost to cut down is 4 sun power
                {
                    return move;
                }
            }
            return null;
        }
        private SunPower CalculateSunPowerForGame(GameState state)
        {
            SunPower power = new SunPower();
            SunPower powerTo0 = new SunPower();
            for (int i = 0; i < sunReset; i++)
            {
                state.AdvanceDay();
                if (state.sunDirection == 0)
                {
                    powerTo0.mySunPower = power.mySunPower;
                    powerTo0.oppSunPower = power.oppSunPower;
                }
                if (state.day >= maxTurns)
                {
                    break;
                }
                power.mySunPower += state.mySunPowerGenerationToday;
                power.oppSunPower += state.opponentSunPowerGenerationToday;
            }
            int cycles = (maxTurns - currentState.day) / sunReset;
            power.mySunPower = powerTo0.mySunPower + cycles * power.mySunPower;
            power.oppSunPower = powerTo0.oppSunPower + cycles * power.oppSunPower;
            return power;
        }
        private Move FindBestGrowAction(GameState state)
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.GROW).ToList();
            int maxPoints = -9999;
            Move bestGrowAction = null;
            List<Tree> myTrees = state.trees.Where(t => t.isMine).ToList();
            Dictionary<int, int> treeSizeToCount = new Dictionary<int, int>();
            treeSizeToCount[1] = myTrees.Where(t => t.size == 1).Count();
            treeSizeToCount[2] = myTrees.Where(t => t.size == 2).Count();
            treeSizeToCount[3] = myTrees.Where(t => t.size == 3).Count();
            foreach (Move move in actions)
            {
                Cell cell = state.board.First(c => c.index == move.targetCellIdx);
                Tree tree = cell.tree;
                int treeSizePoints = Math.Max(maxTurns - state.day - maxTreeSize + tree.size, 0);
                Console.Error.WriteLine($"treesizepoints: {treeSizePoints}");
                if (treeSizePoints == 0)
                {
                    continue;
                }
                int cost = state.GetCostToGrow(tree);
                GameState afterMove = new GameState(state);
                afterMove.ApplyMove(move, afterMove.me);
                SunPower sunPower = CalculateSunPowerForGame(afterMove);
                int points = sunPower.GetDifference();
                points -= cost;
                points += cell.richness;
                if (maxPoints < points)
                {
                    maxPoints = points;
                    bestGrowAction = move;
                }
            }
            return bestGrowAction;
        }
        private Move FindBestFinalTurnsCompleteAction()
        {
            if (maxTurns - currentState.day == 2)
            {
                GameState state = new GameState(currentState);
                Move growMove = FindBestGrowAction(currentState);
                if (growMove != null)
                {
                    Cell growCell = currentState.board.First(c => c.index == growMove.targetCellIdx);
                    if (growCell.tree.size == 2)
                    {
                        state.ApplyMove(growMove, state.me);
                        state.AdvanceDay();
                        int power = state.mySunPowerGenerationToday + currentState.me.sun - currentState.GetCostToGrow(growCell.tree);
                        int level3TreeCountOnHighRichness = state.board.Where(c => c.HasTree() && c.tree.size == 3 && (c.richness > 1 || state.nutrients > 3)).Count();
                        Console.Error.WriteLine($"lastTurnPower: {power} treeCount: {level3TreeCountOnHighRichness}");
                        if (power >= (level3TreeCountOnHighRichness) * 4)
                        {
                            return null;
                        }
                    }
                }
            }
            List<Move> actions = possibleActions.Where(a => a.type == Actions.COMPLETE).ToList();
            int maxPoints = 0;
            Move bestAction = null;
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                int points = currentState.GetTreeCutScore(cell);
                points -= 1;//you lose one point (4 sunpower) to chop a tree
                if (maxPoints < points)
                {
                    maxPoints = cell.richness;
                    bestAction = move;
                }
            }
            return bestAction;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Utility
{
    public class GameState : IGameState
    {
        public int day;
        public int nutrients;
        public List<Cell> board;
        public Player me;
        public Player opponent;
        public bool isCopy = false;
        //Calculated from the trees on the board
        public List<Tree> trees
        { get
            {
                if(treeCache == null)
                {
                    treeCache = new List<Tree>();
                    foreach (Cell cell in board)
                    {
                        cell.Reset();
                        if (cell.HasTree())
                        {
                            trees.Add(cell.tree);
                        }
                    }
                }
                return treeCache;
            }
        }
        private List<Tree> treeCache;
        //Calcualted from the day
        public int sunDirection;
        public int shadowDirection;
        public int mySunPowerGenerationToday;
        public int opponentSunPowerGenerationToday;
        //lazy loaded cache
        private Dictionary<string, int> treeSizeKeyToCount;
        public GameState()
        {
            board = new List<Cell>();
            me = new Player(true);
            opponent = new Player(false);
        }
        public GameState(GameState state)
        {
            isCopy = true;
            day = state.day;
            nutrients = state.nutrients;
            board = new List<Cell>(state.board.Select(c => new Cell(c)));
            me = new Player(state.me);
            opponent = new Player(state.opponent);
            treeSizeKeyToCount = null;
            if (me.movePlayed != null && opponent.movePlayed != null)
            {
                me.movePlayed = null;
                opponent.movePlayed = null;
            }
            BuildCellNeighbors();
            UpdateGameState();
        }
        public void UpdateGameState(bool updateMyMoves = true)
        {
            treeSizeKeyToCount = null;
            treeCache = null;
            sunDirection = day % sunReset;
            shadowDirection = sunDirection + sunReset/2 % sunReset;
            //Console.Error.WriteLine($"sundirection: {sunDirection} day: {day}");
            CalculateShadows();
            CalculateSunGeneration();
            if(updateMyMoves)
            {
                CalculatePossibleMoves(true);
            }
            CalculatePossibleMoves(false);
        }
        private void CalculatePossibleMoves(bool isMe)
        {
            Player player = isMe ? me : opponent;
            player.possibleMoves.Clear();
            player.possibleMoves.Add(new Move(Actions.WAIT));
            if (player.isWaiting)
            {
                return;
            }
            //Seed Actions
            if(player.sun >= GetCostToSeed(isMe))
            {
                foreach(Cell cell in board.Where(c => c.HasTree() && c.tree.size > 0 && c.tree.isMine == isMe && !c.tree.isDormant))
                {
                    for (int i = 0; i < sunReset; i++)
                    {
                        Cell current = cell;
                        for (int tSize = 0; tSize < cell.tree.size; tSize++)
                        {
                            current = current.GetCellNeighbor(i);
                            if (current == null)
                            {
                                break;
                            }
                            AddSeedAction(player, current, cell);
                            if(cell.tree.size > 1)
                            {
                                Cell tempCurrent = current;
                                for(int tempTSize = tSize+1; tempTSize < cell.tree.size; tempTSize++)
                                {
                                    tempCurrent = tempCurrent.GetCellNeighbor((i+1) % sunReset);
                                    if (tempCurrent == null)
                                    {
                                        break;
                                    }
                                    AddSeedAction(player, tempCurrent, cell);
                                }
                            }
                        }
                    }
                }
            }
            //Complete Actions
            if(player.sun >= treeCompleteCost)
            {
                foreach(Tree tree in trees.Where(t => t.isMine == isMe && t.size == maxTreeSize && !t.isDormant))
                {
                    player.possibleMoves.Add(new Move(Actions.COMPLETE, tree.cellIndex));   
                }
            }
            //Grow Actions
            foreach(Tree tree in trees.Where(t => t.isMine == isMe && t.size != maxTreeSize && !t.isDormant))
            {
                //Console.Error.WriteLine($"{tree.ToString()} cost: {GetCostToGrow(tree)} sun: {player.sun}");
                if (player.sun >= GetCostToGrow(tree))
                {
                    player.possibleMoves.Add(new Move(Actions.GROW, tree.cellIndex));
                }
            }
        }
        private void AddSeedAction(Player player, Cell currentTargetCell, Cell sourceCell)
        {
            Cell current = currentTargetCell;
            if (current != null && !current.HasTree() && current.richness != (int)Richness.Unusable)
            {
                /*
                if (!isCopy)
                {
                    //Console.Error.WriteLine($"seed index: {current.index} player: {sourceCell.tree.isMine}");
                }
                */
                if (!sourceCell.HasTree())
                {
                    Console.Error.WriteLine($"Source Cell with no tree! {sourceCell}");
                    Console.Error.WriteLine($"CurrentTarget {currentTargetCell}");
                    Console.Error.WriteLine($"player: {player}");
                }
                player.possibleMoves.Add(new Move(Actions.SEED, sourceCell.index, current.index));
            }
        }
        /// <summary>
        /// Calculates the shadows on each cell and spookiness of each tree
        /// </summary>
        private void CalculateShadows()
        {
            //Calculate the shadow size of each cell
            foreach (Cell cell in board)
            {
                if (cell.HasTree())
                {
                    Cell current = cell;
                    for (int i = 0; i < cell.tree.size; i++)
                    {
                        current = current.GetCellNeighbor(sunDirection);
                        if(current == null)
                        {
                            break;
                        }
                        current.SetShadowSize(cell.tree.size);
                    }
                }
            }
            //Calculate the spookiness of each tree
            foreach (Cell cell in board)
            {
                if (cell.HasTree())
                {
                    if (cell.tree.size <= cell.shadowSize)
                    {
                        cell.tree.isSpookyShadow = true;
                    }
                    else
                    {
                        cell.tree.isSpookyShadow = false;
                    }
                }
                //Console.Error.WriteLine(cell);
            }
        }
        public void BuildCellNeighbors()
        {
            foreach (Cell cell in board)
            {
                Dictionary<int, Cell> sunDirectionToCell = new Dictionary<int, Cell>();
                for (int i = 0; i < cell.neighbours.Count; i++)
                {
                    Cell c = board.FirstOrDefault(c => c.index == cell.neighbours[i]);
                    sunDirectionToCell[i] = c;
                }
                cell.SetCellNeighbors(sunDirectionToCell);
            }
        }
        private void CalculateSunGeneration()
        {
            mySunPowerGenerationToday = 0;
            opponentSunPowerGenerationToday = 0;
            foreach(Tree tree in trees)
            {
                if (!tree.isSpookyShadow)
                {
                    if (tree.isMine)
                    {
                        mySunPowerGenerationToday += tree.size;
                    }
                    else
                    {
                        opponentSunPowerGenerationToday += tree.size;
                    }
                }
            }
            //Console.Error.WriteLine($"my sun gen: {mySunPowerGenerationToday}, opp sun gen: {opponentSunPowerGenerationToday}");
        }
        /// <summary>
        /// Applies moves simultaneously
        /// Notes: 
        ///     simultaneous seeds cancel out
        ///     simultaneous completes are shared; nutrients are decreased at the end by the number of trees cut
        /// </summary>
        /// <param name="myMove">The move I am making</param>
        /// <param name="opponentMove">The move my opponent is making</param>
        public void ApplyMoves(Move myMove, Move opponentMove)
        {
            switch (myMove.type)
            {
                case Actions.SEED:
                    if(opponentMove.type == Actions.SEED && myMove.targetCellIdx == opponentMove.targetCellIdx)
                    {
                        Cell sourceCell = board.First(c => c.index == myMove.sourceCellIdx);
                        sourceCell.tree.isDormant = true;
                        sourceCell = board.First(c => c.index == opponentMove.sourceCellIdx);
                        sourceCell.tree.isDormant = true;
                    }
                    else
                    {
                        ApplyMove(myMove, me, false, false);
                        ApplyMove(opponentMove, opponent, false, false);
                    }
                    break;
                default:
                    ApplyMove(myMove, me, false, false);
                    ApplyMove(opponentMove, opponent, false, false);
                    break;
            }
            int countComplete = 0;
            if(myMove.type == Actions.COMPLETE)
            {
                countComplete++;
            }
            if(opponentMove.type == Actions.COMPLETE)
            {
                countComplete++;
            }
            nutrients -= countComplete;
            if (me.isWaiting && opponent.isWaiting)
            {
                AdvanceDay();
            }
            else
            {
                UpdateGameState();
            }
        }
        /// <summary>
        /// Apply a move for a single player
        /// </summary>
        /// <param name="move">The move to play</param>
        /// <param name="player">The player who made the move</param>
        public void ApplyMove(Move move, Player player, bool updateState = true, bool updateNutrients = true)
        {
            Cell targetCell = board.First(c => c.index == move.targetCellIdx);
            Cell sourceCell = board.First(c => c.index == move.sourceCellIdx);
            switch (move.type)
            {
                case Actions.COMPLETE:
                    if(player.sun < treeCompleteCost)
                    {
                        throw new Exception("Not enough sun!");
                    }
                    if (targetCell.tree.isDormant)
                    {
                        throw new Exception("Tree is dormant!");
                    }
                    player.sun -= treeCompleteCost;
                    player.score += GetTreeCutScore(targetCell);
                    targetCell.RemoveTree();
                    if(updateNutrients)
                        nutrients--;
                    if(updateState)
                        UpdateGameState();
                    break;
                case Actions.GROW:
                    int growCost = GetCostToGrow(targetCell.tree);
                    if (player.sun < growCost)
                    {
                        throw new Exception("Not enough sun!");
                    }
                    if (targetCell.tree.isDormant)
                    {
                        throw new Exception("Tree is dormant!");
                    }
                    player.sun -= growCost;
                    targetCell.tree.Grow();
                    if (updateState)
                        UpdateGameState();
                    break;
                case Actions.SEED:
                    int seedCost = GetCostToSeed(player.isMe);
                    if (player.sun < seedCost)
                    {
                        throw new Exception("Not enough sun");
                    }
                    if (sourceCell.tree.isDormant)
                    {
                        throw new Exception("Tree is dormant!");
                    }
                    player.sun -= seedCost;
                    sourceCell.tree.isDormant = true;
                    targetCell.tree = new Tree(targetCell.index, (int)TreeSize.Seed, player.isMe, true);
                    if (updateState)
                        UpdateGameState();
                    break;
                case Actions.WAIT:
                    player.isWaiting = true;
                    if(me.isWaiting && opponent.isWaiting)
                    {
                        if(updateState)
                            AdvanceDay();
                    }
                    break;
                default:
                    break;
            }
        }
        public void AdvanceDay()
        {
            day++;
            ResetPlayers();
            ResetTrees();
            UpdateGameState();
            me.sun += mySunPowerGenerationToday;
            opponent.sun += opponentSunPowerGenerationToday;
        }
        public int GetTreeCutScore(Cell cell)
        {
            return nutrients + (cell.richness * 2 - 2);
        }
        private Dictionary<string, int> GetCacheTreeSize()
        {
            if (treeSizeKeyToCount == null)
            {
                treeSizeKeyToCount = new Dictionary<string, int>();
                for(int i = 0; i<=(int)TreeSize.Large; i++)
                {
                    treeSizeKeyToCount[GetCacheTreeSizeKey(i, true)] = trees.Where(t => t.size == i && t.isMine == true).Count();
                    treeSizeKeyToCount[GetCacheTreeSizeKey(i, false)] = trees.Where(t => t.size == i && t.isMine == false).Count();
                }
            }
            return treeSizeKeyToCount;
        }
        private string GetCacheTreeSizeKey(int size, bool isMe)
        {
            return $"{size}|{isMe}";
        }
        public int GetCostToSeed(bool isMe = true)
        {
            string key = GetCacheTreeSizeKey((int)TreeSize.Seed, isMe);
            return GetCacheTreeSize()[key];
        }
        private Dictionary<int, int> treeSizeToCost = new Dictionary<int, int>()
        {
            {1,1 },
            {2,3 },
            {3,7 }
        };
        public int GetCostToGrow(Tree tree)
        {
            string key = GetCacheTreeSizeKey(tree.size + 1, tree.isMine);
            return GetCacheTreeSize()[key] + treeSizeToCost[tree.size + 1];
        }
        public void ResetPlayers()
        {
            me.Reset();
            opponent.Reset();
        }
        public void ResetTrees()
        {
            foreach(Tree tree in trees)
            {
                tree.Reset();
            }
        }
        public void RemoveTrees()
        {
            treeCache = null;
            foreach (Cell cell in board)
            {
                cell.RemoveTree();
            }
        }
        public List<IMove> GetPossibleMoves(bool isMax)
        {
            Player player = isMax ? me : opponent;
            return new List<IMove>(player.possibleMoves);
        }
        public void ApplyMove(IMove move, bool isMax)
        {
            if (isMax && opponent.movePlayed != null)
            {
                throw new Exception("Expected opponent's move to be empty");
            }
            Player player = isMax ? me : opponent;
            Move movePlayer = move as Move;
            player.movePlayed = movePlayer;
            if(me.movePlayed != null && opponent.movePlayed != null)
            {
                ApplyMoves(me.movePlayed, opponent.movePlayed);
            }
        }
        public IMove GetMove(bool isMax)
        {
            Player player = isMax ? me : opponent;
            return player.movePlayed;
        }
        public IGameState Clone()
        {
            return new GameState(this);
        }
        public int? GetWinner()
        {
            if(day == maxTurns)
            {
                int myScore = me.GetScore();
                int opponentScore = opponent.GetScore();
                if (myScore > opponentScore)
                {
                    return 1;
                }
                else if(myScore < opponentScore)
                {
                    return -1;
                }
                else if(myScore == opponentScore)
                {
                    int countMyTrees = trees.Where(t => t.isMine).Count();
                    int countOppTrees = trees.Where(t => !t.isMine).Count();
                    if (countMyTrees > countOppTrees)
                    {
                        return 1;
                    }
                    else if (countMyTrees < countOppTrees)
                    {
                        return -1;
                    }
                    else return 0;
                }
            }
            return null;
        }
        public bool Equals(IGameState state)
        {
            GameState gameState = state as GameState;
            if(day == gameState.day && nutrients == gameState.nutrients && board.TrueForAll(c => c.Equals(gameState.board.First(cell => cell.index == c.index))) && me.Equals(gameState.me) && opponent.Equals(gameState.opponent))
            {
                return true;
            }
            return false;
        }
    }
}
