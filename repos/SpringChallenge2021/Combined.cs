/*
 * File generated by SourceCombiner.exe using 16 source files.
 * Created On: 10/2/2021 10:25:25 AM
*/
using Algorithms;
using Algorithms.Trees;
using Algorithms.Utility;
using GameSolution.Entities;
using GameSolution.Moves;
using GameSolution.Utility;
using static GameSolution.Constants;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 9 source files.
 * Created On: 10/2/2021 10:22:58 AM
*/
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms
{
    public class TreeAlgorithm
    {
        protected GameTreeNode RootNode { get; private set; }
        public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
        {
            if (RootNode != null && findState)
            {
                //if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
                //find the child that matches the new node
                bool isFound = false;
                //Expand any moves left in the root node (if any)
                foreach (object move in RootNode.moves)
                {
                    Expand(RootNode, move);
                }
                //Begin scanning the children
                foreach (GameTreeNode child in RootNode.children)
                {
                    if (child.state.Equals(rootState))
                    {
                        RootNode = child;
                        isFound = true;
                        break;
                    }
                    foreach (object move in child.moves)
                    {
                        Expand(child, move);
                    }
                    foreach (GameTreeNode descendent in child.children)
                    {
                        if (descendent.state.Equals(rootState))
                        {
                            RootNode = descendent;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
                    RootNode = new GameTreeNode(rootState.Clone(), isMax);
                }
                else
                {
                    RootNode.parent = null;
                }
            }
            else
            {
                RootNode = new GameTreeNode(rootState.Clone(), isMax);
            }
        }
        /// <summary>
        /// Expands the given node by create a clone, applying the move and then adding it to the list of children.
        /// </summary>
        /// <param name="node">The node to expand</param>
        /// <param name="move">The move to play on the expanded node</param>
        /// <returns></returns>
        protected GameTreeNode Expand(GameTreeNode node, object move)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, node.isMax);
            GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
    }
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
    public class GameTreeNode
    {
        public IGameState state;
        public IList moves;
        public List<GameTreeNode> children;
        public double wins = 0;
        public double loses = 0;
        public int totalPlays = 0;
        public GameTreeNode parent;
        public bool isMax;
        public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
        {
            this.state = state;
            moves = state.GetPossibleMoves(isMax);
            children = new List<GameTreeNode>();
            this.parent = parent;
            this.isMax = isMax;
        }
        public double GetScore(bool isMax)
        {
            double totalPlays = TotalPlays();
            if (totalPlays == 0)
                return 0;
            if (isMax)
            {
                return (wins - loses) / totalPlays;
            }
            else
            {
                return (loses - wins) / totalPlays;
            }
        }
        public int TotalPlays()
        {
            return totalPlays;
        }
        public double? GetWinner()
        {
            return state.GetWinner();
        }
        public void ApplyWinner(double? winner)
        {
            if (winner.HasValue)
            {
                if(winner > 0)
                {
                    wins += winner.Value;
                }
                else if(winner < 0)
                {
                    loses += Math.Abs(winner.Value);
                }
                totalPlays++;
            }
        }
        public double Evaluate()
        {
            return state.Evaluate(isMax);
        }
    }
}
//*** SourceCombiner -> original file Graph.cs ***
namespace Algorithms.Graph
{
    public class Graph
    {
        private List<INode> Nodes;
        //Will hold shortest paths from a start node id to an end node id
        private Dictionary<int, Dictionary<int, List<ILink>>> Paths { get; set; }
        public Graph()
        {
            Nodes = new List<INode>();
        }
        public void AddNode(INode node)
        {
            Nodes.Add(node);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            foreach (INode vertex in Nodes)
            {
                InternalBuildShortestPathsFromStartNode(vertex);
            }
        }
        public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            InternalBuildShortestPathsFromStartNode(startNode, maxDistance);
        }
        private void InternalBuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            foreach (INode node in Nodes)
            {
                node.IsExplored = false;
            }
            List<ILink> minimumSpanningTree = new List<ILink>();
            Paths[startNode.Id] = new Dictionary<int, List<ILink>>();
            Paths[startNode.Id][startNode.Id] = new List<ILink>();
            minimumSpanningTree.Add(new Link(startNode, startNode, 0));
            int vertexCount = Nodes.Count;
            double currentDist;
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                ILink bestLink = null;
                ILink parentLink = null;
                foreach (ILink currentLink in minimumSpanningTree)
                {
                    INode currentNode = currentLink.EndNode;
                    currentDist = currentLink.GetDistance(Paths[startNode.Id][currentNode.Id]);
                    foreach (ILink adjacent in currentNode.GetLinks())
                    {
                        INode adjacentNode = adjacent.EndNode;
                        if (adjacentNode.IsExplored)
                        {
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestLink = adjacent;
                            parentLink = currentLink;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode.Id].TryGetValue(currentNode.Id, out List<ILink> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode.Id].TryGetValue(parentLink.EndNode.Id, out List<ILink> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestLink = adjacent;
                                parentLink = currentLink;
                            }
                        }
                    }
                }
                if (parentLink == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestLink);
                bestLink.EndNode.IsExplored = true;
                List<ILink> currentPath = null;
                if (!parentLink.EndNode.Equals(startNode))
                {
                    Paths[startNode.Id].TryGetValue(parentLink.EndNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<ILink>();
                }
                else
                {
                    currentPath = new List<ILink>(currentPath);
                }
                Paths[startNode.Id].Add(bestLink.EndNode.Id, currentPath);
                currentPath.Add(bestLink);
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The next node in the path</returns>
        public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startNode.Id);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
                throw new InvalidOperationException();
            }
            INode shortest = paths.First().EndNode;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
            return shortest;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                return double.MaxValue;
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                return double.MaxValue;
            }
            return paths.First().GetDistance(paths);
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(Node startNode, Node endNode)
        {
            return startNode.GetLinks().Where(l => l.EndNode.Equals(endNode)).First().Distance;
        }
    }
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        public class Node
        {
            public int Id { get; set; }
            public double Distance { get; set; }
            public bool IsExplored { get; set; }
            public Node(int id, double distance)
            {
                Id = id;
                Distance = distance;
            }
            /// <summary>
            /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
            /// </summary>
            /// <param name="currentDist">The current distance from the starting node</param>
            /// <returns>A clone of the node with the proper distance</returns>
            public Node CreateAtDistance(double currentDist)
            {
                return new Node(Id, currentDist + Distance);
            }
        }
        private Dictionary<int, List<Node>> Links { get; set; }
        private Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        private bool IsByDirectional;
        public GraphLinks(bool isByDirectional = true)
        {
            Links = new Dictionary<int, List<Node>>();
            IsByDirectional = isByDirectional;
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, double distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            AddLinkInternal(id1, id2, distance);
            if(IsByDirectional)
                AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            double currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        /// <summary>
        /// Retrieves the full path from start to end
        /// </summary>
        /// <param name="startId">the start id</param>
        /// <param name="endId">the end id</param>
        /// <returns>The full path</returns>
        public List<Node> GetShortestPathAll(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        //Adds links to the node links
        private void AddLinkInternal(int startNode, int endNode, double distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
    public interface INode
    {
        int Id { get; }
        bool IsExplored { get; set; }
        List<ILink> GetLinks();
    }
    public class Node : INode
    {
        public int Id { get; private set; }
        public bool IsExplored { get; set; }
        private List<ILink> Links;
        public Node(int id)
        {
            Id = id;
            IsExplored = false;
            Links = new List<ILink>();
        }
        public void AddLink(ILink link)
        {
            Links.Add(link);
        }
        public List<ILink> GetLinks()
        {
            return Links;
        }
        public bool Equals(INode node)
        {
            return node.Id == Id;
        }
    }
    public interface ILink
    {
        INode StartNode { get; }
        INode EndNode { get; }
        long Distance { get; }
        long GetDistance(List<ILink> currentPath);
    }
    public class Link : ILink
    {
        public INode StartNode { get; private set; }
        public INode EndNode { get; private set; }
        public long Distance { get; private set; }
        public Link(INode startNode, INode endNode, long distance)
        {
            StartNode = startNode;
            EndNode = endNode;
            Distance = distance;
        }
        public long GetDistance(List<ILink> currentPath)
        {
            long distance = 0;
            foreach(ILink link in currentPath)
            {
                distance += link.Distance;
            }
            return distance;
        }
    }
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms
{
    public class Minimax : TreeAlgorithm
    {
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
        {
            double val = 99999999;
            val *= RootNode.isMax ? -1 : 1;
            object bestMove = null;
            foreach (object move in RootNode.moves)
            {
                GameTreeNode child = Expand(RootNode, move);
                double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
                if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
                {
                    bestMove = move;
                    val = currentVal;
                }
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    break;
                }
            }
            return bestMove;
        }
        public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
        {
            if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
            {
                double eval = currentNode.Evaluate();
                return eval;
            }
            double? winner = currentNode.GetWinner();
            if (winner.HasValue)
            {
                return winner.Value;
            }
            if (currentNode.isMax)
            {
                double value = -99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Max(value, minMax);
                    alpha = Math.Max(alpha, value);
                    if (alpha >= beta)
                    {
                        break;
                    }
                }
                return value;
            }
            else
            {
                double value = 99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Min(value, minMax);
                    beta = Math.Min(beta, value);
                    if (beta <= alpha)
                    {
                        break;
                    }
                }
                return value;
            }
        }
    }
}
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        IList GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(object move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        object GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        double? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
        /// <summary>
        /// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
        /// </summary>
        /// <param name="isMax">true if it is max's turn else false</param>
        /// <returns>A number between [-1, 1]</returns>
        double Evaluate(bool isMax);
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms
{
    public class MonteCarloTreeSearch : TreeAlgorithm
    {
        private Random rand;
        private bool printErrors;
        private SearchStrategy strategy;
        public enum SearchStrategy
        {
            Random = 0,
            Sequential = 1
        }
        public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random) 
        {
            rand = new Random();
            printErrors = showErrors;
            strategy = searchStrategy;
        }
        /// <summary>
        /// Get the next move
        /// </summary>
        /// <param name="watch">timer</param>
        /// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
        /// <param name="numRollouts">The number of roll outs to play per expansion</param>
        /// <returns></returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
        {
            if(exploration == null)
            {
                exploration = Math.Sqrt(2);
            }
            int count = 0;
            do
            {
                GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
                if(selectedNode == null)
                {
                    if(printErrors)
                        Console.Error.WriteLine("Found no more moves!");
                    break;
                }
                object move = SelectMove(selectedNode);
                GameTreeNode childNode = Expand(selectedNode, move);
                double? winner = childNode.GetWinner();
                if (winner.HasValue)
                {
                    BackPropagate(childNode, winner);
                }
                else
                {
                    for (int i = 0; i<numRollouts; i++)
                    {
                        var clonedState = childNode.state.Clone();
                        winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
                        BackPropagate(childNode, winner);
                        count++;
                    }
                }
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            if(printErrors)
                Console.Error.WriteLine($"Played {count} games!");
            GameTreeNode bestChild = null;
            double bestScore = double.MinValue;
            foreach(GameTreeNode child in RootNode.children)
            {
                double score = child.GetScore(RootNode.isMax);
                if(bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                if(printErrors)
                    Console.Error.WriteLine($"w: {child.wins} l: {child.loses} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
            }
            if(printErrors)
                Console.Error.WriteLine($"Best: w: {bestChild.wins} l: {bestChild.loses} total: {bestChild.totalPlays}");
            return bestChild.state.GetMove(RootNode.isMax);
        }
        private void BackPropagate(GameTreeNode selectedNode, double? winner)
        {
            selectedNode.ApplyWinner(winner);
            GameTreeNode tempNode = selectedNode.parent;
            while(tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
        {
            double? winner;
            do
            {
                object move = SelectMoveAtRandom(state, isMax);
                state.ApplyMove(move, isMax);
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    return null;
                }
                depth--;
                isMax = !isMax;
                winner = state.GetWinner();
            }
            while (!winner.HasValue && depth != 0);
            if (winner.HasValue)
            {
                return winner;
            }
            if (depth == 0)
            {
                double eval = state.Evaluate(isMax);
                if (eval > 0)
                {
                    return 1;
                }
                else if (eval == 0)
                {
                    return 0;
                }
                else return -1;
            }
            throw new InvalidOperationException("Could not find a winner for simulation!");
        }
        private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
        {
            Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
            queue.Enqueue(node);
            GameTreeNode tempNode;
            GameTreeNode bestNode = null;
            double maxValue = -1;
            while (queue.Count > 0)
            {
                tempNode = queue.Dequeue();
                if (tempNode.moves.Count == 0)
                {
                    foreach (GameTreeNode child in tempNode.children)
                    {
                        queue.Enqueue(child);
                    }
                }
                else if(tempNode.parent != null)
                {
                    double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
                    double nodeTotal = tempNode.TotalPlays();
                    double parentTotal = tempNode.parent.TotalPlays();
                    double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
                    if(value > maxValue)
                    {
                        maxValue = value;
                        bestNode = tempNode;
                    }
                }
                else return tempNode;
            }
            return bestNode;
        }
        private object SelectMoveAtRandom(IGameState state, bool isMax)
        {
            IList moves = state.GetPossibleMoves(isMax);
            int index = rand.Next(0, moves.Count);
            return moves[index];
        }
        private object SelectMove(GameTreeNode node)
        {
            switch (strategy)
            {
                case SearchStrategy.Random:
                    return SelectMoveAtRandom(node);
                case SearchStrategy.Sequential:
                    return SelectMoveSequentially(node);
            }
            throw new InvalidOperationException("strategy not supported");
        }
        private object SelectMoveSequentially(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                move = node.moves[0];
                node.moves.RemoveAt(0);
            }
            return move;
        }
        private object SelectMoveAtRandom(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
    }
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
    public static class BitFunctions
    {
        public static long SetBit(long value, int location)
        {
            return value | (GetBitMask(location));
        }
        public static long ClearBit(long value, int location)
        {
            return value & (~(GetBitMask(location)));
        }
        public static long SetOrClearBit(long value, int location, bool isSet)
        {
            if (isSet)
                return SetBit(value, location);
            return ClearBit(value, location);
        }
        public static int NumberOfSetBits(long i)
        {
            i = i - ((i >> 1) & 0x5555555555555555);
            i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
            return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
        }
        public static long GetBitMask(int index)
        {
            return (long)1 << index;
        }
    }
}
//*** SourceCombiner -> original file Cell.cs ***
namespace GameSolution.Entities
{
    public class Cell
    {
        public int index { get; private set; }
        public int richness { get; private set; }
        public int[] neighbours { get; private set; }
        public Cell(int index, int richness, int[] neighbours)
        {
            this.index = index;
            this.richness = richness;
            this.neighbours = neighbours;
        }
        public Cell(Cell cell)
        {
            index = cell.index;
            richness = cell.richness;
            neighbours = cell.neighbours;
        }
        /// <summary>
        /// Retrieves the cell neighbor index or -1 if one doesn't exist
        /// </summary>
        /// <param name="sunDirection">the direction of the sun</param>
        /// <returns>The cell in the direction of the sun from this cell</returns>
        public int GetCellNeighbor(int sunDirection)
        {
            return neighbours[sunDirection];
        }
        public override string ToString()
        {
            return $"index: {index} rich: {richness}";
        }
        public bool Equals(Cell cell)
        {
            if(cell.index == index && richness == cell.richness)
            {
                return true;
            }
            return false;
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
namespace GameSolution.Entities
{
    public class Player
    {
        public int sun;
        public int score;
        public bool isWaiting;
        public bool isMe;
        //Calculated from the game board
        public List<long> possibleMoves { get; set; }
        public long movePlayedForCurrentTurn;
        public long movePlayedLastTurn;
        public Player(bool isMe)
        {
            possibleMoves = new List<long>();
            this.isMe = isMe;
            movePlayedForCurrentTurn = 0;
            movePlayedLastTurn = 0;
        }
        public Player(Player player)
        {
            sun = player.sun;
            score = player.score;
            isWaiting = player.isWaiting;
            isMe = player.isMe;
            possibleMoves = new List<long>(player.possibleMoves);
            movePlayedForCurrentTurn = player.movePlayedForCurrentTurn;
            movePlayedLastTurn = player.movePlayedLastTurn;
        }
        public void Reset()
        {
            possibleMoves = new List<long>();
            isWaiting = false;
        }
        public void ResetMoves()
        {
            movePlayedLastTurn = movePlayedForCurrentTurn;
            movePlayedForCurrentTurn = 0;
        }
        public int GetScore()
        {
            return score + sun / 3;
        }
        public bool Equals(Player player)
        {
            if (player.isMe == isMe && player.isWaiting == isWaiting && player.score == score && player.sun == sun && player.movePlayedForCurrentTurn == movePlayedForCurrentTurn)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        public override string ToString()
        {
            string strMove = Move.ToString(movePlayedLastTurn);
            return $"sun: {sun}, score: {score}, wait: {isWaiting}, me: {isMe} \n {strMove}";
        }
    }
}
//*** SourceCombiner -> original file SeedMapMask.cs ***
namespace GameSolution.Entities
{
    /// <summary>
    /// This map is intended to calculate all the indices where a seed can be placed at differing sizes
    /// </summary>
    public class SeedMapMask
    {
        public long[][] seedMapByCellThenSize;
        public SeedMapMask(List<Cell> board)
        {
            seedMapByCellThenSize = new long[board.Count][];
            foreach(Cell cell in board)
            {
                int currentCellIndex = cell.index;
                seedMapByCellThenSize[currentCellIndex] = new long[maxTreeSize] { 0, 0, 0 };
                for (int i = 0; i < sunReset; i++)
                {
                    Cell current = cell;
                    for (int tSize = 0; tSize < maxTreeSize; tSize++)
                    {
                        int index = current.GetCellNeighbor(i);
                        if (index == -1)
                        {
                            break;
                        }
                        current = board[index];
                        if(current.richness != (int)Richness.Unusable)
                            seedMapByCellThenSize[currentCellIndex][tSize] |= BitFunctions.GetBitMask(index);
                        Cell tempCurrent = current;
                        for (int tempTSize = tSize + 1; tempTSize < maxTreeSize; tempTSize++)
                        {
                            int cellIndex = tempCurrent.GetCellNeighbor((i + 1) % sunReset);
                            if (cellIndex == -1)
                            {
                                break;
                            }
                            tempCurrent = board[cellIndex];
                            if (tempCurrent.richness != (int)Richness.Unusable)
                                seedMapByCellThenSize[currentCellIndex][tempTSize] |= BitFunctions.GetBitMask(cellIndex);
                        }
                    }
                }
            }
        }
        public long GetSeedMap(int cellIndex, int treeSize, int startSize)
        {
            long seedMap = 0;
            for(int i = startSize - 1; i<treeSize; i++)
            {
                seedMap |= seedMapByCellThenSize[cellIndex][i];
            }
            return seedMap;
        }
        public long GetSeedMap(int cellIndex, int treeSize)
        {
            return seedMapByCellThenSize[cellIndex][treeSize - 1];
        }
    }
}
//*** SourceCombiner -> original file SeedMap.cs ***
namespace GameSolution.Entities
{
    /// <summary>
    /// This map is intended to calculate all the indices where a seed can be placed at differing sizes
    /// </summary>
    public class SeedMap
    {
        public List<int>[][] seedMapByCellThenSize;
        public SeedMap(List<Cell> board)
        {
            seedMapByCellThenSize = new List<int>[board.Count][];
            foreach(Cell cell in board)
            {
                int currentCellIndex = cell.index;
                seedMapByCellThenSize[currentCellIndex] = new List<int>[maxTreeSize];
                seedMapByCellThenSize[currentCellIndex][0] = new List<int>(sunReset);
                seedMapByCellThenSize[currentCellIndex][1] = new List<int>(sunReset * 2);
                seedMapByCellThenSize[currentCellIndex][2] = new List<int>(sunReset * 3);
                for (int i = 0; i < sunReset; i++)
                {
                    Cell current = cell;
                    for (int tSize = 0; tSize < maxTreeSize; tSize++)
                    {
                        int index = current.GetCellNeighbor(i);
                        if (index == -1)
                        {
                            break;
                        }
                        current = board[index];
                        if(current.richness != (int)Richness.Unusable)
                            seedMapByCellThenSize[currentCellIndex][tSize].Add(index);
                        Cell tempCurrent = current;
                        for (int tempTSize = tSize + 1; tempTSize < maxTreeSize; tempTSize++)
                        {
                            int cellIndex = tempCurrent.GetCellNeighbor((i + 1) % sunReset);
                            if (cellIndex == -1)
                            {
                                break;
                            }
                            tempCurrent = board[cellIndex];
                            if (tempCurrent.richness != (int)Richness.Unusable)
                                seedMapByCellThenSize[currentCellIndex][tempTSize].Add(cellIndex);
                        }
                    }
                }
            }
        }
        public List<int> GetSeedMap(int cellIndex, int treeSize)
        {
            return seedMapByCellThenSize[cellIndex][treeSize - 1];
        }
    }
}
//*** SourceCombiner -> original file ShadowMapMask.cs ***
namespace GameSolution.Entities
{
    public class ShadowMapMask
    {
        public long[][] shadowMapDistanceThenSunDirection;
        public ShadowMapMask(List<Cell> board)
        {
            shadowMapDistanceThenSunDirection = new long[maxTreeSize][];
            shadowMapDistanceThenSunDirection[0] = new long[sunReset] { 0, 0, 0, 0, 0, 0 };
            shadowMapDistanceThenSunDirection[1] = new long[sunReset] { 0, 0, 0, 0, 0, 0 };
            shadowMapDistanceThenSunDirection[2] = new long[sunReset] { 0, 0, 0, 0, 0, 0 };
            foreach (Cell cell in board)
            {                
                for (int sunDirection = 0; sunDirection < sunReset; sunDirection++)
                {
                    Cell current = cell;
                    int shadowDirection = (sunDirection + halfSunReset) % sunReset;
                    for(int treeSize = 0; treeSize < maxTreeSize; treeSize++)
                    {
                        int index = current.GetCellNeighbor(shadowDirection);
                        if (index == -1)
                        {
                            break;
                        }
                        current = board[index];
                        shadowMapDistanceThenSunDirection[treeSize][sunDirection] |= BitFunctions.GetBitMask(index);
                    }
                }
            }
        }
        public long GetShadowMap(int treeSize, int sunDirection)
        {
            return shadowMapDistanceThenSunDirection[treeSize - 1][sunDirection];
        }
    }
}
//*** SourceCombiner -> original file ShadowMap.cs ***
namespace GameSolution.Entities
{
    public class ShadowMap
    {
        public List<int>[][] shadowMapByCellThenSunDirection;
        public ShadowMap(List<Cell> board)
        {
            shadowMapByCellThenSunDirection = new List<int>[board.Count][];
            foreach (Cell cell in board)
            {
                shadowMapByCellThenSunDirection[cell.index] = new List<int>[sunReset];
                for (int sunDirection = 0; sunDirection < sunReset; sunDirection++)
                {
                    shadowMapByCellThenSunDirection[cell.index][sunDirection] = new List<int>(maxTreeSize);
                    Cell current = cell;
                    int shadowDirection = (sunDirection + halfSunReset) % sunReset;
                    for(int treeSize = 0; treeSize < maxTreeSize; treeSize++)
                    {
                        int index = current.GetCellNeighbor(shadowDirection);
                        if (index == -1)
                        {
                            break;
                        }
                        current = board[index];
                        shadowMapByCellThenSunDirection[cell.index][sunDirection].Add(index);
                    }
                }
            }
        }
        public List<int> GetShadowMap(int cellIndex, int sunDirection)
        {
            return shadowMapByCellThenSunDirection[cellIndex][sunDirection];
        }
    }
}
//*** SourceCombiner -> original file SunPower.cs ***
namespace GameSolution.Entities
{
    public class SunPower
    {
        public int mySunPower;
        public int oppSunPower;
        public int GetDifference()
        {
            return mySunPower - oppSunPower;
        }
    }
}
//*** SourceCombiner -> original file Tree.cs ***
namespace GameSolution.Entities
{
    public class Tree
    {
        public int cellIndex { get; private set; }
        public int size { get { return (int)(bitBoard & sizeValue); } }
        public bool isMine { get { return (bitBoard & isMineValue) == isMineValue; } }
        public bool isDormant { get { return (bitBoard & isDormantValue) == isDormantValue; } }
        //Calculated value
        public bool isSpookyShadow { get { return (bitBoard & isSpookyShadowValue) == isSpookyShadowValue; } }
        private long bitBoard = 0;
        private static long sizeValue = 3;
        private static long isMineValue = 4;
        private static long isDormantValue = 8;
        private static long isSpookyShadowValue = 16;
        public Tree(int cellIndex, int size, bool isMine, bool isDormant)
        {
            this.cellIndex = cellIndex;
            bitBoard += size;
            bitBoard += isMine ? isMineValue : 0;
            bitBoard += isDormant ? isDormantValue : 0;
        }
        public Tree(Tree tree)
        {
            cellIndex = tree.cellIndex;
            bitBoard = tree.bitBoard;
        }
        public void Reset()
        {
            bitBoard &= ~isDormantValue;
            bitBoard &= ~isSpookyShadowValue;
        }
        public void Grow()
        {
            bitBoard |= isDormantValue;
            bitBoard += 1;
        }
        public void SetSpookyShadow()
        {
            bitBoard |= isSpookyShadowValue;
        }
        public void ChangeOwnership()
        {
            bitBoard ^= isMineValue;
        }
        public void SetDormant(bool isDormant)
        {
            if (isDormant)
            {
                bitBoard |= isDormantValue;
            }
            else
            {
                bitBoard &= ~isDormantValue;
            }
        }
        public override string ToString()
        {
            return $"i: {cellIndex} s: {size} me: {isMine} d: {isDormant}, ss: {isSpookyShadow}";
        }
        public bool Equals(Tree tree)
        {
            if(tree != null && tree.cellIndex == cellIndex && tree.bitBoard == bitBoard)
            {
                return true;
            }
            return false;
        }
    }
}
//*** SourceCombiner -> original file TreeState.cs ***
namespace GameSolution.Entities
{
    public class TreeState
    {
        private long emptyLocations = 274877906943;
        private long[] treeSizeLocations = new long[4] { 0, 0, 0, 0 };
        private long isMineLocations = 0;
        private long isOppLocations = 0;
        private long isDormant = 0;
        private long isSpookyShadow = 0;
        private int[] treeCountCacheMe = new int[4] { -1, -1, -1, -1 };
        private int[] treeCountCacheOpp = new int[4] { -1, -1, -1, -1 };
        public bool Equals(TreeState otherState)
        {
            if(emptyLocations == otherState.emptyLocations && isMineLocations == otherState.isMineLocations && isOppLocations == otherState.isOppLocations && isDormant == otherState.isDormant && isSpookyShadow == otherState.isSpookyShadow)
            {
                for (int i = 0; i <= Constants.maxTreeSize; i++)
                {
                    if (treeSizeLocations[i] != otherState.treeSizeLocations[i])
                        return false;
                }
                return true;
            }
            return false;
        }
        public TreeState()
        {
        }
        public TreeState(TreeState treeState)
        {
            emptyLocations = treeState.emptyLocations;
            treeState.treeSizeLocations.CopyTo(treeSizeLocations, 0);
            isMineLocations = treeState.isMineLocations;
            isOppLocations = treeState.isOppLocations;
            isDormant = treeState.isDormant;
            isSpookyShadow = treeState.isSpookyShadow;
        }
        public void AddTree(Tree tree)
        {
            ref long location = ref GetLocation(tree.size);
            ref long player = ref GetPlayer(tree.isMine);
            var treeCountCache = tree.isMine ? treeCountCacheMe : treeCountCacheOpp;
            treeCountCache[tree.size] = GetCount(tree.size, tree.isMine) + 1;
            location = BitFunctions.SetBit(location, tree.cellIndex);
            player = BitFunctions.SetBit(player, tree.cellIndex);
            emptyLocations = BitFunctions.ClearBit(emptyLocations, tree.cellIndex);
            isDormant = BitFunctions.SetOrClearBit(isDormant, tree.cellIndex, tree.isDormant);
            isSpookyShadow = BitFunctions.SetOrClearBit(isSpookyShadow, tree.cellIndex, tree.isSpookyShadow);
        }
        public void GrowTree(Tree tree)
        {
            ref long location = ref GetLocation(tree.size);
            ref long newLocation = ref GetLocation(tree.size + 1);
            var treeCountCache = tree.isMine ? treeCountCacheMe : treeCountCacheOpp;
            treeCountCache[tree.size] = GetCount(tree.size, tree.isMine) - 1;
            treeCountCache[tree.size + 1] = GetCount(tree.size + 1, tree.isMine) + 1;
            location = BitFunctions.ClearBit(location, tree.cellIndex);
            newLocation = BitFunctions.SetBit(newLocation, tree.cellIndex);
            isDormant = BitFunctions.SetBit(isDormant, tree.cellIndex);
        }
        public void RemoveTree(Tree tree)
        {
            ref long location = ref GetLocation(tree.size);
            ref long player = ref GetPlayer(tree.isMine);
            var treeCountCache = tree.isMine ? treeCountCacheMe : treeCountCacheOpp;
            treeCountCache[tree.size] = GetCount(tree.size, tree.isMine) - 1;
            location = BitFunctions.ClearBit(location, tree.cellIndex);
            player = BitFunctions.ClearBit(player, tree.cellIndex);
            emptyLocations = BitFunctions.SetBit(emptyLocations, tree.cellIndex);
        }
        public Tree GetTree(int cellIndex)
        {
            return new Tree(cellIndex, GetSize(cellIndex), GetIsMine(cellIndex), GetIsDormant(cellIndex));
        }
        public void SetDormant(Tree tree)
        {
            isDormant = BitFunctions.SetBit(isDormant, tree.cellIndex);
        }
        public void SetSpookyShadow(int cellIndex)
        {
            isSpookyShadow = BitFunctions.SetBit(isSpookyShadow, cellIndex);
        }
        public int GetSize(int cellIndex)
        {
            long cellMask = BitFunctions.GetBitMask(cellIndex);
            for(int i = 0; i<= Constants.maxTreeSize; i++)
            {
                if ((treeSizeLocations[i] & cellMask) == cellMask)
                    return i;
            }
            return -1;
        }
        public bool GetIsMine(int cellIndex)
        {
            long cellMask = BitFunctions.GetBitMask(cellIndex);
            if ((isMineLocations & cellMask) == cellMask)
                return true;
            return false;
        }
        public bool GetIsDormant(int cellIndex)
        {
            long cellMask = BitFunctions.GetBitMask(cellIndex);
            if ((isDormant & cellMask) == cellMask)
                return true;
            return false;
        }
        public int GetCountTrees(bool isMe)
        {
            int totalCount = 0;
            for(int i = 0; i<= Constants.maxTreeSize; i++)
            {
                totalCount += GetCount(i, isMe);
            }
            return totalCount;
        }
        public int GetCount(int treeSize, bool isMe)
        {
            var treeCountCache = isMe ? treeCountCacheMe : treeCountCacheOpp;
            if(treeCountCache[treeSize] == -1)
            {
                long location = GetLocation(treeSize);
                long player = GetPlayer(isMe);
                treeCountCache[treeSize] = BitFunctions.NumberOfSetBits(location & player);
            }
            return treeCountCache[treeSize];
        }
        public int GetCountForSun(int treeSize, bool isMe)
        {
            long location = GetLocation(treeSize);
            long player = GetPlayer(isMe);
            return BitFunctions.NumberOfSetBits(location & player & ~isSpookyShadow);
        }
        public long GetCompleteActions(bool isMe)
        {
            long player = GetPlayer(isMe);
            return treeSizeLocations[3] & player & ~isDormant;
        }
        public long GetGrowActions(bool[] treeSizesThatCanGrow, bool isMe)
        {
            long player = GetPlayer(isMe);
            long growActions = 0;
            for(int i = 0; i<treeSizesThatCanGrow.Length; i++)
            {
                if (treeSizesThatCanGrow[i])
                {
                    growActions |= GetLocation(i) & player & ~isDormant;
                }
            }
            return growActions;
        }
        public long GetSeedActions(int treeSize, bool isMe)
        {
            long player = GetPlayer(isMe);
            return GetLocation(treeSize) & player & ~isDormant;
        }
        public long GetTrees(bool isMe)
        {
            long player = GetPlayer(isMe);
            long trees = GetTrees();
            return trees & player;
        }
        public long GetTrees()
        {
            long trees = 0;
            for (int i = 0; i < treeSizeLocations.Length; i++)
            {
                trees |= treeSizeLocations[i];
            }
            return trees;
        }
        public long GetTrees(int size)
        {
            return GetLocation(size);
        }
        public void ResetTrees()
        {
            isDormant = 0;
            isSpookyShadow = 0;
        }
        public void ChangeTreeOwnership()
        {
            long swap = isMineLocations;
            isMineLocations = isOppLocations;
            isOppLocations = swap;
        }
        public long GetSeedableSpaces()
        {
            return emptyLocations;
        }        
        private ref long GetPlayer(bool isMine)
        {
            if (isMine)
                return ref isMineLocations;
            return ref isOppLocations;
        }
        private ref long GetLocation(int size)
        {
            return ref treeSizeLocations[size];
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Moves
{
    /// <summary>
    /// To Try: Change this to a static class and make the move a long and bit board the logic
    /// </summary>
    public static class Move
    {
        public static long waitBitValue = 1;
        public static long seedBitValue = 2;
        public static long growBitValue = 4;
        public static long completeBitValue = 8;
        public static long typeBitValue = 15;
        public static long sourceCellIndexValue = 1008;
        public static long targetCellIndexValue = 64512;
        public static long CreateMove(Actions type, long sourceCellIdx, long targetCellIdx)
        {
            long output = 0;
            switch (type)
            {
                case Actions.WAIT:
                    output |= waitBitValue;
                    break;
                case Actions.SEED:
                    output |= seedBitValue;
                    break;
                case Actions.GROW:
                    output |= growBitValue;
                    break;
                case Actions.COMPLETE:
                    output |= completeBitValue;
                    break;
            }
            if(sourceCellIdx == -1)
            {
                output |= sourceCellIndexValue;
            }
            else
            {
                output |= sourceCellIdx << 4;
            }
            if (targetCellIdx == -1)
            {
                output |= targetCellIndexValue;
            }
            else
            {
                output |= targetCellIdx << 10;
            }
            return output;
        }
        public static long CreateMove(Actions type, int targetCellIdx)
        {
            return CreateMove(type, -1, targetCellIdx);
        }
        public static long CreateMove(Actions type)
        {
            return CreateMove(type, -1, -1);
        }
        public static Actions GetType(long move)
        {
            return (Actions)(move & typeBitValue);
        }
        public static int GetSourceIndex(long move)
        {
            long value = move & sourceCellIndexValue;
            if (value == sourceCellIndexValue)
                return -1;
            else 
                return (int)value >> 4;
        }
        public static int GetTargetIndex(long move)
        {
            long value = move & targetCellIndexValue;
            if (value == targetCellIndexValue)
                return -1;
            else 
                return (int)value >> 10;
        }
        public static string ToString(long move)
        {
            if (move == 0)
                return "";
            Actions type = GetType(move);
            int sourceCellIdx = GetSourceIndex(move);
            int targetCellIdx = GetTargetIndex(move);
            if (type == Actions.WAIT)
            {
                return ActionsString.WAIT;
            }
            if (type == Actions.SEED)
            {
                return string.Format("{0} {1} {2}", ActionsString.SEED, sourceCellIdx, targetCellIdx);
            }
            return string.Format("{0} {1}", type, targetCellIdx);
        }
        public static long Parse(string action)
        {
            string[] parts = action.Split(' ');
            switch (parts[0])
            {
                case ActionsString.WAIT:
                    return CreateMove(Actions.WAIT);
                case ActionsString.SEED:
                    return CreateMove(Actions.SEED, int.Parse(parts[1]), int.Parse(parts[2]));
                case ActionsString.GROW:
                    return CreateMove(Actions.GROW, int.Parse(parts[1]));
                case ActionsString.COMPLETE:
                    return CreateMove(Actions.COMPLETE, int.Parse(parts[1]));    
            }
            throw new InvalidOperationException("invalid action type");
        }
    }
}
//*** SourceCombiner -> original file GamePlayer.cs ***
public class GamePlayer
{
    static void Main(string[] args)
    {
        string[] inputs;
        bool isFirstRound = true;
        //Minimax search = new Minimax();
        MonteCarloTreeSearch search = new MonteCarloTreeSearch(false, MonteCarloTreeSearch.SearchStrategy.Sequential);
        GameState game = new GameState();
        int numberOfCells = int.Parse(Console.ReadLine()); // 37
        for (int i = 0; i < numberOfCells; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int index = int.Parse(inputs[0]); // 0 is the center cell, the next cells spiral outwards
            int richness = int.Parse(inputs[1]); // 0 if the cell is unusable, 1-3 for usable cells
            int neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            int neigh1 = int.Parse(inputs[3]);
            int neigh2 = int.Parse(inputs[4]);
            int neigh3 = int.Parse(inputs[5]);
            int neigh4 = int.Parse(inputs[6]);
            int neigh5 = int.Parse(inputs[7]);
            int[] neighs = new int[]{ neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 };
            Cell cell = new Cell(index, richness, neighs);
            game.board.Insert(cell.index, cell);
        }
        SeedMapMask seedMapMask = new SeedMapMask(game.board);
        game.seedMapMask = seedMapMask;
        ShadowMap shadowMap = new ShadowMap(game.board);
        game.shadowMap = shadowMap;
        //ShadowMapMask shadowMapMask = new ShadowMapMask(game.board);
        //game.shadowMapMask = shadowMapMask;
        // game loop
        while (true)
        {
            //Note: loop appears to start when we read the first item...
            game.day = int.Parse(Console.ReadLine()); // the game lasts 24 days: 0-23
            Stopwatch watch = new Stopwatch();
            watch.Start();
            game.RemoveTrees();
            game.ResetPlayers();
            game.nutrients = int.Parse(Console.ReadLine()); // the base score you gain from the next COMPLETE action
            inputs = Console.ReadLine().Split(' ');
            game.me.sun = int.Parse(inputs[0]); // your sun points
            game.me.score = int.Parse(inputs[1]); // your current score
            game.me.isWaiting = false;
            inputs = Console.ReadLine().Split(' ');
            game.opponent.sun = int.Parse(inputs[0]); // opponent's sun points
            game.opponent.score = int.Parse(inputs[1]); // opponent's score
            game.opponent.isWaiting = inputs[2] != "0"; // whether your opponent is asleep until the next day
            int numberOfTrees = int.Parse(Console.ReadLine()); // the current amount of trees
            for (int i = 0; i < numberOfTrees; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int cellIndex = int.Parse(inputs[0]); // location of this tree
                int size = int.Parse(inputs[1]); // size of this tree: 0-3
                bool isMine = inputs[2] != "0"; // 1 if this is your tree
                bool isDormant = inputs[3] != "0"; // 1 if this tree is dormant
                Tree tree = new Tree(cellIndex, size, isMine, isDormant);
                game.AddTree(tree);
            }
            List<long> possibleActions = new List<long>();
            int numberOfPossibleMoves = int.Parse(Console.ReadLine());
            for (int i = 0; i < numberOfPossibleMoves; i++)
            {
                string possibleMove = Console.ReadLine();
                long movePlayer = Move.Parse(possibleMove);
                possibleActions.Add(movePlayer);
            }
            //Console.Error.WriteLine($"After parsing: {watch.ElapsedMilliseconds}ms");
            //game.me.possibleMoves = possibleActions;
            game.UpdateGameState();
            //Console.Error.WriteLine($"After updating gamestate: {watch.ElapsedMilliseconds}ms");
            /*
            if(game.me.possibleMoves.Count != possibleActions.Count)
            {
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.SEED).Count()}");
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.WAIT).Count()}");
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.COMPLETE).Count()}");
                Console.Error.WriteLine($"{possibleActions.Where(m => m.type == Actions.GROW).Count()}");
                Console.Error.WriteLine("Calculated Actions:");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.SEED).Count()}");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.WAIT).Count()}");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.COMPLETE).Count()}");
                Console.Error.WriteLine($"{game.me.possibleMoves.Where(m => m.type == Actions.GROW).Count()}");
                throw new Exception($"Possible moves not matching! ");
            }
            */
            GC.Collect();
            long move;
            int limit = isFirstRound ? 998 : 98;
            if (true)
            {
                //Console.Error.WriteLine($"Before search: {watch.ElapsedMilliseconds}ms");
                search.SetState(game, true, true);
                object moveToPlay = search.GetNextMove(watch, limit, -1, 20, 1);
                move = (long)moveToPlay;
            }
            else
            {
                GameHelper gameHelper = new GameHelper(game, possibleActions);
                move = gameHelper.GetNextMove();
            }
            watch.Stop();
            Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds} / {limit}");
            isFirstRound = false;
            Console.WriteLine(Move.ToString(move));
        }
    }
}
//*** SourceCombiner -> original file Constants.cs ***
namespace GameSolution
{
    public static class Constants
    {
        public const int maxTurns = 24;
        public const int maxTreeSize = 3;
        public const int sunReset = 6;
        public const int halfSunReset = sunReset / 2;
        public const int treeCompleteCost = 4;
        public static int[] treeSizeToCost = new int[4] { 0, 1, 3, 7 };
        public enum Richness
        {
            Unusable = 0,
            Low = 1,
            Medium = 2,
            High = 3
        }
        public enum TreeSize
        {
            Seed = 0,
            Small = 1,
            Medium = 2,
            Large = 3
        }
        public enum Actions
        {
            WAIT = 1,
            SEED = 2,
            GROW = 4,
            COMPLETE = 8
        }
        public static class ActionsString
        {
            public const string WAIT = "WAIT";
            public const string SEED = "SEED";
            public const string GROW = "GROW";
            public const string COMPLETE = "COMPLETE";
        }
    }
}
//*** SourceCombiner -> original file GameBuilder.cs ***
namespace GameSolution.Utility
{
    public static class GameBuilder
    {
        public static GameState BuildSampleGame()
        {
            GameState game = new GameState();
            game.board.Insert(0, new Cell(0, 3, new int[] { 1, 2, 3, 4, 5, 6 }));
            game.board.Insert(1, new Cell(1, 3, new int[] { 7, 8, 2, 0, 6, 18 }));
            game.board.Insert(2, new Cell(2, 3, new int[] { 8, 9, 10, 3, 0, 1 }));
            game.board.Insert(3, new Cell(3, 3, new int[] { 2, 10, 11, 12, 4, 0 }));
            game.board.Insert(4, new Cell(4, 3, new int[] { 0, 3, 12, 13, 14, 5 }));
            game.board.Insert(5, new Cell(5, 3, new int[] { 6, 0, 4, 14, 15, 16 }));
            game.board.Insert(6, new Cell(6, 3, new int[] { 18, 1, 0, 5, 16, 17 }));
            game.board.Insert(7, new Cell(7, 2, new int[] { 19, 20, 8, 1, 18, 36 }));
            game.board.Insert(8, new Cell(8, 2, new int[] { 20, 21, 9, 2, 1, 7 }));
            game.board.Insert(9, new Cell(9, 2, new int[] { 21, 22, 23, 10, 2, 8 }));
            game.board.Insert(10, new Cell(10, 2, new int[] { 9, 23, 24, 11, 3, 2 }));
            game.board.Insert(11, new Cell(11, 2, new int[] { 10, 24, 25, 26, 12, 3 }));
            game.board.Insert(12, new Cell(12, 2, new int[] { 3, 11, 26, 27, 13, 4 }));
            game.board.Insert(13, new Cell(13, 2, new int[] { 4, 12, 27, 28, 29, 14 }));
            game.board.Insert(14, new Cell(14, 2, new int[] { 5, 4, 13, 29, 30, 15 }));
            game.board.Insert(15, new Cell(15, 2, new int[] { 16, 5, 14, 30, 31, 32 }));
            game.board.Insert(16, new Cell(16, 2, new int[] { 17, 6, 5, 15, 32, 33 }));
            game.board.Insert(17, new Cell(17, 2, new int[] { 35, 18, 6, 16, 33, 34 }));
            game.board.Insert(18, new Cell(18, 2, new int[] { 36, 7, 1, 6, 17, 35 }));
            game.board.Insert(19, new Cell(19, 1, new int[] { -1, -1, 20, 7, 36, -1 }));
            game.board.Insert(20, new Cell(20, 1, new int[] { -1, -1, 21, 8, 7, 19 }));
            game.board.Insert(21, new Cell(21, 1, new int[] { -1, -1, 22, 9, 8, 20 }));
            game.board.Insert(22, new Cell(22, 1, new int[] { -1, -1, -1, 23, 9, 21 }));
            game.board.Insert(23, new Cell(23, 1, new int[] { 22, -1, -1, 24, 10, 9 }));
            game.board.Insert(24, new Cell(24, 1, new int[] { 23, -1, -1, 25, 11, 10 }));
            game.board.Insert(25, new Cell(25, 1, new int[] { 24, -1, -1, -1, 26, 11 }));
            game.board.Insert(26, new Cell(26, 1, new int[] { 11, 25, -1, -1, 27, 12 }));
            game.board.Insert(27, new Cell(27, 1, new int[] { 12, 26, -1, -1, 28, 13 }));
            game.board.Insert(28, new Cell(28, 1, new int[] { 13, 27, -1, -1, -1, 29 }));
            game.board.Insert(29, new Cell(29, 1, new int[] { 14, 13, 28, -1, -1, 30 }));
            game.board.Insert(30, new Cell(30, 1, new int[] { 15, 14, 29, -1, -1, 31 }));
            game.board.Insert(31, new Cell(31, 1, new int[] { 32, 15, 30, -1, -1, -1 }));
            game.board.Insert(32, new Cell(32, 1, new int[] { 33, 16, 15, 31, -1, -1 }));
            game.board.Insert(33, new Cell(33, 1, new int[] { 34, 17, 16, 32, -1, -1 }));
            game.board.Insert(34, new Cell(34, 1, new int[] { -1, 35, 17, 33, -1, -1 }));
            game.board.Insert(35, new Cell(35, 1, new int[] { -1, 36, 18, 17, 34, -1 }));
            game.board.Insert(36, new Cell(36, 1, new int[] { -1, 19, 7, 18, 35, -1 }));
            SeedMapMask seedMapMask = new SeedMapMask(game.board);
            game.seedMapMask = seedMapMask;
            ShadowMap shadowMap = new ShadowMap(game.board);
            game.shadowMap = shadowMap;
            //ShadowMapMask shadowMapMask = new ShadowMapMask(game.board);
            //game.shadowMapMask = shadowMapMask;
            game.ResetTrees();
            game.ResetPlayers();
            game.day = 1;
            game.nutrients = 20;
            game.me.sun = 2;
            game.me.score = 0;
            game.me.isWaiting = false;
            game.opponent.sun = 2;
            game.opponent.score = 0;
            game.opponent.isWaiting = false;
            game.AddTree(new Tree(29, 1, true, false));
            game.AddTree(new Tree(23, 1, true, false));
            game.AddTree(new Tree(20, 1, false, false));
            game.AddTree(new Tree(32, 1, false, false));
            game.UpdateGameState();
            return game;
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Utility
{
    public class GameHelper
    {
        private GameState currentState;
        private List<long> possibleActions;
        public GameHelper(GameState state, List<long> possibleActions)
        {
            currentState = state;
            this.possibleActions = possibleActions;
        }
        public long GetNextMove()
        {
            long bestAction = 0;
            long treeInShadow = FindShadowedTree();
            if (treeInShadow != 0)
            {
                bestAction = treeInShadow;
            }
            else if (currentState.day >= maxTurns - 2)
            {
                bestAction = FindBestFinalTurnsCompleteAction();
            }
            if(bestAction == 0)
            {
                bestAction = FindBestGrowAction(currentState);
                if (bestAction == 0)
                {
                    bestAction = FindBestSeedAction();
                }
            }
            Console.Error.WriteLine($"Move: {bestAction} : {possibleActions.Count}");
            if (bestAction == 0)
            {
                return Move.CreateMove(Actions.WAIT);
            }
            return bestAction;
        }
        private long FindBestSeedAction()
        {
            List<long> actions = possibleActions.Where(a => Move.GetType(a) == Actions.SEED).ToList();
            int treeCount = currentState.TreeEnumeration.Count(t => t.isMine);
            int seedCount = currentState.TreeEnumeration.Count(t => t.isMine && t.size == 0);
            GameState state = new GameState(currentState);
            SunPower totalSunPower = CalculateSunPowerForGame(state);
            state = new GameState(currentState);
            int costToUpgrade = GetCostToUpgradeTrees(state);
            if (seedCount <= 0 && maxTurns - currentState.day > 4 && totalSunPower.mySunPower > costToUpgrade)
            {
                int maxPoints = -9999;
                long bestSeedAction = 0;
                foreach (long move in actions)
                {
                    Cell cell = currentState.board[Move.GetTargetIndex(move)];
                    Tree tree = currentState.GetTree(Move.GetSourceIndex(move));
                    if(tree.size == 1)
                    {
                        continue;
                    }
                    GameState afterMove = new GameState(currentState);
                    afterMove.ApplyMove(move, afterMove.me);
                    afterMove.AdvanceDay();
                    afterMove.ApplyMove(Move.CreateMove(Actions.GROW, cell.index), afterMove.me);
                    SunPower sunPower = CalculateSunPowerForGame(afterMove);
                    int points = cell.richness;
                    points += sunPower.GetDifference();
                    points -= currentState.GetCostToSeed();
                    if (maxPoints < points)
                    {
                        maxPoints = points;
                        bestSeedAction = move;
                    }
                }
                return bestSeedAction;
            }
            return 0;
        }
        /// <summary>
        /// Determines cost in sunpower to upgrade every tree in the most efficient way possible
        /// </summary>
        /// <param name="state">The state of the game.  Note the state will be mutated to perform the calculation</param>
        /// <returns>The minimum upgrade cost</returns>
        private int GetCostToUpgradeTrees(GameState state)
        {
            int totalCost = 0;
            foreach(Tree tree in state.TreeEnumeration)
            {
                if(tree.isMine && tree.size == 2)
                {
                    while (tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(tree);
                        tree.Grow();
                    }
                }
            }
            foreach (Tree tree in state.TreeEnumeration)
            {
                if (tree.isMine && tree.size == 1)
                {
                    while (tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(tree);
                        tree.Grow();
                    }
                }
            }
            foreach (Tree tree in state.TreeEnumeration)
            {
                if (tree.isMine && tree.size == 0)
                {
                    while (tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(tree);
                        tree.Grow();
                    }
                }
            }
            return totalCost;
        }
        /// <summary>
        /// Find trees that are better to cut down then to keep standing
        /// </summary>
        /// <returns></returns>
        private long FindShadowedTree()
        {
            List<long> actions = possibleActions.Where(a => Move.GetType(a) == Actions.COMPLETE).ToList();
            SunPower sunPowerWithTree = CalculateSunPowerForGame(new GameState(currentState));
            int countLevel3Tree = currentState.TreeEnumeration.Count(t => t.size == maxTreeSize);
            foreach (long move in actions)
            {
                Tree tree = currentState.GetTree(Move.GetTargetIndex(move));
                Cell cell = currentState.board[Move.GetTargetIndex(move)];
                int scoreOnCut = currentState.GetTreeCutScore(cell);
                scoreOnCut -= 1;//take away one point for the sunpower cost
                GameState afterComplete = new GameState(currentState);
                afterComplete.ApplyMove(move, afterComplete.me);
                SunPower sunPower = CalculateSunPowerForGame(afterComplete);
                //If the amount of power gained keeping the tree is greater than the score we receive from cutting then keep the tree.
                if ((sunPowerWithTree.mySunPower - sunPower.mySunPower) / 3 > scoreOnCut)
                {
                    continue;
                }
                if(sunPowerWithTree.GetDifference() - countLevel3Tree  <= (sunPower.GetDifference() - 4))//Cost to cut down is 4 sun power
                {
                    return move;
                }
            }
            return 0;
        }
        public static SunPower CalculateSunPowerForGame(GameState state)
        {
            SunPower power = new SunPower();
            SunPower powerTo0 = new SunPower();
            int startingDay = state.day;
            for (int i = 0; i < sunReset; i++)
            {
                state.AdvanceDay();
                if (state.sunDirection == 0)
                {
                    powerTo0.mySunPower = power.mySunPower;
                    powerTo0.oppSunPower = power.oppSunPower;
                }
                if (state.day >= maxTurns)
                {
                    break;
                }
                power.mySunPower += state.mySunPowerGenerationToday;
                power.oppSunPower += state.opponentSunPowerGenerationToday;
            }
            int cycles = (maxTurns - startingDay) / sunReset;
            power.mySunPower = powerTo0.mySunPower + cycles * power.mySunPower;
            power.oppSunPower = powerTo0.oppSunPower + cycles * power.oppSunPower;
            return power;
        }
        private long FindBestGrowAction(GameState state)
        {
            List<long> actions = possibleActions.Where(a => Move.GetType(a) == Actions.GROW).ToList();
            int maxPoints = -9999;
            long bestGrowAction = 0;
            List<Tree> myTrees = state.TreeEnumeration.Where(t => t.isMine).ToList();
            Dictionary<int, int> treeSizeToCount = new Dictionary<int, int>();
            treeSizeToCount[1] = myTrees.Where(t => t.size == 1).Count();
            treeSizeToCount[2] = myTrees.Where(t => t.size == 2).Count();
            treeSizeToCount[3] = myTrees.Where(t => t.size == 3).Count();
            foreach (long move in actions)
            {
                Cell cell = state.board[Move.GetTargetIndex(move)];
                Tree tree = state.GetTree(cell.index);
                int treeSizePoints = Math.Max(maxTurns - state.day - maxTreeSize + tree.size, 0);
                Console.Error.WriteLine($"treesizepoints: {treeSizePoints}");
                if (treeSizePoints == 0)
                {
                    continue;
                }
                int cost = state.GetCostToGrow(tree);
                GameState afterMove = new GameState(state);
                afterMove.ApplyMove(move, afterMove.me);
                SunPower sunPower = CalculateSunPowerForGame(afterMove);
                int points = sunPower.GetDifference();
                points -= cost;
                points += cell.richness;
                if (maxPoints < points)
                {
                    maxPoints = points;
                    bestGrowAction = move;
                }
            }
            return bestGrowAction;
        }
        private long FindBestFinalTurnsCompleteAction()
        {
            if (maxTurns - currentState.day == 2)
            {
                GameState state = new GameState(currentState);
                long growMove = FindBestGrowAction(currentState);
                if (growMove != 0)
                {
                    Tree growTree = currentState.GetTree(Move.GetTargetIndex(growMove));
                    if (growTree.size == 2)
                    {
                        state.ApplyMove(growMove, state.me);
                        state.AdvanceDay();
                        int power = state.mySunPowerGenerationToday + currentState.me.sun - currentState.GetCostToGrow(growTree);
                        int level3TreeCountOnHighRichness = state.TreeEnumeration.Where(t => t.size == 3 && (state.board[t.cellIndex].richness > 1 || state.nutrients > 3)).Count();
                        Console.Error.WriteLine($"lastTurnPower: {power} treeCount: {level3TreeCountOnHighRichness}");
                        if (power >= (level3TreeCountOnHighRichness) * 4)
                        {
                            return 0;
                        }
                    }
                }
            }
            List<long> actions = possibleActions.Where(a => Move.GetType(a) == Actions.COMPLETE).ToList();
            int maxPoints = 0;
            long bestAction = 0;
            foreach (long move in actions)
            {
                Tree tree = currentState.GetTree(Move.GetTargetIndex(move));
                Cell cell = currentState.board[Move.GetTargetIndex(move)];
                int points = currentState.GetTreeCutScore(cell);
                points -= 1;//you lose one point (4 sunpower) to chop a tree
                if (maxPoints < points)
                {
                    maxPoints = cell.richness;
                    bestAction = move;
                }
            }
            return bestAction;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Utility
{
    public class GameState : IGameState
    {
        public int day;
        public int nutrients;
        public List<Cell> board;
        public Player me;
        public Player opponent;
        public SeedMapMask seedMapMask;
        public ShadowMap shadowMap;
        //public ShadowMapMask shadowMapMask;
        public TreeState treeList;
        //Calcualted from the day
        public int sunDirection;
        public int mySunPowerGenerationToday;
        public int opponentSunPowerGenerationToday;
        //Calculated from the trees on the board
        public IEnumerable<Tree> TreeEnumeration
        {
            get
            {
                List<Tree> trees = new List<Tree>(board.Count);
                for(int i =0; i<board.Count; i++)
                {
                    Tree tree = treeList.GetTree(i);
                    if(tree.size != -1)
                    {
                        trees.Add(tree);
                    }
                }
                return trees;
            }
        }
        public GameState(int boardSize = 37)
        {
            board = new List<Cell>(boardSize);
            me = new Player(true);
            opponent = new Player(false);
            treeList = new TreeState();
        }
        public GameState(GameState state)
        {
            day = state.day;
            nutrients = state.nutrients;
            board = state.board;
            me = new Player(state.me);
            opponent = new Player(state.opponent);
            seedMapMask = state.seedMapMask;
            shadowMap = state.shadowMap;
            //shadowMapMask = state.shadowMapMask;
            treeList = new TreeState(state.treeList);
        }
        public void AddTree(Tree tree)
        {
            treeList.AddTree(tree);
        }
        public void GrowTree(Tree tree)
        {
            treeList.GrowTree(tree);
        }
        public void RemoveTree(Tree tree)
        {
            treeList.RemoveTree(tree);
        }
        public void SetDormant(Tree tree)
        {
            treeList.SetDormant(tree);
            tree.SetDormant(true);
        }
        public void ChangeTreeOwnership()
        {
            treeList.ChangeTreeOwnership();
        }
        public Tree GetTree(int cellIndex)
        {
            return treeList.GetTree(cellIndex);
        }
        public void UpdateGameState(bool applySun = false)
        {
            sunDirection = day % sunReset;
            if (applySun)
            {
                CalculateShadowsNew();
                CalculateSunGeneration(true);
            }
            CalculateMoves(true);
            CalculateMoves(false);
        }
        private void CalculateMoves(bool isMe)
        {
            Player player = isMe ? me : opponent;
            List<long> possibleMoves = player.possibleMoves;
            bool isWaiting = player.isWaiting;
            int sun = player.sun;
            possibleMoves.Clear();
            if (day == 24)
            {
                return;
            }
            int costToSeed;
            int size3TreeToCut = 4;
            bool canCut;
            bool canSeed;
            if (day > 14)
            {
                size3TreeToCut--;
            }
            if (day > 18)
            {
                size3TreeToCut--;
            }
            if (day > 20)
            {
                size3TreeToCut--;
            }
            if (isWaiting)
            {
                possibleMoves.Add(Move.CreateMove(Actions.WAIT));
                return;
            }
            else
            {
                costToSeed = treeList.GetCount(0, isMe);
                canCut = day > 11 && sun >= treeCompleteCost && (day > 22 || treeList.GetCount((int)TreeSize.Large, isMe) > size3TreeToCut);
                canSeed = sun >= costToSeed && costToSeed < 1;//only seed when cost is 0
            }
            if (canCut)
            {
                //Complete actions
                long completeTrees = treeList.GetCompleteActions(isMe);
                for (var cellIndex = 0; completeTrees != 0; cellIndex++)
                {
                    if ((completeTrees & 1) == 1)
                        possibleMoves.Add(Move.CreateMove(Actions.COMPLETE, cellIndex));
                    completeTrees >>= 1;
                }
            }
            //Grow actions
            {
                bool[] canGrow = new bool[3]
                {
                    sun >= GetCostToGrow(isMe, 0),
                    sun >= GetCostToGrow(isMe, 1),
                    sun >= GetCostToGrow(isMe, 2)
                };
                long growTrees = treeList.GetGrowActions(canGrow, isMe);
                for (var cellIndex = 0; growTrees != 0; cellIndex++)
                {
                    if ((growTrees & 1) == 1)
                        possibleMoves.Add(Move.CreateMove(Actions.GROW, cellIndex));
                    growTrees >>= 1;
                }
            }
            if (canSeed)
            {
                long allTrees = treeList.GetTrees(isMe);
                for (int i = 2; i <= maxTreeSize; i++)//Skip seeding for size 1 trees
                {
                    long seedTrees = treeList.GetSeedActions(i, isMe);
                    for (var cellIndex = 0; seedTrees != 0; cellIndex++)
                    {
                        if ((seedTrees & 1) == 1)
                        {
                            long seedableLocations = treeList.GetSeedableSpaces() & seedMapMask.GetSeedMap(cellIndex, i, (int)TreeSize.Medium);//Skip seeding 1 space away; retrieve seedable locations starting from size 2;
                            for(var targetCellIndex = 0; seedableLocations != 0; targetCellIndex++)
                            {
                                if ((seedableLocations & 1) == 1)
                                {
                                    if ((seedMapMask.GetSeedMap(targetCellIndex, (int)TreeSize.Small) & allTrees) == 0)//Don't seed next to own trees
                                    {
                                        possibleMoves.Add(Move.CreateMove(Actions.SEED, cellIndex, targetCellIndex));
                                    }
                                }
                                seedableLocations >>= 1;
                            }
                        }
                        seedTrees >>= 1;
                    }
                }
            }
            if (possibleMoves.Count == 0 || sun < 3)
            {
                possibleMoves.Add(Move.CreateMove(Actions.WAIT));
            }
        }
        /// <summary>
        /// Calculates the spookiness of each tree
        /// </summary>
        private void CalculateShadowsNew()
        {
            //Calculate the shadow size of each cell
            long trees = treeList.GetTrees(1) | treeList.GetTrees(2) | treeList.GetTrees(3);
            for (var cellIndex = 0; trees != 0; cellIndex++)
            {
                if ((trees & 1) == 1)
                {
                    int distance = 1;
                    int treeSize = treeList.GetSize(cellIndex);
                    foreach (int shadowCellIndex in shadowMap.GetShadowMap(cellIndex, sunDirection))
                    {
                        int shadowSize = treeList.GetSize(shadowCellIndex);
                        if (shadowSize >= distance && shadowSize >= treeSize)
                        {
                            treeList.SetSpookyShadow(cellIndex);
                            break;
                        }
                        distance++;
                    }
                }
                trees >>= 1;
            }
        }
        private void CalculateSunGeneration(bool apply)
        {
            mySunPowerGenerationToday = 0;
            opponentSunPowerGenerationToday = 0;
            for (int i = 1; i<=maxTreeSize; i++)
            {
                mySunPowerGenerationToday += treeList.GetCountForSun(i, true) * i;
                opponentSunPowerGenerationToday += treeList.GetCountForSun(i, false) * i;
            }
            if (apply)
            {
                me.sun += mySunPowerGenerationToday;
                opponent.sun += opponentSunPowerGenerationToday;
                //Console.Error.WriteLine($"day: {day}, my sun gen: {mySunPowerGenerationToday}, opp sun gen: {opponentSunPowerGenerationToday}");
            }
        }
        /// <summary>
        /// Applies moves simultaneously
        /// Notes: 
        ///     simultaneous seeds cancel out
        ///     simultaneous completes are shared; nutrients are decreased at the end by the number of trees cut
        /// </summary>
        /// <param name="myMove">The move I am making</param>
        /// <param name="opponentMove">The move my opponent is making</param>
        public void ApplyMoves(long myMove, long opponentMove)
        {
            switch (Move.GetType(myMove))
            {
                case Actions.SEED:
                    if(Move.GetType(opponentMove) == Actions.SEED && Move.GetTargetIndex(myMove) == Move.GetTargetIndex(opponentMove))
                    {
                        Tree sourceTree = GetTree(Move.GetSourceIndex(myMove));
                        SetDormant(sourceTree);
                        sourceTree = GetTree(Move.GetSourceIndex(opponentMove));
                        SetDormant(sourceTree);
                    }
                    else
                    {
                        ApplyMove(myMove, me, false, false);
                        ApplyMove(opponentMove, opponent, false, false);
                    }
                    break;
                default:
                    ApplyMove(myMove, me, false, false);
                    ApplyMove(opponentMove, opponent, false, false);
                    break;
            }
            int countComplete = 0;
            if(Move.GetType(myMove) == Actions.COMPLETE)
            {
                countComplete++;
            }
            if(Move.GetType(opponentMove) == Actions.COMPLETE)
            {
                countComplete++;
            }
            nutrients -= countComplete;
            if (me.isWaiting && opponent.isWaiting)
            {
                AdvanceDay();
            }
            else
            {
                UpdateGameState();
            }
            //Reset moves for the turn
            me.ResetMoves();
            opponent.ResetMoves();
        }
        /// <summary>
        /// Apply a move for a single player
        /// </summary>
        /// <param name="move">The move to play</param>
        /// <param name="player">The player who made the move</param>
        public void ApplyMove(long move, Player player, bool updateState = true, bool updateNutrients = true)
        {
            int targetIndex = Move.GetTargetIndex(move);
            int sourceIndex = Move.GetSourceIndex(move);
            Tree targetTree = null;
            Tree sourceTree = null;
            if(targetIndex != -1)
            {
                targetTree = GetTree(targetIndex);
            }
            if(sourceIndex != -1)
            {
                sourceTree = GetTree(sourceIndex);
            }
            switch (Move.GetType(move))
            {
                case Actions.COMPLETE:
                    if(player.sun < treeCompleteCost)
                    {
                        throw new Exception("Not enough sun!");
                    }
                    if (targetTree.isDormant)
                    {
                        throw new Exception("Tree is dormant!");
                    }
                    player.sun -= treeCompleteCost;
                    player.score += GetTreeCutScore(board[targetIndex]);
                    RemoveTree(targetTree);
                    if(updateNutrients)
                        nutrients--;
                    if(updateState)
                        UpdateGameState();
                    break;
                case Actions.GROW:
                    int growCost = GetCostToGrow(targetTree);
                    if (player.sun < growCost)
                    {
                        throw new Exception("Not enough sun!");
                    }
                    if (targetTree.isDormant)
                    {
                        throw new Exception("Tree is dormant!");
                    }
                    player.sun -= growCost;
                    GrowTree(targetTree);
                    if (updateState)
                        UpdateGameState();
                    break;
                case Actions.SEED:
                    int seedCost = GetCostToSeed(player.isMe);
                    if (player.sun < seedCost)
                    {
                        throw new Exception("Not enough sun");
                    }
                    if (sourceTree.isDormant)
                    {
                        throw new Exception("Tree is dormant!");
                    }
                    player.sun -= seedCost;
                    SetDormant(sourceTree);
                    AddTree(new Tree(targetIndex, (int)TreeSize.Seed, player.isMe, true));
                    if (updateState)
                        UpdateGameState();
                    break;
                case Actions.WAIT:
                    player.isWaiting = true;
                    if(me.isWaiting && opponent.isWaiting)
                    {
                        if(updateState)
                            AdvanceDay();
                    }
                    break;
                default:
                    break;
            }
        }
        public void AdvanceDay()
        {
            day++;
            ResetPlayers();
            ResetTrees();
            UpdateGameState(true);
        }
        public int GetTreeCutScore(Cell cell)
        {
            return nutrients + (cell.richness * 2 - 2);
        }
        public int GetCostToSeed(bool isMe = true)
        {
            return treeList.GetCount((int)TreeSize.Seed, isMe);
        }
        public int GetNumberOfTrees(bool isMe, int size)
        {
            return treeList.GetCount(size, isMe);
        }
        public int GetCostToGrow(Tree tree)
        {
            return GetCostToGrow(tree.isMine, tree.size);
        }
        public int GetCostToGrow(bool isMe, int treeSize)
        {
            treeSize++;
            return treeList.GetCount(treeSize, isMe) + treeSizeToCost[treeSize];
        }
        public void ResetPlayers()
        {
            me.Reset();
            opponent.Reset();
        }
        public void ResetTrees()
        {
            treeList.ResetTrees();
        }
        public void RemoveTrees()
        {
            treeList = new TreeState();
        }
        public IList GetPossibleMoves(bool isMax)
        {
            Player player = isMax ? me : opponent;
            return player.possibleMoves;
        }
        public void ApplyMove(object move, bool isMax)
        {
            if (isMax && opponent.movePlayedForCurrentTurn != 0)
            {
                throw new Exception("Expected opponent's move to be empty");
            }
            Player player = isMax ? me : opponent;
            long movePlayer = (long)move;
            player.movePlayedForCurrentTurn = movePlayer;
            if(me.movePlayedForCurrentTurn != 0 && opponent.movePlayedForCurrentTurn != 0)
            {
                ApplyMoves(me.movePlayedForCurrentTurn, opponent.movePlayedForCurrentTurn);
            }
        }
        public object GetMove(bool isMax)
        {
            Player player = isMax ? me : opponent;
            if (player.movePlayedForCurrentTurn != 0)
                return player.movePlayedForCurrentTurn;
            else return player.movePlayedLastTurn;
        }
        public IGameState Clone()
        {
            return new GameState(this);
        }
        public double? GetWinner()
        {
            if (day == maxTurns)
            {
                int myScore = me.GetScore();
                int opponentScore = opponent.GetScore();
                if (myScore > opponentScore)
                {
                    return (myScore - opponentScore);
                }
                else if (myScore < opponentScore)
                {
                    return (myScore - opponentScore);
                }
                else if (myScore == opponentScore)
                {
                    int countMyTrees = treeList.GetCountTrees(true);
                    int countOppTrees = treeList.GetCountTrees(false);
                    if (countMyTrees > countOppTrees)
                    {
                        return (countMyTrees - countOppTrees) * 0.0001;
                    }
                    else if (countMyTrees < countOppTrees)
                    {
                        return (countMyTrees - countOppTrees) * 0.0001;
                    }
                    else return 0;
                }
            }
            else if (day > maxTurns)
                throw new Exception("day advanced too far");
            return null;
        }
        public bool Equals(IGameState state)
        {
            GameState gameState = state as GameState;
            if(day == gameState.day && nutrients == gameState.nutrients && me.Equals(gameState.me) && opponent.Equals(gameState.opponent) && treeList.Equals(gameState.treeList))
            {
                return true;
            }
            return false;
        }
        public double Evaluate(bool isMax)
        {
            SunPower power = GameHelper.CalculateSunPowerForGame(this);
            double denominator = power.mySunPower + power.oppSunPower;
            double difference = power.GetDifference();
            if (denominator != 0)
            {
                difference = difference / denominator;
                return isMax ? difference : -1 * difference;
            }
            return 0;
        }
        public override string ToString()
        {
            return "d: " + day + " n: " + nutrients + "\n" + treeList.ToString() + "\n" + me.ToString() + "\n" + opponent.ToString();
        }
    }
}
