/*
 * File generated by SourceCombiner.exe using 7 source files.
 * Created On: 5/11/2021 9:59:26 PM
*/
using GameSolution;
using GameSolution.Entities;
using GameSolution.Moves;
using GameSolution.Utility;
using static GameSolution.Constants;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file Cell.cs ***
namespace GameSolution.Entities
{
    public class Cell
    {
        public int index;
        public int richness;
        public List<int> neighbours;
        public Tree tree;
        private Dictionary<int, Cell> sunDirectionToCellNeighbour;
        //Calculated value that must be reset!
        public int shadowSize { get; private set; }
        public Cell(int index, int richness, List<int> neighbours)
        {
            this.index = index;
            this.richness = richness;
            this.neighbours = neighbours;
            Reset();
        }
        public Cell(Cell cell)
        {
            index = cell.index;
            richness = cell.richness;
            neighbours = new List<int>(cell.neighbours);
            if (cell.HasTree())
            {
                tree = new Tree(cell.tree);
            }
            shadowSize = cell.shadowSize;
        }
        public void Reset()
        {
            shadowSize = -1;
        }
        public void SetShadowSize(int size)
        {
            shadowSize = Math.Max(shadowSize, size);
        }
        public void SetCellNeighbors(Dictionary<int, Cell> neighbours)
        {
            sunDirectionToCellNeighbour = neighbours;
        }
        /// <summary>
        /// Retrieves the cell neighbor or null if one doesn't exist
        /// </summary>
        /// <param name="sunDirection">the direction of the sun</param>
        /// <returns>The cell in the direction of the sun from this cell</returns>
        public Cell GetCellNeighbor(int sunDirection)
        {
            return sunDirectionToCellNeighbour[sunDirection];
        }
        public bool IsCorner()
        {
            return index == 19 || index == 22 || index == 25 || index == 28 || index == 31 || index == 34;
        }
        public void AddTree(Tree tree)
        {
            if (tree.cellIndex == index)
            {
                this.tree = tree;
            }
        }
        public void RemoveTree()
        {
            this.tree = null;
        }
        public bool HasTree()
        {
            return tree != null;
        }
        public override string ToString()
        {
            return $"i: {index} r: {richness} s:{shadowSize} ts: {tree?.size} spooky:{tree?.isSpookyShadow}";
        }
    }
}
//*** SourceCombiner -> original file Tree.cs ***
namespace GameSolution.Entities
{
    public class Tree
    {
        public int cellIndex;
        public int size;
        public bool isMine;
        public bool isDormant;
        //Calculated value
        public bool isSpookyShadow;
        public Tree(int cellIndex, int size, bool isMine, bool isDormant)
        {
            this.cellIndex = cellIndex;
            this.size = size;
            this.isMine = isMine;
            this.isDormant = isDormant;
            isSpookyShadow = false;
        }
        public Tree(Tree tree)
        {
            cellIndex = tree.cellIndex;
            size = tree.size;
            isMine = tree.isMine;
            isDormant = tree.isDormant;
            isSpookyShadow = tree.isSpookyShadow;
        }
        public void Grow()
        {
            isDormant = true;
            size += 1;
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Moves
{
    public class Move
    {
        public string type;
        public int targetCellIdx;
        public int sourceCellIdx;
        public Move(string type, int sourceCellIdx, int targetCellIdx)
        {
            this.type = type;
            this.targetCellIdx = targetCellIdx;
            this.sourceCellIdx = sourceCellIdx;
        }
        public Move(Move move)
        {
            type = move.type;
            targetCellIdx = move.targetCellIdx;
            sourceCellIdx = move.sourceCellIdx;
        }
        public Move(string type, int targetCellIdx)
            : this(type, 0, targetCellIdx)
        {
        }
        public Move(string type)
            : this(type, 0, 0)
        {
        }
        public override string ToString()
        {
            if (type == Actions.WAIT)
            {
                return Actions.WAIT;
            }
            if (type == Actions.SEED)
            {
                return string.Format("{0} {1} {2}", Actions.SEED, sourceCellIdx, targetCellIdx);
            }
            return string.Format("{0} {1}", type, targetCellIdx);
        }
        public static Move Parse(string action)
        {
            string[] parts = action.Split(' ');
            switch (parts[0])
            {
                case Actions.WAIT:
                    return new Move(Actions.WAIT);
                case Actions.SEED:
                    return new Move(Actions.SEED, int.Parse(parts[1]), int.Parse(parts[2]));
                case Actions.GROW:
                case Actions.COMPLETE:
                default:
                    return new Move(parts[0], int.Parse(parts[1]));
            }
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
public class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        GameState game = new GameState();
        int numberOfCells = int.Parse(Console.ReadLine()); // 37
        for (int i = 0; i < numberOfCells; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int index = int.Parse(inputs[0]); // 0 is the center cell, the next cells spiral outwards
            int richness = int.Parse(inputs[1]); // 0 if the cell is unusable, 1-3 for usable cells
            int neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            int neigh1 = int.Parse(inputs[3]);
            int neigh2 = int.Parse(inputs[4]);
            int neigh3 = int.Parse(inputs[5]);
            int neigh4 = int.Parse(inputs[6]);
            int neigh5 = int.Parse(inputs[7]);
            List<int> neighs = new List<int>(){ neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 };
            Cell cell = new Cell(index, richness, neighs);
            game.board.Add(cell);
        }
        game.BuildCellNeighbors();
        // game loop
        while (true)
        {
            game.ResetTrees();
            game.day = int.Parse(Console.ReadLine()); // the game lasts 24 days: 0-23
            game.nutrients = int.Parse(Console.ReadLine()); // the base score you gain from the next COMPLETE action
            inputs = Console.ReadLine().Split(' ');
            game.mySun = int.Parse(inputs[0]); // your sun points
            game.myScore = int.Parse(inputs[1]); // your current score
            inputs = Console.ReadLine().Split(' ');
            game.opponentSun = int.Parse(inputs[0]); // opponent's sun points
            game.opponentScore = int.Parse(inputs[1]); // opponent's score
            game.opponentIsWaiting = inputs[2] != "0"; // whether your opponent is asleep until the next day
            int numberOfTrees = int.Parse(Console.ReadLine()); // the current amount of trees
            for (int i = 0; i < numberOfTrees; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int cellIndex = int.Parse(inputs[0]); // location of this tree
                int size = int.Parse(inputs[1]); // size of this tree: 0-3
                bool isMine = inputs[2] != "0"; // 1 if this is your tree
                bool isDormant = inputs[3] != "0"; // 1 if this tree is dormant
                Tree tree = new Tree(cellIndex, size, isMine, isDormant);
                Cell cell = game.board.First(c => c.index == tree.cellIndex);
                cell.AddTree(tree);
            }
            List<Move> possibleActions = new List<Move>();
            int numberOfPossibleMoves = int.Parse(Console.ReadLine());
            for (int i = 0; i < numberOfPossibleMoves; i++)
            {
                string possibleMove = Console.ReadLine();
                possibleActions.Add(Move.Parse(possibleMove));
            }
            game.UpdateGameState();
            GameHelper gameHelper = new GameHelper(game, possibleActions);
            Move move = gameHelper.GetNextMove();
            Console.WriteLine(move);
        }
    }
    private static List<T> List<T>()
    {
        throw new NotImplementedException();
    }
}
//*** SourceCombiner -> original file Constants.cs ***
namespace GameSolution
{
    public static class Constants
    {
        public const int maxTurns = 24;
        public const int maxTreeSize = 3;
        public const int sunReset = 6;
        public static class Actions
        {
            public const string WAIT = "WAIT";
            public const string SEED = "SEED";
            public const string GROW = "GROW";
            public const string COMPLETE = "COMPLETE";
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Utility
{
    class GameHelper
    {
        private GameState currentState;
        private List<Move> possibleActions;
        public GameHelper(GameState state, List<Move> possibleActions)
        {
            currentState = state;
            this.possibleActions = possibleActions;
        }
        public Move GetNextMove()
        {
            Move bestAction = null;
            Move treeInShadow = FindShadowedTree();
            if (treeInShadow != null)
            {
                bestAction = treeInShadow;
            }
            else if (currentState.day >= maxTurns - 2)
            {
                bestAction = FindBestCompleteAction();
            }
            else
            {
                bestAction = FindBestGrowAction();
                if (bestAction == null)
                {
                    bestAction = FindBestSeedAction();
                }
            }
            Console.Error.WriteLine($"Move: {bestAction} : {possibleActions.Count}");
            if (bestAction == null)
            {
                return possibleActions.First(a => a.type == Actions.WAIT);
            }
            return bestAction;
        }
        private Move FindBestSeedAction()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.SEED).ToList();
            int treeCount = currentState.trees.Where(t => t.isMine).Count();
            int seedCount = currentState.trees.Where(t => t.isMine && t.size == 0).Count();
            if (seedCount <= 2 && treeCount <= 8)
            {
                int maxPoints = -1;
                Move bestSeedAction = null;
                foreach (Move move in actions)
                {
                    Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                    int points = cell.richness;
                    points += cell.IsCorner() ? 2 : 0;
                    if (maxPoints < points)
                    {
                        maxPoints = points;
                        bestSeedAction = move;
                    }
                }
                return bestSeedAction;
            }
            return null;
        }
        /// <summary>
        /// Find trees that are better to cut down then to keep standing
        /// </summary>
        /// <returns></returns>
        private Move FindShadowedTree()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.COMPLETE).ToList();
            int sunPowerWithTree = CalculateMySunPowerForGame(new GameState(currentState));
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                GameState afterComplete = new GameState(currentState);
                afterComplete.ApplyMove(move);
                int sunPower = CalculateMySunPowerForGame(afterComplete);
                if(sunPowerWithTree < (sunPower - 4))//Cost to cut down is 4 sun power
                {
                    return move;
                }
            }
            return null;
        }
        private int CalculateMySunPowerForGame(GameState state)
        {
            int sunPower = 0;
            int sunPowerTo0 = -1;
            for (int i = 0; i < sunReset; i++)
            {
                state.AdvanceDay();
                if (state.sunDirection == 0)
                {
                    sunPowerTo0 = sunPower;
                }
                sunPower += state.mySunPowerGenerationToday;
            }
            int cycles = (maxTurns - currentState.day) / sunReset;
            sunPower = sunPowerTo0 + cycles * sunPower;
            return sunPower;
        }
        //List of trees that are shadowed by the given level 3 tree and will provide power if the level 3 tree is cut down;
        private List<Tree> FindShadowedTrees(Cell cell, int direction)
        {
            List<Tree> shadowedTrees = new List<Tree>();
            Cell cell1 = currentState.board.FirstOrDefault(c => c.index == cell.neighbours[direction]);
            Cell cell2 = null;
            if (cell1 != null)
            {
                cell2 = currentState.board.FirstOrDefault(c => c.index == cell1.neighbours[direction]);
            }
            Cell cell3 = null;
            if (cell2 != null)
            {
                cell3 = currentState.board.FirstOrDefault(c => c.index == cell2.neighbours[direction]);
            }
            Tree tree1 = null;
            if (cell1 != null)
            {
                tree1 = cell1.tree;
            }
            Tree tree2 = null;
            if (cell2 != null)
            {
                tree2 = cell2.tree;
            }
            Tree tree3 = null;
            if (cell3 != null)
            {
                tree3 = cell3.tree;
            }
            if (tree1 != null)
            {
                shadowedTrees.Add(tree1);
            }
            if (tree2 != null && (tree1 == null || tree1.size < tree2.size))
            {
                shadowedTrees.Add(tree2);
            }
            if (tree3 != null && (tree1 == null || tree1.size < tree3.size) && (tree2 == null || tree2.size < tree3.size))
            {
                shadowedTrees.Add(tree3);
            }
            return shadowedTrees;
        }
        private Move FindBestGrowAction()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.GROW).ToList();
            int maxPoints = -9999;
            Move bestGrowAction = null;
            List<Tree> myTrees = currentState.trees.Where(t => t.isMine).ToList();
            Dictionary<int, int> treeSizeToCount = new Dictionary<int, int>();
            treeSizeToCount[1] = myTrees.Where(t => t.size == 1).Count();
            treeSizeToCount[2] = myTrees.Where(t => t.size == 2).Count();
            treeSizeToCount[3] = myTrees.Where(t => t.size == 3).Count();
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                int treeSizePoints = Math.Max(maxTurns - currentState.day - maxTreeSize + tree.size, 0);
                if (treeSizePoints == 0)
                {
                    continue;
                }
                int cost = treeSizeToCount[tree.size + 1];
                cost += (int)Math.Pow(2, tree.size + 1) - 1;
                /*
                GameState afterMove = new GameState(currentState);
                afterMove.ApplyMove(move);
                int sunPower = CalculateMySunPowerForGame(afterMove);
                */
                int powerUntil0 = -1;
                int power = 0;
                for (int i = currentState.shadowDirection; i < sunReset + currentState.shadowDirection; i++)
                {
                    int currentShadowDirection = i % sunReset;
                    if (currentShadowDirection == 0 && powerUntil0 == -1)
                    {
                        powerUntil0 = power;
                    }
                    if (!IsSpookyShadowed(currentState, cell.index, currentShadowDirection))
                    {
                        //Console.Error.WriteLine(cell);
                        power++;
                    }
                }
                power = (maxTurns / sunReset) * (power - powerUntil0) + powerUntil0;
                int sunPower = power;
                int points = sunPower - cost;
                if (maxPoints < points)
                {
                    maxPoints = points;
                    bestGrowAction = move;
                }
            }
            return bestGrowAction;
        }
        private bool IsSpookyShadowed(GameState state, int cellIndex, int currentShadowDirection)
        {
            Cell cell = state.board.First(c => c.index == cellIndex);
            Cell treeSize1 = state.board.FirstOrDefault(c => c.index == cell.neighbours[currentShadowDirection]);
            Cell treeSize2 = null;
            if (treeSize1 != null)
            {
                treeSize2 = state.board.FirstOrDefault(c => c.index == treeSize1.neighbours[currentShadowDirection]);
            }
            Cell treeSize3 = null;
            if (treeSize2 != null)
            {
                treeSize3 = state.board.FirstOrDefault(c => c.index == treeSize2.neighbours[currentShadowDirection]);
            }
            Tree tree1 = null;
            if (treeSize1 != null && (cell.tree == null || cell.tree.size <= 1))
            {
                tree1 = treeSize1.tree;
            }
            Tree tree2 = null;
            if (treeSize2 != null && (cell.tree == null || cell.tree.size <= 2))
            {
                tree2 = treeSize2.tree;
            }
            Tree tree3 = null;
            if (treeSize3 != null)
            {
                tree3 = treeSize3.tree;
            }
            if (((tree1 != null && tree1.size >= 1) || (tree2 != null && tree2.size >= 2) || (tree3 != null && tree3.size == 3)))
            {
                return true;
            }
            return false;
        }
        private Move FindBestCompleteAction()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.COMPLETE).ToList();
            int maxPoints = -1;
            Move bestAction = null;
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                if (maxPoints < cell.richness)
                {
                    maxPoints = cell.richness;
                    bestAction = move;
                }
            }
            return bestAction;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Utility
{
    public class GameState
    {
        public int day;
        public int nutrients;
        public int mySun, opponentSun;
        public int myScore, opponentScore;
        public bool opponentIsWaiting;
        public List<Cell> board;
        //Calculated from the trees on the board
        public List<Tree> trees;
        //Calcualted from the day
        public int sunDirection;
        public int shadowDirection;
        public int mySunPowerGenerationToday;
        public int opponentSunPowerGenerationToday;
        public GameState()
        {
            board = new List<Cell>();
        }
        public GameState(GameState state)
        {
            day = state.day;
            nutrients = state.nutrients;
            board = new List<Cell>(state.board.Select(c => new Cell(c)));
            mySun = state.mySun;
            opponentSun = state.opponentSun;
            myScore = state.myScore;
            opponentScore = state.opponentScore;
            opponentIsWaiting = state.opponentIsWaiting;
            BuildCellNeighbors();
            UpdateGameState();
        }
        public void UpdateGameState()
        {
            trees = new List<Tree>();
            //Resets cell data that is recalulated and builds tree list
            foreach(Cell cell in board)
            {
                cell.Reset();
                if (cell.HasTree())
                {
                    trees.Add(cell.tree);
                }
            }
            sunDirection = day % sunReset;
            shadowDirection = sunDirection + sunReset/2 % sunReset;
            Console.Error.WriteLine($"sundirection: {sunDirection} day: {day}");
            CalculateShadows();
            CalculateSunGeneration();
        }
        /// <summary>
        /// Calcualtes the shadows on each cell and spookiness of each tree
        /// </summary>
        private void CalculateShadows()
        {
            //Calculate the shadow size of each cell
            foreach (Cell cell in board)
            {
                if (cell.HasTree())
                {
                    Cell current = cell;
                    for (int i = 0; i < cell.tree.size; i++)
                    {
                        current = current.GetCellNeighbor(sunDirection);
                        if(current == null)
                        {
                            break;
                        }
                        current.SetShadowSize(cell.tree.size);
                    }
                }
            }
            //Calculate the spookiness of each tree
            foreach (Cell cell in board)
            {
                if (cell.HasTree())
                {
                    if (cell.tree.size <= cell.shadowSize)
                    {
                        cell.tree.isSpookyShadow = true;
                    }
                }
                //Console.Error.WriteLine(cell);
            }
        }
        public void BuildCellNeighbors()
        {
            foreach (Cell cell in board)
            {
                Dictionary<int, Cell> sunDirectionToCell = new Dictionary<int, Cell>();
                for (int i = 0; i < cell.neighbours.Count; i++)
                {
                    Cell c = board.FirstOrDefault(c => c.index == cell.neighbours[i]);
                    sunDirectionToCell[i] = c;
                }
                cell.SetCellNeighbors(sunDirectionToCell);
            }
        }
        private void CalculateSunGeneration()
        {
            mySunPowerGenerationToday = 0;
            opponentSunPowerGenerationToday = 0;
            foreach(Tree tree in trees)
            {
                if (!tree.isSpookyShadow)
                {
                    if (tree.isMine)
                    {
                        mySunPowerGenerationToday += tree.size;
                    }
                    else
                    {
                        opponentSunPowerGenerationToday += tree.size;
                    }
                }
            }
            Console.Error.WriteLine($"my sun gen: {mySunPowerGenerationToday}, opp sun gen: {opponentSunPowerGenerationToday}");
        }
        public void ApplyMove(Move move)
        {
            Cell targetCell = board.First(c => c.index == move.targetCellIdx);
            Cell sourceCell = board.First(c => c.index == move.sourceCellIdx);
            switch (move.type)
            {
                case Actions.COMPLETE:
                    mySun -= 4;
                    myScore += GetTreeCutScore(targetCell);
                    targetCell.RemoveTree();
                    nutrients--;
                    UpdateGameState();
                    break;
                case Actions.GROW:
                    mySun -= GetCostToGrow(targetCell);
                    targetCell.tree.Grow();
                    break;
                case Actions.SEED:
                    mySun -= GetCostToSeed();
                    targetCell.tree = new Tree(targetCell.index, 0, true, true);
                    UpdateGameState();
                    break;
                case Actions.WAIT:
                    //Should we advance day on wait if opponent is waiting?
                default:
                    break;
            }
        }
        public void AdvanceDay()
        {
            day++;
            UpdateGameState();
            //In theory we should also add sun power to mySun and opponentSun
        }
        public int GetCostToSeed()
        {
            return trees.Where(t => t.size == 0).Count();
        }
        public int GetTreeCutScore(Cell cell)
        {
            return nutrients + (cell.richness * 2 - 2);
        }
        public int GetCostToGrow(Cell cell)
        {
            return trees.Where(t => t.size == cell.tree.size + 1).Count() + (int)Math.Pow(2, cell.tree.size + 1) - 1;
        }
        public void ResetTrees()
        {
            foreach (Cell cell in board)
            {
                cell.RemoveTree();
            }
        }
    }
}
