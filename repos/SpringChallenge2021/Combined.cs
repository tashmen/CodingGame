/*
 * File generated by SourceCombiner.exe using 8 source files.
 * Created On: 5/12/2021 6:05:11 PM
*/
using GameSolution;
using GameSolution.Entities;
using GameSolution.Moves;
using GameSolution.Utility;
using static GameSolution.Constants;
using System;
using System.Collections.Generic;
using System.Linq;
//*** SourceCombiner -> original file Cell.cs ***
namespace GameSolution.Entities
{
    public class Cell
    {
        public int index;
        public int richness;
        public List<int> neighbours;
        public Tree tree;
        private Dictionary<int, Cell> sunDirectionToCellNeighbour;
        //Calculated value that must be reset!
        public int shadowSize { get; private set; }
        public Cell(int index, int richness, List<int> neighbours)
        {
            this.index = index;
            this.richness = richness;
            this.neighbours = neighbours;
            Reset();
        }
        public Cell(Cell cell)
        {
            index = cell.index;
            richness = cell.richness;
            neighbours = new List<int>(cell.neighbours);
            if (cell.HasTree())
            {
                tree = new Tree(cell.tree);
            }
            shadowSize = cell.shadowSize;
        }
        public int GetBonusScore()
        {
            return (int)Math.Pow(2, richness) - 2;
        }
        public void Reset()
        {
            shadowSize = -1;
        }
        public void SetShadowSize(int size)
        {
            shadowSize = Math.Max(shadowSize, size);
        }
        public void SetCellNeighbors(Dictionary<int, Cell> neighbours)
        {
            sunDirectionToCellNeighbour = neighbours;
        }
        /// <summary>
        /// Retrieves the cell neighbor or null if one doesn't exist
        /// </summary>
        /// <param name="sunDirection">the direction of the sun</param>
        /// <returns>The cell in the direction of the sun from this cell</returns>
        public Cell GetCellNeighbor(int sunDirection)
        {
            return sunDirectionToCellNeighbour[sunDirection];
        }
        public bool IsCorner()
        {
            return index == 19 || index == 22 || index == 25 || index == 28 || index == 31 || index == 34;
        }
        public void AddTree(Tree tree)
        {
            if (tree.cellIndex == index)
            {
                this.tree = tree;
            }
        }
        public void RemoveTree()
        {
            this.tree = null;
        }
        public bool HasTree()
        {
            return tree != null;
        }
        public override string ToString()
        {
            return $"i: {index} r: {richness} s:{shadowSize} ts: {tree?.size} spooky:{tree?.isSpookyShadow}";
        }
    }
}
//*** SourceCombiner -> original file SunPower.cs ***
namespace GameSolution.Entities
{
    public class SunPower
    {
        public int mySunPower;
        public int oppSunPower;
        public int GetDifference()
        {
            return mySunPower - oppSunPower;
        }
    }
}
//*** SourceCombiner -> original file Tree.cs ***
namespace GameSolution.Entities
{
    public class Tree
    {
        public int cellIndex;
        public int size;
        public bool isMine;
        public bool isDormant;
        //Calculated value
        public bool isSpookyShadow;
        public Tree(int cellIndex, int size, bool isMine, bool isDormant)
        {
            this.cellIndex = cellIndex;
            this.size = size;
            this.isMine = isMine;
            this.isDormant = isDormant;
            isSpookyShadow = false;
        }
        public Tree(Tree tree)
        {
            cellIndex = tree.cellIndex;
            size = tree.size;
            isMine = tree.isMine;
            isDormant = tree.isDormant;
            isSpookyShadow = tree.isSpookyShadow;
        }
        public void Grow()
        {
            isDormant = true;
            size += 1;
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Moves
{
    public class Move
    {
        public string type;
        public int targetCellIdx;
        public int sourceCellIdx;
        public Move(string type, int sourceCellIdx, int targetCellIdx)
        {
            this.type = type;
            this.targetCellIdx = targetCellIdx;
            this.sourceCellIdx = sourceCellIdx;
        }
        public Move(Move move)
        {
            type = move.type;
            targetCellIdx = move.targetCellIdx;
            sourceCellIdx = move.sourceCellIdx;
        }
        public Move(string type, int targetCellIdx)
            : this(type, 0, targetCellIdx)
        {
        }
        public Move(string type)
            : this(type, 0, 0)
        {
        }
        public override string ToString()
        {
            if (type == Actions.WAIT)
            {
                return Actions.WAIT;
            }
            if (type == Actions.SEED)
            {
                return string.Format("{0} {1} {2}", Actions.SEED, sourceCellIdx, targetCellIdx);
            }
            return string.Format("{0} {1}", type, targetCellIdx);
        }
        public static Move Parse(string action)
        {
            string[] parts = action.Split(' ');
            switch (parts[0])
            {
                case Actions.WAIT:
                    return new Move(Actions.WAIT);
                case Actions.SEED:
                    return new Move(Actions.SEED, int.Parse(parts[1]), int.Parse(parts[2]));
                case Actions.GROW:
                case Actions.COMPLETE:
                default:
                    return new Move(parts[0], int.Parse(parts[1]));
            }
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
public class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        GameState game = new GameState();
        int numberOfCells = int.Parse(Console.ReadLine()); // 37
        for (int i = 0; i < numberOfCells; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int index = int.Parse(inputs[0]); // 0 is the center cell, the next cells spiral outwards
            int richness = int.Parse(inputs[1]); // 0 if the cell is unusable, 1-3 for usable cells
            int neigh0 = int.Parse(inputs[2]); // the index of the neighbouring cell for each direction
            int neigh1 = int.Parse(inputs[3]);
            int neigh2 = int.Parse(inputs[4]);
            int neigh3 = int.Parse(inputs[5]);
            int neigh4 = int.Parse(inputs[6]);
            int neigh5 = int.Parse(inputs[7]);
            List<int> neighs = new List<int>(){ neigh0, neigh1, neigh2, neigh3, neigh4, neigh5 };
            Cell cell = new Cell(index, richness, neighs);
            game.board.Add(cell);
        }
        game.BuildCellNeighbors();
        // game loop
        while (true)
        {
            game.ResetTrees();
            game.day = int.Parse(Console.ReadLine()); // the game lasts 24 days: 0-23
            game.nutrients = int.Parse(Console.ReadLine()); // the base score you gain from the next COMPLETE action
            inputs = Console.ReadLine().Split(' ');
            game.mySun = int.Parse(inputs[0]); // your sun points
            game.myScore = int.Parse(inputs[1]); // your current score
            inputs = Console.ReadLine().Split(' ');
            game.opponentSun = int.Parse(inputs[0]); // opponent's sun points
            game.opponentScore = int.Parse(inputs[1]); // opponent's score
            game.opponentIsWaiting = inputs[2] != "0"; // whether your opponent is asleep until the next day
            int numberOfTrees = int.Parse(Console.ReadLine()); // the current amount of trees
            for (int i = 0; i < numberOfTrees; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int cellIndex = int.Parse(inputs[0]); // location of this tree
                int size = int.Parse(inputs[1]); // size of this tree: 0-3
                bool isMine = inputs[2] != "0"; // 1 if this is your tree
                bool isDormant = inputs[3] != "0"; // 1 if this tree is dormant
                Tree tree = new Tree(cellIndex, size, isMine, isDormant);
                Cell cell = game.board.First(c => c.index == tree.cellIndex);
                cell.AddTree(tree);
            }
            List<Move> possibleActions = new List<Move>();
            int numberOfPossibleMoves = int.Parse(Console.ReadLine());
            for (int i = 0; i < numberOfPossibleMoves; i++)
            {
                string possibleMove = Console.ReadLine();
                possibleActions.Add(Move.Parse(possibleMove));
            }
            game.UpdateGameState();
            GameHelper gameHelper = new GameHelper(game, possibleActions);
            Move move = gameHelper.GetNextMove();
            Console.WriteLine(move);
        }
    }
    private static List<T> List<T>()
    {
        throw new NotImplementedException();
    }
}
//*** SourceCombiner -> original file Constants.cs ***
namespace GameSolution
{
    public static class Constants
    {
        public const int maxTurns = 24;
        public const int maxTreeSize = 3;
        public const int sunReset = 6;
        public static class Actions
        {
            public const string WAIT = "WAIT";
            public const string SEED = "SEED";
            public const string GROW = "GROW";
            public const string COMPLETE = "COMPLETE";
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Utility
{
    class GameHelper
    {
        private GameState currentState;
        private List<Move> possibleActions;
        public GameHelper(GameState state, List<Move> possibleActions)
        {
            currentState = state;
            this.possibleActions = possibleActions;
        }
        public Move GetNextMove()
        {
            Move bestAction = null;
            Move treeInShadow = FindShadowedTree();
            if (treeInShadow != null)
            {
                bestAction = treeInShadow;
            }
            else if (currentState.day >= maxTurns - 2)
            {
                bestAction = FindBestFinalTurnsCompleteAction();
            }
            if(bestAction == null)
            {
                bestAction = FindBestGrowAction(currentState);
                if (bestAction == null)
                {
                    bestAction = FindBestSeedAction();
                }
            }
            Console.Error.WriteLine($"Move: {bestAction} : {possibleActions.Count}");
            if (bestAction == null)
            {
                return possibleActions.First(a => a.type == Actions.WAIT);
            }
            return bestAction;
        }
        private Move FindBestSeedAction()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.SEED).ToList();
            int treeCount = currentState.trees.Where(t => t.isMine).Count();
            int seedCount = currentState.trees.Where(t => t.isMine && t.size == 0).Count();
            GameState state = new GameState(currentState);
            SunPower totalSunPower = CalculateSunPowerForGame(state);
            state = new GameState(currentState);
            int costToUpgrade = GetCostToUpgradeTrees(state);
            if (seedCount <= 0 && maxTurns - currentState.day > 4 && totalSunPower.mySunPower > costToUpgrade)
            {
                int maxPoints = -9999;
                Move bestSeedAction = null;
                foreach (Move move in actions)
                {
                    Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                    GameState afterMove = new GameState(currentState);
                    afterMove.ApplyMove(move);
                    afterMove.AdvanceDay();
                    afterMove.ApplyMove(new Move(Actions.GROW, cell.index));
                    SunPower sunPower = CalculateSunPowerForGame(afterMove);
                    int points = cell.richness;
                    points += sunPower.GetDifference();
                    points -= currentState.GetCostToSeed();
                    if (maxPoints < points)
                    {
                        maxPoints = points;
                        bestSeedAction = move;
                    }
                }
                return bestSeedAction;
            }
            return null;
        }
        /// <summary>
        /// Determines cost in sunpower to upgrade every tree in the most efficient way possible
        /// </summary>
        /// <param name="state">The state of the game.  Note the state will be mutated to perform the calculation</param>
        /// <returns>The minimum upgrade cost</returns>
        private int GetCostToUpgradeTrees(GameState state)
        {
            int totalCost = 0;
            foreach(Cell cell in state.board)
            {
                if(cell.HasTree() && cell.tree.isMine && cell.tree.size == 2)
                {
                    while (cell.tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(cell);
                        cell.tree.Grow();
                    }
                }
            }
            foreach (Cell cell in state.board)
            {
                if (cell.HasTree() && cell.tree.isMine && cell.tree.size == 1)
                {
                    while (cell.tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(cell);
                        cell.tree.Grow();
                    }
                }
            }
            foreach (Cell cell in state.board)
            {
                if (cell.HasTree() && cell.tree.isMine && cell.tree.size == 0)
                {
                    while (cell.tree.size < maxTreeSize)
                    {
                        totalCost += state.GetCostToGrow(cell);
                        cell.tree.Grow();
                    }
                }
            }
            return totalCost;
        }
        /// <summary>
        /// Find trees that are better to cut down then to keep standing
        /// </summary>
        /// <returns></returns>
        private Move FindShadowedTree()
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.COMPLETE).ToList();
            SunPower sunPowerWithTree = CalculateSunPowerForGame(new GameState(currentState));
            int countLevel3Tree = currentState.trees.Where(t => t.size == maxTreeSize).Count();
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                GameState afterComplete = new GameState(currentState);
                afterComplete.ApplyMove(move);
                SunPower sunPower = CalculateSunPowerForGame(afterComplete);
                if(sunPowerWithTree.GetDifference() - countLevel3Tree <= (sunPower.GetDifference() - 4))//Cost to cut down is 4 sun power
                {
                    return move;
                }
            }
            return null;
        }
        private SunPower CalculateSunPowerForGame(GameState state)
        {
            SunPower power = new SunPower();
            SunPower powerTo0 = new SunPower();
            for (int i = 0; i < sunReset; i++)
            {
                state.AdvanceDay();
                if (state.sunDirection == 0)
                {
                    powerTo0.mySunPower = power.mySunPower;
                    powerTo0.oppSunPower = power.oppSunPower;
                }
                if (state.day >= maxTurns)
                {
                    break;
                }
                power.mySunPower += state.mySunPowerGenerationToday;
                power.oppSunPower += state.opponentSunPowerGenerationToday;
            }
            int cycles = (maxTurns - currentState.day) / sunReset;
            power.mySunPower = powerTo0.mySunPower + cycles * power.mySunPower;
            power.oppSunPower = powerTo0.oppSunPower + cycles * power.oppSunPower;
            return power;
        }
        private Move FindBestGrowAction(GameState state)
        {
            List<Move> actions = possibleActions.Where(a => a.type == Actions.GROW).ToList();
            int maxPoints = -9999;
            Move bestGrowAction = null;
            List<Tree> myTrees = state.trees.Where(t => t.isMine).ToList();
            Dictionary<int, int> treeSizeToCount = new Dictionary<int, int>();
            treeSizeToCount[1] = myTrees.Where(t => t.size == 1).Count();
            treeSizeToCount[2] = myTrees.Where(t => t.size == 2).Count();
            treeSizeToCount[3] = myTrees.Where(t => t.size == 3).Count();
            foreach (Move move in actions)
            {
                Tree tree = state.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = state.board.First(c => c.index == move.targetCellIdx);
                int treeSizePoints = Math.Max(maxTurns - state.day - maxTreeSize + tree.size, 0);
                Console.Error.WriteLine($"treesizepoints: {treeSizePoints}");
                if (treeSizePoints == 0)
                {
                    continue;
                }
                int cost = state.GetCostToGrow(cell);
                GameState afterMove = new GameState(state);
                afterMove.ApplyMove(move);
                SunPower sunPower = CalculateSunPowerForGame(afterMove);
                int points = sunPower.GetDifference();
                points -= cost;
                points += cell.richness;
                if (maxPoints < points)
                {
                    maxPoints = points;
                    bestGrowAction = move;
                }
            }
            return bestGrowAction;
        }
        private Move FindBestFinalTurnsCompleteAction()
        {
            if (maxTurns - currentState.day == 2)
            {
                GameState state = new GameState(currentState);
                Move growMove = FindBestGrowAction(currentState);
                if (growMove != null)
                {
                    Cell growCell = currentState.board.First(c => c.index == growMove.targetCellIdx);
                    if (growCell.tree.size == 2)
                    {
                        state.ApplyMove(growMove);
                        state.AdvanceDay();
                        int power = state.mySunPowerGenerationToday + currentState.mySun - currentState.GetCostToGrow(growCell);
                        int level3TreeCountOnHighRichness = state.board.Where(c => c.HasTree() && c.tree.size == 3 && (c.richness > 1 || state.nutrients > 3)).Count();
                        Console.Error.WriteLine($"lastTurnPower: {power} treeCount: {level3TreeCountOnHighRichness}");
                        if (power >= (level3TreeCountOnHighRichness) * 4)
                        {
                            return null;
                        }
                    }
                }
            }
            List<Move> actions = possibleActions.Where(a => a.type == Actions.COMPLETE).ToList();
            int maxPoints = 0;
            Move bestAction = null;
            foreach (Move move in actions)
            {
                Tree tree = currentState.trees.First(t => t.cellIndex == move.targetCellIdx);
                Cell cell = currentState.board.First(c => c.index == move.targetCellIdx);
                int points = currentState.GetTreeCutScore(cell);
                points -= 1;//you lose one point (4 sunpower) to chop a tree
                if (maxPoints < points)
                {
                    maxPoints = cell.richness;
                    bestAction = move;
                }
            }
            return bestAction;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Utility
{
    public class GameState
    {
        public int day;
        public int nutrients;
        public int mySun, opponentSun;
        public int myScore, opponentScore;
        public bool opponentIsWaiting;
        public List<Cell> board;
        //Calculated from the trees on the board
        public List<Tree> trees;
        //Calcualted from the day
        public int sunDirection;
        public int shadowDirection;
        public int mySunPowerGenerationToday;
        public int opponentSunPowerGenerationToday;
        public GameState()
        {
            board = new List<Cell>();
        }
        public GameState(GameState state)
        {
            day = state.day;
            nutrients = state.nutrients;
            board = new List<Cell>(state.board.Select(c => new Cell(c)));
            mySun = state.mySun;
            opponentSun = state.opponentSun;
            myScore = state.myScore;
            opponentScore = state.opponentScore;
            opponentIsWaiting = state.opponentIsWaiting;
            BuildCellNeighbors();
            UpdateGameState();
        }
        public void UpdateGameState()
        {
            trees = new List<Tree>();
            //Resets cell data that is recalulated and builds tree list
            foreach(Cell cell in board)
            {
                cell.Reset();
                if (cell.HasTree())
                {
                    trees.Add(cell.tree);
                }
            }
            sunDirection = day % sunReset;
            shadowDirection = sunDirection + sunReset/2 % sunReset;
            Console.Error.WriteLine($"sundirection: {sunDirection} day: {day}");
            CalculateShadows();
            CalculateSunGeneration();
        }
        /// <summary>
        /// Calcualtes the shadows on each cell and spookiness of each tree
        /// </summary>
        private void CalculateShadows()
        {
            //Calculate the shadow size of each cell
            foreach (Cell cell in board)
            {
                if (cell.HasTree())
                {
                    Cell current = cell;
                    for (int i = 0; i < cell.tree.size; i++)
                    {
                        current = current.GetCellNeighbor(sunDirection);
                        if(current == null)
                        {
                            break;
                        }
                        current.SetShadowSize(cell.tree.size);
                    }
                }
            }
            //Calculate the spookiness of each tree
            foreach (Cell cell in board)
            {
                if (cell.HasTree())
                {
                    if (cell.tree.size <= cell.shadowSize)
                    {
                        cell.tree.isSpookyShadow = true;
                    }
                }
                //Console.Error.WriteLine(cell);
            }
        }
        public void BuildCellNeighbors()
        {
            foreach (Cell cell in board)
            {
                Dictionary<int, Cell> sunDirectionToCell = new Dictionary<int, Cell>();
                for (int i = 0; i < cell.neighbours.Count; i++)
                {
                    Cell c = board.FirstOrDefault(c => c.index == cell.neighbours[i]);
                    sunDirectionToCell[i] = c;
                }
                cell.SetCellNeighbors(sunDirectionToCell);
            }
        }
        private void CalculateSunGeneration()
        {
            mySunPowerGenerationToday = 0;
            opponentSunPowerGenerationToday = 0;
            foreach(Tree tree in trees)
            {
                if (!tree.isSpookyShadow)
                {
                    if (tree.isMine)
                    {
                        mySunPowerGenerationToday += tree.size;
                    }
                    else
                    {
                        opponentSunPowerGenerationToday += tree.size;
                    }
                }
            }
            Console.Error.WriteLine($"my sun gen: {mySunPowerGenerationToday}, opp sun gen: {opponentSunPowerGenerationToday}");
        }
        public void ApplyMove(Move move)
        {
            Cell targetCell = board.First(c => c.index == move.targetCellIdx);
            Cell sourceCell = board.First(c => c.index == move.sourceCellIdx);
            switch (move.type)
            {
                case Actions.COMPLETE:
                    mySun -= 4;
                    myScore += GetTreeCutScore(targetCell);
                    targetCell.RemoveTree();
                    nutrients--;
                    UpdateGameState();
                    break;
                case Actions.GROW:
                    mySun -= GetCostToGrow(targetCell);
                    targetCell.tree.Grow();
                    break;
                case Actions.SEED:
                    mySun -= GetCostToSeed();
                    targetCell.tree = new Tree(targetCell.index, 0, true, true);
                    UpdateGameState();
                    break;
                case Actions.WAIT:
                    //Should we advance day on wait if opponent is waiting?
                default:
                    break;
            }
        }
        public void AdvanceDay()
        {
            day++;
            UpdateGameState();
            //In theory we should also add sun power to mySun and opponentSun
        }
        public int GetCostToSeed()
        {
            return trees.Where(t => t.size == 0).Count();
        }
        public int GetTreeCutScore(Cell cell)
        {
            return nutrients + (cell.richness * 2 - 2);
        }
        public int GetCostToGrow(Cell cell)
        {
            return trees.Where(t => t.size == cell.tree.size + 1).Count() + (int)Math.Pow(2, cell.tree.size + 1) - 1;
        }
        public void ResetTrees()
        {
            foreach (Cell cell in board)
            {
                cell.RemoveTree();
            }
        }
    }
}
