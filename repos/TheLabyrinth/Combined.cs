/*
 * File generated by SourceCombiner.exe using 3 source files.
 * Created On: 8/7/2021 8:45:27 PM
*/
using Algorithms.Graph;
using GameSolution;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 2 source files.
 * Created On: 8/7/2021 8:45:10 PM
*/
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        private Dictionary<int, List<Node>> Links { get; set; }
        private Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        public GraphLinks()
        {
            Links = new Dictionary<int, List<Node>>();
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, int distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            AddLinkInternal(id1, id2, distance);
            AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            int currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                int minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        int distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public int GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public int GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        //Adds links to the node links
        public void AddLinkInternal(int startNode, int endNode, int distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace Algorithms.Graph
{
    public class Node
    {
        public int Id { get; set; }
        public int Distance { get; set; }
        public bool IsExplored { get; set; }
        public Node(int id, int distance)
        {
            Id = id;
            Distance = distance;
        }
        /// <summary>
        /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
        /// </summary>
        /// <param name="currentDist">The current distance from the starting node</param>
        /// <returns>A clone of the node with the proper distance</returns>
        public Node CreateAtDistance(int currentDist)
        {
            return new Node(Id, currentDist + Distance);
        }
    }
}
//*** SourceCombiner -> original file Map2d.cs ***
namespace GameSolution
{
    public enum Location
    {
        unknown = 0,
        wall,
        open,
        startPosition,
        controlRoom
    }
    public class Map2d
    {
        List<List<Location>> _map;
        string[] _strMap;
        bool _controlRoomFound = false;
        Tuple<int, int> _controlRoom;
        Tuple<int, int> _startLocation;
        public Map2d(string[] map, Tuple<int, int> currentLocation)
        {
            _strMap = map;
            _map = new List<List<Location>>();
            int y = 0;
            foreach(string row in map)
            {
                int x = 0;
                List<Location> rows = new List<Location>();
                foreach(char c in row)
                {
                    switch (c)
                    {
                        case '#':
                            rows.Add(Location.wall);
                            break;
                        case '?':
                            rows.Add(Location.unknown);
                            break;
                        case '.':
                            rows.Add(Location.open);
                            break;
                        case 'T':
                            rows.Add(Location.startPosition);
                            _startLocation = new Tuple<int, int>(x, y);
                            break;
                        case 'C':
                            rows.Add(Location.controlRoom);
                            _controlRoomFound = true;
                            _controlRoom = new Tuple<int, int>(x, y);
                            break;
                    }
                    if (x == currentLocation.Item1 && y == currentLocation.Item2)
                    {
                        var array = _strMap[y].ToCharArray();
                        array[x] = 'X';
                        _strMap[y] = new string(array);
                    }
                    x++;
                }
                _map.Add(rows);
                y++;
            }
        }
        public Tuple<int, int> GetStartLocation()
        {
            return _startLocation;
        }
        public Tuple<int, int> GetControlRoomLocation()
        {
            return _controlRoom;
        }
        public bool isControlRoomFound()
        {
            return _controlRoomFound;
        }
        public bool isPassable(Location location)
        {
            return location != Location.wall;
        }
        public Location GetLocation(int x, int y)
        {
            if (y > _map.Count || x > _map[y].Count || y<0 || x<0)
                return Location.wall;
            return _map[y][x];
        }
        public void Print()
        {
            foreach(string str in _strMap)
            {
                Console.Error.WriteLine(str);
            }
            /*
            foreach(List<Location> locations in _map)
            {
                foreach(Location location in locations)
                {
                    Console.Error.Write((int)location);
                }
                Console.Error.WriteLine();
            }
            */
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int R = int.Parse(inputs[0]); // number of rows.
        int C = int.Parse(inputs[1]); // number of columns.
        int A = int.Parse(inputs[2]); // number of rounds between the time the alarm countdown is activated and the time the alarm goes off.
        // game loop
        while (true)
        {
            inputs = Console.ReadLine().Split(' ');
            int KR = int.Parse(inputs[0]); // row where Kirk is located.
            int KC = int.Parse(inputs[1]); // column where Kirk is located.
            string[] strMap = new string[R];
            for (int i = 0; i<R; i++)
            {
                strMap[i] = Console.ReadLine(); // C of the characters in '#.TC?' (i.e. one line of the ASCII maze).
            }
            Map2d map = new Map2d(strMap, new Tuple<int, int>(KC, KR));
            map.Print();
            GraphLinks links = new GraphLinks();
            int kirkLocationId = GenerateId(KC, KR);
            Stopwatch watch = new Stopwatch();
            AddLinks(map, links, KC, KR, kirkLocationId);
            watch.Start();
            links.CalculateShortestPathsFromStartNode(kirkLocationId, 999999);
            watch.Stop();
            Console.Error.WriteLine(watch.ElapsedMilliseconds);
            int nextDirection = 0;
            if (map.isControlRoomFound())
            {
                Tuple<int, int> controlRoomLocation = map.GetControlRoomLocation();
                Tuple<int, int> startLocation = map.GetStartLocation();
                if (controlRoomLocation.Item1 == KC && controlRoomLocation.Item2 == KR)
                {
                    strategy = "escape";
                }
                if(strategy == "explore")
                {
                    try
                    {
                        nextDirection = links.GetShortestPath(kirkLocationId, GenerateId(controlRoomLocation.Item1, controlRoomLocation.Item2));
                    }
                    catch(Exception ex)
                    {
                        //do nothing; need to keep exploring
                    }
                }
                else
                {
                    nextDirection = links.GetShortestPath(kirkLocationId, GenerateId(startLocation.Item1, startLocation.Item2));
                }
            }
            if(nextDirection == 0)
            {
                Dictionary<int, List<Node>> endPoints = links.GetPaths(kirkLocationId);
                int minDist = 999999;
                foreach(int endLocation in endPoints.Keys)
                {
                    var paths = endPoints[endLocation];
                    var point = GetPointFromId(endLocation);
                    var location = map.GetLocation(point.Item1, point.Item2);
                    if(location == Location.unknown)
                    {
                        var dist = links.GetShortestPathDistance(kirkLocationId, endLocation);
                        if (minDist > dist)
                        {
                            minDist = dist;
                            nextDirection = links.GetShortestPath(kirkLocationId, endLocation);
                        }
                    }
                }
            }
            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            Console.Error.WriteLine(nextDirection);
            Console.WriteLine(GetDirectionForLocation(kirkLocationId, nextDirection)); // Kirk's next move (UP DOWN LEFT or RIGHT).
        }
    }
    static string strategy = "explore";
    public static string GetDirectionForLocation(int kirkLocationId, int nextDirectionId)
    {
        var kirkLocation = GetPointFromId(kirkLocationId);
        var nextLocation = GetPointFromId(nextDirectionId);
        if(kirkLocation.Item1 + 1 == nextLocation.Item1)
        {
            return "RIGHT";
        }
        else if (kirkLocation.Item1 - 1 == nextLocation.Item1)
        {
            return "LEFT";
        }
        else if (kirkLocation.Item2 - 1 == nextLocation.Item2)
        {
            return "UP";
        }
        else if (kirkLocation.Item2 + 1 == nextLocation.Item2)
        {
            return "DOWN";
        }
        return null;
    }
    public static void AddLinks(Map2d map, GraphLinks links, int startX, int startY, int startId)
    {
        if (map.GetLocation(startX, startY) == Location.unknown)
        {
            return;
        }
        int dx = startX;
        int dy = startY - 1;
        int id = GenerateId(dx, dy);
        Location up = map.GetLocation(dx, dy);
        if (map.isPassable(up) && !links.ContainsLink(startId, id))
        {
            links.AddLink(startId, id, 1);
            AddLinks(map, links, dx, dy, id);
        }
        dx = startX;
        dy = startY + 1;
        id = GenerateId(dx, dy);
        Location down = map.GetLocation(dx, dy);
        if (map.isPassable(down) && !links.ContainsLink(startId, id))
        {
            links.AddLink(startId, id, 1);
            AddLinks(map, links, dx, dy, id);
        }
        dx = startX - 1;
        dy = startY;
        id = GenerateId(dx, dy);
        Location left = map.GetLocation(dx, dy);
        if (map.isPassable(left) && !links.ContainsLink(startId, id))
        {
            links.AddLink(startId, id, 1);
            AddLinks(map, links, dx, dy, id);
        }
        dx = startX + 1;
        dy = startY;
        id = GenerateId(dx, dy);
        Location right = map.GetLocation(dx, dy);
        if (map.isPassable(right) && !links.ContainsLink(startId, id))
        {
            links.AddLink(startId, id, 1);
            AddLinks(map, links, dx, dy, id);
        }
    }
    public static int GenerateId(int x, int y)
    {
        return x * 10000 + y;
    }
    public static Tuple<int, int> GetPointFromId(int id)
    {
        return new Tuple<int, int>(id / 10000, id % 10000);
    }
}
