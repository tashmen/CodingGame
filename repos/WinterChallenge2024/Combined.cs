/*
 * File generated by SourceCombiner.exe using 9 source files.
 * Created On: 12/28/2024 11:05:01 AM
*/
using Algorithms.GameComponent;
using Algorithms.Graph;
using Algorithms.Trees;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Text;
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
static void Main(string[] args)
{
MonteCarloTreeSearch search = new MonteCarloTreeSearch();
GameState gameState = new GameState();
string[] inputs;
inputs = Console.ReadLine().Split(' ');
int width = int.Parse(inputs[0]); // columns in the game grid
int height = int.Parse(inputs[1]); // rows in the game grid
Stopwatch watch = new Stopwatch();
watch.Start();
Board board = new Board(width, height);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
// game loop
while (true)
{
int entityCount = int.Parse(Console.ReadLine());
List<Entity> entities = new List<Entity>();
for (int i = 0; i < entityCount; i++)
{
inputs = Console.ReadLine().Split(' ');
int x = int.Parse(inputs[0]);
int y = int.Parse(inputs[1]);
string type = inputs[2];
int owner = int.Parse(inputs[3]);
int organId = int.Parse(inputs[4]);
string organDir = inputs[5];
int organParentId = int.Parse(inputs[6]);
int organRootId = int.Parse(inputs[7]);
Entity entity = new Entity(x, y, board.GetNodeIndex(x, y), type, owner, organId, organDir, organParentId, organRootId);
entities.Add(entity);
}
inputs = Console.ReadLine().Split(' ');
int myA = int.Parse(inputs[0]);
int myB = int.Parse(inputs[1]);
int myC = int.Parse(inputs[2]);
int myD = int.Parse(inputs[3]);
inputs = Console.ReadLine().Split(' ');
int oppA = int.Parse(inputs[0]);
int oppB = int.Parse(inputs[1]);
int oppC = int.Parse(inputs[2]);
int oppD = int.Parse(inputs[3]);
int requiredActionsCount = int.Parse(Console.ReadLine());
int[] myProtein = new int[] { myA, myB, myC, myD };
int[] oppProtein = new int[] { oppA, oppB, oppC, oppD };
watch.Start();
board.SetEntities(entities);
gameState.SetNextTurn(board, myProtein, oppProtein);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
search.SetState(gameState, true, false);
Move move = (Move)search.GetNextMove(watch, gameState.Turn > 1 ? 45 : 990, 20, 1);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
if (watch.ElapsedMilliseconds < 48)
{
board.Print();
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
}
watch.Stop();
watch.Reset();
move.Print();
}
}
}
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 12/27/2024 3:58:05 PM
*/
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms.GameComponent
{
public interface IGameState
{
/// <summary>
/// Retrieve the possible moves
/// </summary>
/// <param name="isMax">Whether or not to retrieve moves for max</param>
/// <returns>list of all possible moves</returns>
IList GetPossibleMoves(bool isMax);
/// <summary>
/// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
/// </summary>
/// <param name="isMax">Whether or not the move is for max</param>
/// <param name="move">the move to apply</param>
void ApplyMove(object move, bool isMax);
/// <summary>
/// Retrieves the move that was played to reach this state.
/// </summary>
/// <param name="isMax">Whether or not the move is for max</param>
/// <returns>The move</returns>
object GetMove(bool isMax);
/// <summary>
/// Clones the game state
/// </summary>
/// <returns>The copy of the state</returns>
IGameState Clone();
/// <summary>
/// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
/// </summary>
/// <returns>Who won the game</returns>
double? GetWinner();
/// <summary>
/// Determines if the game state is the same as this one
/// </summary>
/// <param name="">the state to compare against</param>
/// <returns>true if equal</returns>
bool Equals(IGameState state);
/// <summary>
/// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
/// </summary>
/// <param name="isMax">true if it is max's turn else false</param>
/// <returns>A number between [-1, 1]</returns>
double Evaluate(bool isMax);
}
}
//*** SourceCombiner -> original file Graph.cs ***
namespace Algorithms.Graph
{
public class Graph
{
private Dictionary<int, INode> Nodes;
//Will hold shortest paths from a start node id to an end node id
private Dictionary<int, Dictionary<int, Tuple<double, List<ILink>>>> Paths;
public Graph()
{
Nodes = new Dictionary<int, INode>();
}
public void AddNode(INode node)
{
Nodes[node.Id] = node;
}
/// <summary>
/// Calculates all of the shortest paths in the node links
/// </summary>
public void CalculateShortestPaths()
{
Paths = new Dictionary<int, Dictionary<int, Tuple<double, List<ILink>>>>();
foreach (INode vertex in Nodes.Values)
{
InternalBuildShortestPathsFromStartNode2(vertex);
}
}
public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
{
Paths = new Dictionary<int, Dictionary<int, Tuple<double, List<ILink>>>>();
InternalBuildShortestPathsFromStartNode2(startNode, maxDistance);
}
//With a little help from Chat GPT improved the performance significantly.
private void InternalBuildShortestPathsFromStartNode2(INode startNode, double maxDistance = double.MaxValue)
{
// Initialize exploration state and paths
foreach (INode node in Nodes.Values)
{
node.IsExplored = false;
}
var minimumSpanningTree = new HashSet<ILink>();
var priorityQueue = new SortedSet<(double Distance, int StepCount, ILink Link)>(Comparer<(double Distance, int StepCount, ILink Link)>.Create((a, b) =>
{
// Compare first by distance, then by step count (in case of tie)
int result = a.Distance.CompareTo(b.Distance);
if (result != 0) return result;
result = a.StepCount.CompareTo(b.StepCount);
if (result != 0) return result;
return a.Link.EndNodeId.CompareTo(b.Link.EndNodeId);
}));
Paths[startNode.Id] = new Dictionary<int, Tuple<double, List<ILink>>>();
Paths[startNode.Id][startNode.Id] = Tuple.Create(0.0, new List<ILink>());
startNode.IsExplored = true;
// Add initial links of the startNode to the priority queue
foreach (var link in startNode.GetLinks())
{
priorityQueue.Add((link.Distance, 1, link));  // Distance, StepCount (1), Link
}
while (minimumSpanningTree.Count < Nodes.Count && priorityQueue.Count > 0)
{
// Get the link with the minimum distance and fewest steps
var (currentDist, stepCount, bestLink) = priorityQueue.Min;
priorityQueue.Remove(priorityQueue.Min);
var currentNode = Nodes[bestLink.StartNodeId];
var adjacentNode = Nodes[bestLink.EndNodeId];
if (adjacentNode.IsExplored)
{
continue; // Skip already explored nodes
}
adjacentNode.IsExplored = true;
minimumSpanningTree.Add(bestLink);
// Update paths
if (!Paths[startNode.Id].TryGetValue(currentNode.Id, out var currentPath))
{
currentPath = Tuple.Create(0.0, new List<ILink>());
}
else
{
currentPath = Tuple.Create(currentDist, new List<ILink>(currentPath.Item2)); // Copy the existing path
}
// Add the new link to the current path
currentPath.Item2.Add(bestLink);
// Store the complete path from the start node to the adjacent node
Paths[startNode.Id][bestLink.EndNodeId] = currentPath;
// Exit if the distance exceeds the maximum allowed
if (currentDist >= maxDistance)
return;
// Add adjacent links of the newly explored node to the queue
foreach (ILink adjacentLink in adjacentNode.GetLinks())
{
var nextNode = Nodes[adjacentLink.EndNodeId];
if (!nextNode.IsExplored)
{
// Calculate the new distance and step count for the adjacent link
double newDist = currentDist + adjacentLink.Distance;
int newStepCount = stepCount + 1;
priorityQueue.Add((newDist, newStepCount, adjacentLink));
}
}
}
}
/*
private void InternalBuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
{
foreach (INode node in Nodes.Values)
{
node.IsExplored = false;
}
List<ILink> minimumSpanningTree = new List<ILink>();
Paths[startNode.Id] = new Dictionary<int, Tuple<double, List<ILink>>>();
Paths[startNode.Id][startNode.Id] = Tuple.Create(0.0, new List<ILink>());
minimumSpanningTree.Add(new Link(startNode.Id, startNode.Id, 0));
startNode.IsExplored = true;
int vertexCount = Nodes.Count;
double currentDist;
while (minimumSpanningTree.Count < vertexCount)
{
double minDist = 99999;
ILink bestLink = null;
ILink parentLink = null;
foreach (ILink currentLink in minimumSpanningTree)
{
INode currentNode = Nodes[currentLink.EndNodeId];
currentDist = currentLink.GetDistance(Paths[startNode.Id][currentNode.Id]);
foreach (ILink adjacent in currentNode.GetLinks())
{
INode adjacentNode = Nodes[adjacent.EndNodeId];
if (adjacentNode.IsExplored)
{
continue;//skip nodes already in minimum spanning tree
}
double distance = currentDist + adjacent.Distance;
if (distance < minDist)
{
minDist = distance;
bestLink = adjacent;
parentLink = currentLink;
}
else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
{
Paths[startNode.Id].TryGetValue(currentNode.Id, out List<ILink> pathCurrent);
int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
Paths[startNode.Id].TryGetValue(parentLink.EndNodeId, out List<ILink> pathPrevious);
int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
if (lengthCurrent < lengthPrevious)
{
minDist = distance;
bestLink = adjacent;
parentLink = currentLink;
}
}
}
}
if (parentLink == null)
{
return;//no possible paths
}
minimumSpanningTree.Add(bestLink);
Nodes[bestLink.EndNodeId].IsExplored = true;
List<ILink> currentPath = null;
if (!parentLink.EndNodeId.Equals(startNode.Id))
{
Paths[startNode.Id].TryGetValue(parentLink.EndNodeId, out currentPath);
}
if (currentPath == null)
{
currentPath = new List<ILink>();
}
else
{
currentPath = new List<ILink>(currentPath);
}
Paths[startNode.Id].Add(bestLink.EndNodeId, currentPath);
currentPath.Add(bestLink);
if (minDist >= maxDistance)
return;
}
}
*/
/// <summary>
/// Retrieves the next node along the path from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The next node in the path</returns>
public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
{
Paths.TryGetValue(startNode.Id, out Dictionary<int, Tuple<double, List<ILink>>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startNode.Id);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endNode.Id, out Tuple<double, List<ILink>> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
throw new InvalidOperationException();
}
INode shortest = Nodes[paths.Item2.First().EndNodeId];
Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
return shortest;
}
/// <summary>
/// Retrieves all nodes along the shortest path between two points
/// </summary>
/// <param name="startNodeId">Start node id</param>
/// <param name="endNodeId">End node id</param>
/// <returns>The full path from start to end</returns>
/// <exception cref="InvalidOperationException"></exception>
public IList<ILink> GetShortestPathAll(int startNodeId, int endNodeId)
{
Paths.TryGetValue(startNodeId, out Dictionary<int, Tuple<double, List<ILink>>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startNodeId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endNodeId, out Tuple<double, List<ILink>> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endNodeId + " start: " + startNodeId);
throw new InvalidOperationException();
}
return paths.Item2;
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node</param>
/// <param name="endId">The ending node</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(INode startNode, INode endNode)
{
return GetShortestPathDistance(startNode.Id, endNode.Id);
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, Tuple<double, List<ILink>>> endPoints);
if (endPoints == null)
{
return double.MaxValue;
}
endPoints.TryGetValue(endId, out Tuple<double, List<ILink>> paths);
if (paths == null)
{
return double.MaxValue;
}
return paths.Item1;
}
/// <summary>
/// Retrieves the straight line distance from start to end
/// </summary>
/// <param name="startId">The starting node</param>
/// <param name="endId">The ending node</param>
/// <returns>The distance from start to end</returns>
public double GetDistance(Node startNode, Node endNode)
{
return startNode.GetLinks().Where(l => l.EndNodeId.Equals(endNode.Id)).First().Distance;
}
}
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
public class GraphLinks
{
public class Node
{
public int Id;
public double Distance;
public bool IsExplored;
public Node(int id, double distance)
{
Id = id;
Distance = distance;
}
/// <summary>
/// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
/// </summary>
/// <param name="currentDist">The current distance from the starting node</param>
/// <returns>A clone of the node with the proper distance</returns>
public Node CreateAtDistance(double currentDist)
{
return new Node(Id, currentDist + Distance);
}
}
private Dictionary<int, List<Node>> Links;
private Dictionary<int, Dictionary<int, List<Node>>> Paths;
private bool IsByDirectional;
public GraphLinks(bool isByDirectional = true)
{
Links = new Dictionary<int, List<Node>>();
IsByDirectional = isByDirectional;
}
public bool ContainsLink(int id1, int id2)
{
return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
}
/// <summary>
/// Adds a link to the list
/// </summary>
/// <param name="id1">First id</param>
/// <param name="id2">Second id</param>
/// <param name="distance">The distance between the two nodes</param>
public void AddLink(int id1, int id2, double distance)
{
//Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
if (ContainsLink(id1, id2))
return;
AddLinkInternal(id1, id2, distance);
if (IsByDirectional)
AddLinkInternal(id2, id1, distance);
}
public void RemoveLink(int id1, int id2)
{
Links[id1].RemoveAll(n => n.Id == id2);
Links[id2].RemoveAll(n => n.Id == id1);
}
/// <summary>
/// Calculates all of the shortest paths in the node links
/// </summary>
public void CalculateShortestPaths()
{
Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
List<int> vertices = Links.Keys.ToList();
int vertexCount = vertices.Count;
foreach (int vertex in vertices)
{
CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
}
}
/// <summary>
/// Calculates the shortest paths from a start node
/// </summary>
/// <param name="startNode">id of the start node</param>
/// <param name="maxDistance">the fartheset distance to travel</param>
public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
{
Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
}
/// <summary>
/// Calculates the shortest paths from the start node to all other nodes
/// </summary>
/// <param name="startNode">The starting id</param>
/// <param name="vertexCount">The number of nodes</param>
/// <param name="maxDistance">the farthest distance to travel</param>
private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
{
List<Node> minimumSpanningTree = new List<Node>();
//Console.Error.WriteLine("Starting with " + startNode);
double currentDist = 0;
Paths[startNode] = new Dictionary<int, List<Node>>();
minimumSpanningTree.Add(new Node(startNode, currentDist));
while (minimumSpanningTree.Count < vertexCount)
{
double minDist = 99999;
Node bestNode = null;
Node parentNode = null;
foreach (Node currentNode in minimumSpanningTree)
{
currentDist = currentNode.Distance;
//Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
foreach (Node adjacent in GetLinks(currentNode.Id))
{
if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
{
adjacent.IsExplored = true;
continue;//skip nodes already in minimum spanning tree
}
double distance = currentDist + adjacent.Distance;
if (distance < minDist)
{
minDist = distance;
bestNode = adjacent.CreateAtDistance(currentDist);
parentNode = currentNode;
}
else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
{
Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
if (lengthCurrent < lengthPrevious)
{
minDist = distance;
bestNode = adjacent.CreateAtDistance(currentDist);
parentNode = currentNode;
}
}
}
}
if (parentNode == null)
{
return;//no possible paths
}
minimumSpanningTree.Add(bestNode);
List<Node> currentPath = null;
if (parentNode.Id != startNode)
{
Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
}
if (currentPath == null)
{
currentPath = new List<Node>();
}
else
{
currentPath = new List<Node>(currentPath);
}
Paths[startNode].Add(bestNode.Id, currentPath);
currentPath.Add(bestNode);
/*
if (startNode == 0)
{
Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
}
*/
if (minDist >= maxDistance)
return;
}
}
/// <summary>
/// Retrieves the links that are adjacent to the given node
/// </summary>
/// <param name="id">The node id</param>
/// <returns></returns>
public List<Node> GetLinks(int id)
{
return Links[id];
}
public Dictionary<int, List<Node>> GetPaths(int startId)
{
return Paths[startId];
}
/// <summary>
/// Retrieves the straight line distance from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance from start to end</returns>
public double GetDistance(int startId, int endId)
{
return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
return 99999;
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
return 99999;
}
return paths.Last().Distance;
}
/// <summary>
/// Retrieves the next node along the path from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The factory id that is first in the path</returns>
public int GetShortestPath(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
throw new InvalidOperationException();
}
int shortest = paths.First().Id;
Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
return shortest;
}
/// <summary>
/// Retrieves the full path from start to end
/// </summary>
/// <param name="startId">the start id</param>
/// <param name="endId">the end id</param>
/// <returns>The full path</returns>
public List<Node> GetShortestPathAll(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
throw new InvalidOperationException();
}
return paths;
}
//Adds links to the node links
private void AddLinkInternal(int startNode, int endNode, double distance)
{
List<Node> nodeLinks;
if (Links.ContainsKey(startNode))
{
nodeLinks = Links[startNode];
}
else
{
nodeLinks = new List<Node>();
Links[startNode] = nodeLinks;
}
nodeLinks.Add(new Node(endNode, distance));
}
}
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
public interface INode
{
int Id { get; }
bool IsExplored { get; set; }
List<ILink> GetLinks();
}
public class Node : INode
{
public int Id { get; private set; }
public bool IsExplored { get; set; }
private List<ILink> Links;
public Node(int id)
{
Id = id;
IsExplored = false;
Links = new List<ILink>();
}
public void AddLink(ILink link)
{
Links.Add(link);
}
public List<ILink> GetLinks()
{
return Links;
}
public bool Equals(INode node)
{
return node.Id == Id;
}
}
public interface ILink
{
int StartNodeId { get; }
int EndNodeId { get; }
double Distance { get; }
double GetDistance(List<ILink> currentPath);
}
public class Link : ILink
{
public int StartNodeId { get; private set; }
public int EndNodeId { get; private set; }
public double Distance { get; private set; }
public Link(int startNodeId, int endNodeId, double distance)
{
StartNodeId = startNodeId;
EndNodeId = endNodeId;
Distance = distance;
}
public Link(INode startNode, INode endNode, double distance)
{
StartNodeId = startNode.Id;
EndNodeId = endNode.Id;
Distance = distance;
}
public double GetDistance(List<ILink> currentPath)
{
double distance = 0;
foreach (ILink link in currentPath)
{
distance += link.Distance;
}
return distance;
}
}
}
//*** SourceCombiner -> original file Circle2d.cs ***
namespace Algorithms.Space
{
public class Circle2d : Point2d
{
public double radius;
public Circle2d(double x, double y, double radius) : base(x, y)
{
this.radius = radius;
}
}
}
//*** SourceCombiner -> original file Point2d.cs ***
namespace Algorithms.Space
{
public class Point2d
{
public double x;
public double y;
public Point2d(double x, double y)
{
this.x = x;
this.y = y;
}
public Point2d(Point2d point)
{
x = point.x;
y = point.y;
}
public override string ToString()
{
return $"({x},{y})";
}
public override bool Equals(object objPoint)
{
Point2d point = objPoint as Point2d;
return point.x == this.x && point.y == this.y;
}
public override int GetHashCode()
{
return Tuple.Create(x, y).GetHashCode();
}
public Point2d GetTruncatedPoint()
{
return new Point2d(Math.Truncate(this.x), Math.Truncate(this.y));
}
public Point2d GetRoundedPoint()
{
return new Point2d(Math.Round(this.x), Math.Round(this.y));
}
public Point2d GetCeilingPoint()
{
return new Point2d(Math.Ceiling(x), Math.Ceiling(y));
}
public int GetTruncatedX()
{
return (int)x;
}
public int GetTruncatedY()
{
return (int)y;
}
public double GetAngle(Point2d point)
{
return Math.Atan2(point.y - y, point.x - x);
}
public int GetManhattenDistance(Point2d point)
{
return (int)(Math.Abs(point.x - x) + Math.Abs(point.y - y));
}
public double GetDistance(Point2d point)
{
return GetDistance(point.x, point.y, x, y);
}
public Point2d GetMidPoint(Point2d point)
{
return GetMidPoint(point.x, point.y, x, y);
}
public double LengthSquared()
{
return x * x + y * y;
}
public double Length()
{
return Math.Sqrt(LengthSquared());
}
public Point2d Normalize()
{
var length = Length();
if (length == 0)
{
x = 0;
y = 0;
}
else
{
x /= length;
y /= length;
}
return this;
}
public Point2d Multiply(double scalar)
{
x *= scalar;
y *= scalar;
return this;
}
public Point2d Add(Point2d vector)
{
x += vector.x;
y += vector.y;
return this;
}
public Point2d Subtract(Point2d vector)
{
x -= vector.x;
y -= vector.y;
return this;
}
public Point2d Truncate()
{
x = GetTruncatedX();
y = GetTruncatedY();
return this;
}
public Point2d SymmetricTruncate(Point2d origin)
{
Subtract(origin).Truncate().Add(origin);
return this;
}
public Point2d GetRoundedAwayFromZeroPoint()
{
return new Point2d(Math.Round(x, MidpointRounding.AwayFromZero), Math.Round(y, MidpointRounding.AwayFromZero));
}
public Point2d Clone()
{
return new Point2d(x, y);
}
public void Fill(Point2d point)
{
x = point.x;
y = point.y;
}
public static double GetDistance(double x1, double y1, double x2, double y2)
{
return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));
}
public static Point2d GetMidPoint(double x1, double y1, double x2, double y2)
{
return new Point2d((x1 + x2) / 2, (y1 + y2) / 2);
}
}
}
//*** SourceCombiner -> original file Space2d.cs ***
namespace Algorithms.Space
{
public class Space2d
{
/// <summary>
/// Given a list of points and a circle radius, find the circle location that covers the maximum number of points
/// </summary>
/// <param name="points">The list of points to consider</param>
/// <param name="radius">The radius of the circle</param>
/// <returns>The number of points covered by the circle that is centered at the point.</returns>
public static Tuple<int, Point2d> FindCircleWithMaximumPoints(Point2d[] points, double radius)
{
Tuple<int, Point2d> maxPoint = null;
if (points == null)
return null;
if (radius <= 0)
return null;
var numberOfPoints = points.Count();
double[,] distance = new double[numberOfPoints, numberOfPoints];
for (int i = 0; i < numberOfPoints - 1; i++)
{
for (int j = i + 1; j < numberOfPoints; j++)
{
distance[i, j] = distance[j, i] = points[i].GetDistance(points[j]);
}
}
for (int i = 0; i < numberOfPoints; i++)
{
var currentAnswer = GetPointsInside(distance, points, i, radius, numberOfPoints);
var nextPoint = new Tuple<int, Point2d>(currentAnswer.Item1, new Point2d(points[i].x + (radius * Math.Round(Math.Cos(currentAnswer.Item2), 15)), points[i].y + (radius * Math.Round(Math.Sin(currentAnswer.Item2), 15))));
if (maxPoint == null || currentAnswer.Item1 > maxPoint.Item1 || (currentAnswer.Item1 == maxPoint.Item1 && IsInteger(nextPoint.Item2.x) && IsInteger(nextPoint.Item2.y)))
{
maxPoint = nextPoint;
}
}
return maxPoint;
}
/// <summary>
/// Given a list of points and a circle radius, find the circle location that covers the maximum number of points, at point i.
/// </summary>
/// <param name="points">The list of points to consider</param>
/// <param name="radius">The radius of the circle</param>
/// <param name="i">The index of the point to use for the sweeping circle</param>
/// <returns>The number of points covered by the circle that is centered at the point.</returns>
public static Tuple<int, Point2d> FindCircleWithMaximumPoints(Point2d[] points, double radius, int i)
{
Tuple<int, Point2d> maxPoint = null;
if (points == null)
return null;
if (radius <= 0)
return null;
var numberOfPoints = points.Count();
double[,] distance = new double[numberOfPoints, numberOfPoints];
for (int j = 0; j < numberOfPoints; j++)
{
distance[i, j] = distance[j, i] = points[i].GetDistance(points[j]);
}
var currentAnswer = GetPointsInside(distance, points, i, radius, numberOfPoints);
maxPoint = new Tuple<int, Point2d>(currentAnswer.Item1, new Point2d(points[i].x + (radius * Math.Round(Math.Cos(currentAnswer.Item2), 15)), points[i].y + (radius * Math.Round(Math.Sin(currentAnswer.Item2), 15))));
return maxPoint;
}
public static double CalculateAreaOfCircle(double radius)
{
return Math.PI * Math.Pow(radius, 2);
}
public static double CalculateOverlappingArea(Circle2d circle, Circle2d circle2)
{
var d = circle.GetDistance(circle2);
if (d < circle.radius + circle2.radius)
{
var a = circle.radius * circle.radius;
var b = circle2.radius * circle2.radius;
var x = (a - b + d * d) / (2 * d);
var z = x * x;
var y = Math.Sqrt(a - z);
if (d <= Math.Abs(circle2.radius - circle.radius))
{
return Math.PI * Math.Min(a, b);
}
return a * Math.Asin(y / circle.radius) + b * Math.Asin(y / circle2.radius) - y * (x + Math.Sqrt(z + b - a));
}
return 0;
}
/// <summary>
/// Moves the point towards the targetPoint with maximum distance
/// </summary>
/// <param name="startPoint">Start point</param>
/// <param name="targetPoint">Target point</param>
/// <param name="maximumDistance">Maximum distance to translate</param>
/// <returns>The translated point in direction of target point with maximum distance</returns>
public static Point2d TranslatePoint(Point2d startPoint, Point2d targetPoint, double maximumDistance)
{
var vector = CreateVector(startPoint, targetPoint);
if (vector.LengthSquared() <= (maximumDistance * maximumDistance))
return targetPoint;
else
{
vector.Normalize();
vector.Multiply(maximumDistance);
return new Point2d(startPoint.x + vector.x, startPoint.y + vector.y);
}
/*
if (point.GetDistance(targetPoint) <= maximumDistance)
return targetPoint;
else
{
var angle = point.GetAngle(targetPoint);
var vx = Math.Cos(angle) * maximumDistance;
var vy = Math.Sin(angle) * maximumDistance;
return new Point2d(point.x + vx, point.y + vy);
}
*/
}
public static Point2d CreateVector(Point2d startPoint, Point2d targetPoint)
{
var x = targetPoint.x - startPoint.x;
var y = targetPoint.y - startPoint.y;
return new Point2d(x, y);
}
private static bool IsInteger(double d)
{
return Math.Abs(d % 1) <= (Double.Epsilon * 100);
}
private static Tuple<int, double> GetPointsInside(double[,] distance, Point2d[] points, int i, double radius, int numberOfPoints)
{
List<Tuple<double, bool>> angles = new List<Tuple<double, bool>>();
for (int j = 0; j < numberOfPoints; j++)
{
if (i != j && distance[i, j] <= 2 * radius)
{
double B = Math.Acos(distance[i, j] / (2 * radius));
Complex c1 = new Complex(points[j].x - points[i].x, points[j].y - points[i].y);
double A = c1.Phase;
double alpha = A - B;
double beta = A + B;
angles.Add(new Tuple<double, bool>(alpha, true));
angles.Add(new Tuple<double, bool>(beta, false));
}
}
angles = angles.OrderBy(angle => angle.Item1).ToList();
int count = 1, res = 1;
double maxAngle = 0;
foreach (var angle in angles)
{
if (angle.Item2)
count++;
else
count--;
if (count > res)
{
res = count;
maxAngle = angle.Item1;
}
}
return new Tuple<int, double>(res, maxAngle);
}
}
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
public class GameTreeNode
{
public IGameState state;
public IList moves;
public List<GameTreeNode> children;
public double wins = 0;
public double loses = 0;
public int totalPlays = 0;
public GameTreeNode parent;
public bool isMax;
public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
{
this.state = state;
moves = state.GetPossibleMoves(isMax);
children = new List<GameTreeNode>(50);
this.parent = parent;
this.isMax = isMax;
}
public double GetScore(bool isMax)
{
double totalPlays = TotalPlays();
if (totalPlays == 0)
return 0;
if (isMax)
{
return (wins - loses) / totalPlays;
}
else
{
return (loses - wins) / totalPlays;
}
}
public int TotalPlays()
{
return totalPlays;
}
public double? GetWinner()
{
return state.GetWinner();
}
public void ApplyWinner(double? winner)
{
if (winner.HasValue)
{
if (winner > 0)
{
wins += winner.Value;
}
else if (winner < 0)
{
loses += Math.Abs(winner.Value);
}
totalPlays++;
}
}
public double Evaluate()
{
return state.Evaluate(isMax);
}
}
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms.Trees
{
public class Minimax : TreeAlgorithm
{
public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
{
double val = 99999999;
val *= RootNode.isMax ? -1 : 1;
object bestMove = null;
foreach (object move in RootNode.moves)
{
GameTreeNode child = Expand(RootNode, move);
double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
{
bestMove = move;
val = currentVal;
}
if (watch.ElapsedMilliseconds >= timeLimit)
{
break;
}
}
return bestMove;
}
public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
{
if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
{
double eval = currentNode.Evaluate();
return eval;
}
double? winner = currentNode.GetWinner();
if (winner.HasValue)
{
return winner.Value;
}
if (currentNode.isMax)
{
double value = -99999;
double minMax;
foreach (object move in currentNode.moves)
{
GameTreeNode childNode = Expand(currentNode, move);
minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
value = Math.Max(value, minMax);
alpha = Math.Max(alpha, value);
if (alpha >= beta)
{
break;
}
}
return value;
}
else
{
double value = 99999;
double minMax;
foreach (object move in currentNode.moves)
{
GameTreeNode childNode = Expand(currentNode, move);
minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
value = Math.Min(value, minMax);
beta = Math.Min(beta, value);
if (beta <= alpha)
{
break;
}
}
return value;
}
}
}
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
public class MonteCarloTreeSearch : TreeAlgorithm
{
private Random rand;
private bool printErrors;
private SearchStrategy strategy;
public enum SearchStrategy
{
Random = 0,
Sequential = 1
}
public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random)
{
rand = new Random();
printErrors = showErrors;
strategy = searchStrategy;
}
public IGameState GetRootState()
{
return RootNode.state;
}
/// <summary>
/// Get the next move
/// </summary>
/// <param name="watch">timer</param>
/// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
/// <param name="depth">How deep to run the simulations; does not impact how deep it goes in the game tree.</param>
/// <param name="numRollouts">The number of roll outs to play per expansion</param>
/// <returns></returns>
public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
{
if (exploration == null)
{
exploration = Math.Sqrt(2);
}
int count = 0;
do
{
GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
if (selectedNode == null)
{
if (printErrors)
Console.Error.WriteLine("Found no more moves!");
break;
}
object move = SelectMove(selectedNode);
GameTreeNode childNode = Expand(selectedNode, move);
double? winner = childNode.GetWinner();
if (winner.HasValue)
{
BackPropagate(childNode, winner);
count++;
}
else
{
for (int i = 0; i < numRollouts; i++)
{
var clonedState = childNode.state.Clone();
winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
if (!winner.HasValue)
break;//We simulated a game, but it didn't end so we are out of time...
BackPropagate(childNode, winner);
count++;
}
}
}
while (watch.ElapsedMilliseconds < timeLimit);
if (printErrors)
Console.Error.WriteLine($"Played {count} games!");
GameTreeNode bestChild = null;
double bestScore = double.MinValue;
for (int i = 0; i < RootNode.children.Count; i++)
{
var child = RootNode.children[i];
double score = child.GetScore(RootNode.isMax);
if (bestScore < score)
{
bestChild = child;
bestScore = score;
}
if (printErrors)
Console.Error.WriteLine($"w: {(RootNode.isMax ? child.wins : child.loses)} l: {(RootNode.isMax ? child.loses : child.wins)} total: {child.totalPlays} score: {score} isMax: {RootNode.isMax} move: {child.state.GetMove(RootNode.isMax)}");
}
if (printErrors)
Console.Error.WriteLine($"Best: w: {(RootNode.isMax ? bestChild.wins : bestChild.loses)} l: {(RootNode.isMax ? bestChild.loses : bestChild.wins)} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
return bestChild.state.GetMove(RootNode.isMax);
}
private void BackPropagate(GameTreeNode selectedNode, double? winner)
{
selectedNode.ApplyWinner(winner);
GameTreeNode tempNode = selectedNode.parent;
while (tempNode != null)
{
tempNode.ApplyWinner(winner);
tempNode = tempNode.parent;
}
}
private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
{
double? winner;
do
{
if (watch.ElapsedMilliseconds >= timeLimit)
{
return null;
}
object move = SelectMoveAtRandom(state, isMax);
state.ApplyMove(move, isMax);
if (watch.ElapsedMilliseconds >= timeLimit)
{
return null;
}
depth--;
isMax = !isMax;
winner = state.GetWinner();
}
while (!winner.HasValue && depth != 0);
if (winner.HasValue)
{
return winner;
}
if (depth == 0)
{
double eval = state.Evaluate(isMax);
if (eval > 1)
{
return 1;
}
else if (eval < -1)
return -1;
else return eval;
}
throw new InvalidOperationException("Could not find a winner for simulation!");
}
private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
{
Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
queue.Enqueue(node);
GameTreeNode tempNode;
GameTreeNode bestNode = null;
double maxValue = -1;
while (queue.Count > 0)
{
tempNode = queue.Dequeue();
if (tempNode.moves.Count == 0)
{
for (int i = 0; i < tempNode.children.Count; i++)
{
var child = tempNode.children[i];
queue.Enqueue(child);
}
}
else if (tempNode.parent != null)
{
double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
double nodeTotal = tempNode.TotalPlays();
double parentTotal = tempNode.parent.TotalPlays();
double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
if (value > maxValue)
{
maxValue = value;
bestNode = tempNode;
}
}
else return tempNode;
}
return bestNode;
}
private object SelectMoveAtRandom(IGameState state, bool isMax)
{
IList moves = state.GetPossibleMoves(isMax);
if (moves.Count == 0)
{
throw new Exception("No moves available!");
}
int index = rand.Next(0, moves.Count);
return moves[index];
}
private object SelectMove(GameTreeNode node)
{
switch (strategy)
{
case SearchStrategy.Random:
return SelectMoveAtRandom(node);
case SearchStrategy.Sequential:
return SelectMoveSequentially(node);
}
throw new InvalidOperationException("strategy not supported");
}
private object SelectMoveSequentially(GameTreeNode node)
{
object move;
if (node.moves.Count == 0)//If there are no more moves then that is a problem...
{
throw new Exception("No moves found!");
}
else
{
move = node.moves[0];
node.moves.RemoveAt(0);
}
return move;
}
private object SelectMoveAtRandom(GameTreeNode node)
{
object move;
if (node.moves.Count == 0)//If there are no more moves then that is a problem...
{
throw new Exception("No moves found!");
}
else
{
int index = rand.Next(0, node.moves.Count);
move = node.moves[index];
node.moves.RemoveAt(index);
}
return move;
}
}
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms.Trees
{
public class TreeAlgorithm
{
protected GameTreeNode RootNode;
public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
{
if (RootNode != null && findState)
{
//if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
//find the child that matches the new node
bool isFound = false;
//Expand any moves left in the root node (if any)
for (int i = 0; i < RootNode.moves.Count; i++)
{
var move = RootNode.moves[i];
Expand(RootNode, move);
}
//Begin scanning the children
for (int i = 0; i < RootNode.children.Count; i++)
{
var child = RootNode.children[i];
if (child.state.Equals(rootState))
{
RootNode = child;
isFound = true;
break;
}
for (int j = 0; j < child.moves.Count; j++)
{
var move = child.moves[j];
Expand(child, move);
}
for (int j = 0; j < child.children.Count; j++)
{
var descendent = child.children[j];
if (descendent.state.Equals(rootState))
{
RootNode = descendent;
isFound = true;
break;
}
}
}
if (!isFound)
{
Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
RootNode = new GameTreeNode(rootState.Clone(), isMax);
}
else
{
RootNode.parent = null;
}
}
else
{
RootNode = new GameTreeNode(rootState.Clone(), isMax);
}
}
/// <summary>
/// Expands the given node by create a clone, applying the move and then adding it to the list of children.
/// </summary>
/// <param name="node">The node to expand</param>
/// <param name="move">The move to play on the expanded node</param>
/// <returns></returns>
protected GameTreeNode Expand(GameTreeNode node, object move)
{
IGameState nextState = node.state.Clone();
nextState.ApplyMove(move, node.isMax);
GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
node.children.Add(childNode);
return childNode;
}
}
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
public static class BitFunctions
{
public static bool IsBitSet(long value, int location)
{
long mask = GetBitMask(location);
return (value & mask) == mask;
}
public static long SetBit(long value, int location)
{
return value | (GetBitMask(location));
}
public static long ClearBit(long value, int location)
{
return value & (~(GetBitMask(location)));
}
public static long SetOrClearBit(long value, int location, bool isSet)
{
if (isSet)
return SetBit(value, location);
return ClearBit(value, location);
}
public static int NumberOfSetBits(long i)
{
i = i - ((i >> 1) & 0x5555555555555555);
i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
}
public static long GetBitMask(int index)
{
return (long)1 << index;
}
}
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
public class Board
{
public int Width { get; private set; }
public int Height { get; private set; }
private Entity[] Entities { get; set; }
public int GlobalOrganId { get; set; } = -1;
public Graph Graph { get; set; }
public static OrganDirection[] PossibleDirections = new OrganDirection[] { OrganDirection.North, OrganDirection.South, OrganDirection.East, OrganDirection.West };
public Board(int width, int height)
{
Width = width;
Height = height;
Entities = new Entity[Width * Height];
Graph = new Graph();
InitializeBoard();
UpdateBoard();
}
public Board(Board board)
{
Width = board.Width;
Height = board.Height;
Entities = board.Entities.Select(e => e == null ? null : e.Clone()).ToArray();
GlobalOrganId = board.GlobalOrganId;
Graph = board.Graph;
_entityCache = board._entityCache;
_moveActionCache = board._moveActionCache;
_myEntityCount = board._myEntityCount;
_oppEntityCount = board._oppEntityCount;
_locationCache = board._locationCache;
_locationIndexCache = board._locationIndexCache;
_locationNeighbors = board._locationNeighbors;
UpdateBoard();
}
public bool Equals(Board board)
{
if (Width != board.Width || Height != board.Height)
return false;
for (int x = 0; x < Width; x++)
{
for (int y = 0; y < Height; y++)
{
board.GetEntity(GetNodeIndex(x, y), out Entity entity);
GetEntity(GetNodeIndex(x, y), out Entity currentEntity);
if (entity == null && currentEntity == null)
continue;
if (entity == null && currentEntity != null)
return false;
if (entity != null && currentEntity == null)
return false;
else if (!entity.Equals(currentEntity))
return false;
}
}
return true;
}
public void Attack()
{
var tentacles = GetTentacleEntities();
List<Entity> deadEntities = new List<Entity>();
foreach (Entity tentacle in tentacles)
{
if (GetEntityWithDirection(tentacle.Location, tentacle.OrganDirection, out Entity entity) && entity.IsMine.HasValue && entity.IsMine != tentacle.IsMine)
{
deadEntities.Add(entity);
}
}
foreach (Entity deadEntity in deadEntities)
{
if (deadEntity.Type == EntityType.ROOT)
{
var deathToRoot = GetEntitiesList().Where(e => e.OrganRootId == deadEntity.OrganRootId);
foreach (Entity kill in deathToRoot)
{
Entities[GetNodeIndex(kill.Location)] = null;
}
}
else
{
var deathToChildren = GetEntitiesList().Where(e => e.OrganParentId == deadEntity.OrganId);
foreach (Entity kill in deathToChildren)
{
Entities[GetNodeIndex(kill.Location)] = null;
}
}
}
}
public void ApplyMove(Move myMove, Move oppMove)
{
foreach (MoveAction action in myMove.Actions)
{
if (action.Type != MoveType.WAIT)
{
var collisionActions = oppMove.Actions.Where(a => (a.Type == MoveType.GROW || a.Type == MoveType.SPORE) && a.Location.Equals(action.Location));
if (collisionActions.Count() > 0)
{
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, EntityType.WALL, null, 0, 0, 0, OrganDirection.None);
}
else
{
ApplyAction(action, true);
}
}
}
foreach (MoveAction action in oppMove.Actions)
{
ApplyAction(action, false);
}
}
public void ApplyAction(MoveAction action, bool isMine)
{
switch (action.Type)
{
case MoveType.GROW:
Entity growEntity = Entities[GetNodeIndex(action.Location)];
if (growEntity == null || growEntity.IsOpenSpace())
{
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, action.EntityType, isMine, GlobalOrganId++, action.OrganId, action.OrganRootId, action.OrganDirection);
}
break;
case MoveType.SPORE:
Entity sporeEntity = Entities[GetNodeIndex(action.Location)];
if (sporeEntity == null || sporeEntity.IsOpenSpace())
{
var organId = GlobalOrganId++;
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, action.EntityType, isMine, organId, organId, organId, action.OrganDirection);
}
break;
}
}
public List<Move> GetMoves(int[] proteins, bool isMine)
{
var moves = new List<Move>();
var rootEntities = GetRootEntities(isMine);
var organismCount = rootEntities.Count();
MoveAction[][] organismToMoveActions = new MoveAction[organismCount][];
List<bool> hasProteins = proteins.Select(p => p > 0).ToList();
bool hasHarvestProteins = hasProteins[2] && hasProteins[3];
bool hasBasicProteins = hasProteins[0];
bool hasTentacleProteins = hasProteins[1] && hasProteins[2];
bool hasSporerProteins = hasProteins[1] && hasProteins[3];
bool hasRootProteins = hasProteins.All(m => m);
List<bool> hasManyProteins = proteins.Select(p => p > 10).ToList();
bool hasManyTentacleProteins = hasManyProteins[1] && hasManyProteins[2];
bool hasManySporerProteins = hasManyProteins[1] && hasManyProteins[3];
bool hasAtLeastTwoMany = hasManyProteins.Count(value => value) > 1;
int i = 0;
int maxOrgans = 3;//Put a limit on the number of organs we calculate moves for as this is exploding the action space
var limitedRootEntities = rootEntities;
if (organismCount > maxOrgans)
{
rootEntities.Sort((e1, e2) => e2.OrganId.CompareTo(e1.OrganId));
limitedRootEntities = rootEntities.Take(maxOrgans).ToList();
}
foreach (Entity root in limitedRootEntities)
{
var moveActions = new List<MoveAction>
{
MoveAction.CreateWait()
};
bool canHarvest = false;
if (hasHarvestProteins)
{
var harvestActions = GetHarvestMoveActions(root.OrganRootId, isMine);
moveActions.AddRange(harvestActions);
canHarvest = harvestActions.Count > 0;
}
if (!canHarvest)
{
if (hasBasicProteins && !hasManyTentacleProteins)
{
moveActions.AddRange(GetGrowBasicMoveActions(root.OrganRootId, isMine));
}
}
if (hasTentacleProteins)
{
moveActions.AddRange(GetTentacleMoveActions(root.OrganRootId, isMine, moveActions.Count > 1));
}
if ((!canHarvest || hasManySporerProteins) && hasSporerProteins)
{
moveActions.AddRange(GetSporerMoveActions(root.OrganRootId, isMine));
}
if (hasRootProteins)
{
moveActions.AddRange(GetSporeMoveActions(root.OrganRootId, isMine));
}
organismToMoveActions[i] = moveActions.ToArray();
i++;
}
for (; i < organismCount; i++)
{
organismToMoveActions[i] = new MoveAction[]
{
MoveAction.CreateWait()
};
}
if (organismCount > 1)
{
bool hasSufficientProteins = (proteins[0] > maxOrgans || proteins[0] == 0) && (proteins[1] > maxOrgans || proteins[1] == 0) && (proteins[2] > maxOrgans || proteins[2] == 0) && (proteins[3] > maxOrgans || proteins[3] == 0);
var theMoves = PrunedCartesianProduct(organismToMoveActions, hasSufficientProteins, proteins);
moves = theMoves.ToList();
}
else if (organismCount == 1)
{
foreach (MoveAction action in organismToMoveActions[0])
{
var move = new Move();
move.SetActions(new MoveAction[] { action });
moves.Add(move);
}
}
else
{
//Since we don't check game end conditions until after a move occurs, when there is an attack that kills the last root entity then we can end up in this situation so just give a wait action and do nothing.  The game is over.
var move = new Move();
move.SetActions(new MoveAction[]
{
MoveAction.CreateWait()
});
moves.Add(move);
}
return moves;
}
public bool ValidateCost(int[] proteins, Move move)
{
int[] theCosts = move.GetCost();
for (int i = 0; i < 4; i++)
{
if (proteins[i] < theCosts[i])
return false;
}
return true;
}
//slower
public static IEnumerable<MoveAction[]> CartesianProductRecursive(MoveAction[][] arrays)
{
IEnumerable<MoveAction[]> Helper(int depth)
{
if (depth == arrays.Length)
{
yield return new MoveAction[0];
yield break;
}
foreach (var item in arrays[depth])
{
foreach (var product in Helper(depth + 1))
{
yield return new[] { item }.Concat(product).ToArray();
}
}
}
return Helper(0);
}
//should be faster with pruning
public IEnumerable<Move> PrunedCartesianProduct(MoveAction[][] sequences, bool hasSufficientProteins, int[] proteins)
{
if (sequences == null || sequences.Length == 0)
yield break;
var sequenceArrays = sequences;
var dimensions = sequenceArrays.Length;
// Indexes to keep track of positions in each sequence
var indices = new int[dimensions];
var currentCombination = new MoveAction[dimensions];
int position = 0;
var partialCosts = new int[dimensions][];
var partialCollision = new HashSet<int>[dimensions];
while (true)
{
// Build the current combination
bool hasCollision = false;
bool hasProteins = true;
for (int i = position; i < dimensions; i++)
{
if (i > 0)
{
partialCosts[i] = partialCosts[i - 1].ToArray();
partialCollision[i] = partialCollision[i - 1].ToHashSet();
}
else
{
partialCosts[i] = new int[4] { 0, 0, 0, 0 };
partialCollision[i] = new HashSet<int>();
}
currentCombination[i] = sequenceArrays[i][indices[i]];
// Update partial costs for each protein based on current combination
if (!hasSufficientProteins)
{
var cost = currentCombination[i].GetCost();
for (int j = 0; j < proteins.Length; j++)
{
partialCosts[i][j] += cost[j];
if (partialCosts[position][j] > proteins[j]) // Compare individual protein costs across all dimensions
{
hasProteins = false;
break;
}
}
if (!hasProteins)
{
break;
}
}
// Update partial collisions
if (ValidateLocation(currentCombination[i].Location))
{
if (!partialCollision[i].Add(currentCombination[i].Location.index))
{
hasCollision = true;
break;
}
}
}
// Validate the combination
if (!hasCollision &&
(hasSufficientProteins || hasProteins))
{
var move = new Move();
move.SetActions(currentCombination);
yield return move;
position = dimensions - 1;
}
// Increment indices iteratively
while (position >= 0)
{
indices[position]++;
if (indices[position] < sequenceArrays[position].Length)
break;
// Reset this position and move to the next
indices[position] = 0;
position--;
}
// Terminate if we've exhausted all combinations
if (position < 0)
break;
}
}
public List<MoveAction> GetSporeMoveActions(int organRootId, bool isMine)
{
List<MoveAction> moveActions = new List<MoveAction>();
IEnumerable<Entity> sporers = GetSporerEntities(organRootId, isMine);
foreach (Entity sporer in sporers)
{
var location = sporer.Location;
int distance = 0;
while (true)
{
distance++;
if (IsOpenSpace(location, sporer.OrganDirection, isMine))
{
location = GetNextLocation(location, sporer.OrganDirection);
if (distance <= 3)
{
continue;
}
if (!IsHarvesting(location, isMine) && IsHarvestExactly2paces(location))
{
moveActions.Add(MoveAction.CreateSpore(sporer.OrganId, location));
}
}
else
{
break;
}
}
}
return moveActions;
}
public List<MoveAction> GetSporerMoveActions(int organRootId, bool isMine)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowBasicMoveActions(organRootId, isMine);
foreach (MoveAction growAction in growMoveActions)
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(growAction.Location))
{
var location = growAction.Location;
bool isOpen = true;
for (int i = 0; i < 4; i++)
{
if (!IsOpenSpace(location, locationNeighbor.direction, isMine))
{
isOpen = false;
break;
}
location = GetNextLocation(location, locationNeighbor.direction);
}
if (isOpen)
{
moveActions.Add(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.SPORER, growAction.OrganRootId, locationNeighbor.direction));
}
}
}
return moveActions;
}
public List<MoveAction> GetTentacleMoveActions(int organRootId, bool isMine, bool hasActions)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowBasicMoveActions(organRootId, isMine);
foreach (MoveAction growAction in growMoveActions)
{
List<MoveAction> tentacleMoveActions = new List<MoveAction>();
List<MoveAction> tentacleMoveActionsToAdd = new List<MoveAction>();
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(growAction.Location))
{
if (IsOpponentOrEmptySpace(locationNeighbor.point.index, isMine))
{
if (!hasActions || IsOpponentWithin3Spaces(growAction.Location, isMine))
{
MoveAction tentacleAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.TENTACLE, growAction.OrganRootId, locationNeighbor.direction);
tentacleMoveActions.Add(tentacleAction);
//Check to see if any are facing the enemy and use those as priority
if (GetEntityWithDirection(tentacleAction.Location, tentacleAction.OrganDirection, out Entity entity) && entity.IsMine.HasValue && entity.IsMine != isMine)
{
tentacleMoveActionsToAdd.Add(tentacleAction);
}
}
}
}
if (tentacleMoveActionsToAdd.Count > 0)
{
moveActions.AddRange(tentacleMoveActionsToAdd);
}
else
{
moveActions.AddRange(tentacleMoveActions);
}
}
return moveActions;
}
private Dictionary<string, List<MoveAction>> _moveActionCache = new Dictionary<string, List<MoveAction>>();
public List<MoveAction> GetGrowBasicMoveActions(int organRootId, bool isMine)
{
var key = (isMine ? "growbasic1_" : "growbasic0_") + organRootId.ToString();
if (!_moveActionCache.TryGetValue(key, out List<MoveAction> moveActions))
{
moveActions = new List<MoveAction>();
var potentialMoveActions = new List<MoveAction>();
var entities = GetEntitiesByRoot(organRootId, isMine);
foreach (Entity entity in entities)
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(entity.Location))
{
if (IsOpenSpace(locationNeighbor.point.index, isMine))
{
var moveAction = MoveAction.CreateGrow(entity.OrganId, locationNeighbor.point, EntityType.BASIC, entity.OrganRootId);
if (!IsHarvesting(locationNeighbor.point.index, isMine))
{
moveActions.Add(moveAction);
}
else
{
potentialMoveActions.Add(moveAction);
}
}
}
}
if (moveActions.Count == 0)
{
moveActions = potentialMoveActions;
}
int maxMoves = 5;
if (moveActions.Count > maxMoves)
{
var oppRootEntities = GetRootEntities(!isMine);
var harvestableEntities = GetHarvestableEntities();
bool hasOppRoot = false;
bool hasHarvestable = false;
if (oppRootEntities.Count > 0)
hasOppRoot = true;
if (harvestableEntities.Count > 0)
hasHarvestable = true;
foreach (MoveAction action in moveActions)
{
action.Score = 0;
if (hasHarvestable)
{
action.Score += harvestableEntities.Min(r => Graph.GetShortestPathDistance(r.Location.index, action.Location.index));
}
else if (hasOppRoot)
{
action.Score += oppRootEntities.Min(r => Graph.GetShortestPathDistance(r.Location.index, action.Location.index));
}
}
moveActions.Sort((m1, m2) => m2.Score.CompareTo(m1.Score));
moveActions = moveActions.Take(maxMoves).ToList();
}
_moveActionCache[key] = moveActions;
}
return moveActions;
}
public List<MoveAction> GetHarvestMoveActions(int organRootId, bool isMine)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowBasicMoveActions(organRootId, isMine);
foreach (MoveAction growAction in growMoveActions)
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(growAction.Location))
{
if (IsHarvestSpace(locationNeighbor.point.index) && !IsHarvesting(locationNeighbor.point.index, isMine))
{
var harvestAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, locationNeighbor.direction);
//Prioritize A harvests
/*
if (GetEntity(locationNeighbor.point.index, out Entity entity) && entity.Type == EntityType.A)
{
return new List<MoveAction>()
{
harvestAction
};
}
*/
moveActions.Add(harvestAction);
}
}
}
return moveActions;
}
public bool IsHarvesting(int location, bool isMine)
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(location))
{
if (GetEntity(locationNeighbor.point.index, out Entity entity) && entity.Type == EntityType.HARVESTER && entity.IsMine.HasValue && entity.IsMine == isMine && entity.OrganDirection == GetOpposingDirection(locationNeighbor.direction))
{
return true;
}
}
return false;
}
public bool IsHarvesting(Point2d location, bool isMine)
{
if (ValidateLocation(location) && GetEntity(location, out Entity harvestSpace) && harvestSpace.IsOpenSpace())
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(location))
{
if (GetEntity(locationNeighbor.point.index, out Entity entity) && entity.Type == EntityType.HARVESTER && entity.IsMine.HasValue && entity.IsMine == isMine && entity.OrganDirection == GetOpposingDirection(locationNeighbor.direction))
{
return true;
}
}
}
return false;
}
public bool IsFull()
{
foreach (Entity entity in Entities)
{
if (entity == null)
{
return false;
}
}
return true;
}
public int[] GetHarvestProteins(bool isMine)
{
var harvesters = GetHarvesterEntities(isMine);
int[] harvestedProteins = new int[4] { 0, 0, 0, 0 };
foreach (Entity harvester in harvesters)
{
if (GetEntityWithDirection(harvester.Location, harvester.OrganDirection, out Entity entity) && entity.IsOpenSpace())
{
harvestedProteins[entity.Type - EntityType.A]++;
}
}
return harvestedProteins;
}
public OrganDirection GetOpposingDirection(OrganDirection direction)
{
switch (direction)
{
case OrganDirection.North:
return OrganDirection.South;
case OrganDirection.South:
return OrganDirection.North;
case OrganDirection.East:
return OrganDirection.West;
case OrganDirection.West:
return OrganDirection.East;
}
throw new Exception("No direction given");
}
public bool IsHarvestExactly2paces(Point2d location)
{
var harvestEntities = GetHarvestableEntities();
foreach (var entity in harvestEntities)
{
if (location.Equals(entity.Location))
continue;
double distance = Graph.GetShortestPathDistance(GetNodeIndex(location), GetNodeIndex(entity.Location));
if (distance == 2)
{
return true;
}
}
return false;
}
public bool IsOpponentWithin3Spaces(Point2d location, bool isMine)
{
var oppEntities = GetEntities(!isMine);
foreach (var oppEntity in oppEntities)
{
double distance = Graph.GetShortestPathDistance(GetNodeIndex(location), GetNodeIndex(oppEntity.Location));
if (distance <= 3)
return true;
}
return false;
}
public bool IsOpponentWithin3Spaces(int index, bool isMine)
{
var oppEntities = GetEntities(!isMine);
foreach (var oppEntity in oppEntities)
{
double distance = Graph.GetShortestPathDistance(index, GetNodeIndex(oppEntity.Location));
if (distance <= 3)
return true;
}
return false;
}
public bool IsOpponentOrEmptySpace(Point2d location, OrganDirection direction, bool isMine)
{
return ValidateLocation(location, direction) && (!GetEntityWithDirection(location, direction, out Entity entity) || (entity.IsMine.HasValue && entity.IsMine != isMine));
}
public bool IsOpponentOrEmptySpace(int index, bool isMine)
{
return !GetEntity(index, out Entity entity) || (entity.IsMine.HasValue && entity.IsMine != isMine);
}
public bool IsOpponentSpace(Point2d location, OrganDirection direction, bool isMine)
{
return GetEntityWithDirection(location, direction, out Entity entity) && entity.IsMine != isMine;
}
public bool IsHarvestSpace(int location)
{
return GetEntity(location, out Entity entity) && entity.IsOpenSpace();
}
public bool IsHarvestSpace(Point2d location, OrganDirection nextDirection)
{
return GetEntityWithDirection(location, nextDirection, out Entity entity) && entity.IsOpenSpace();
}
public bool IsOpenSpace(Point2d location, OrganDirection nextDirection, bool isMine)
{
var locationToCheck = GetNextLocation(location, nextDirection);
if (ValidateLocation(locationToCheck))
{
if (!GetEntityByLocation(locationToCheck, out Entity entity) || entity.IsOpenSpace())
{
var tentacles = GetTentacleEntities(!isMine);
if (tentacles.Count > 0)
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(locationToCheck))
{
if (GetEntity(locationNeighbor.point.index, out Entity checkForTentacleEntity))
{
if (checkForTentacleEntity.Type == EntityType.TENTACLE && GetOpposingDirection(checkForTentacleEntity.OrganDirection) == locationNeighbor.direction && checkForTentacleEntity.IsMine != isMine)
{
return false;
}
}
}
}
return true;
}
}
return false;
}
public bool IsOpenSpace(int location, bool isMine)
{
if (!GetEntity(location, out Entity entity) || entity.IsOpenSpace())
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(location))
{
if (GetEntity(locationNeighbor.point.index, out Entity checkForTentacleEntity))
{
if (checkForTentacleEntity.Type == EntityType.TENTACLE && GetOpposingDirection(checkForTentacleEntity.OrganDirection) == locationNeighbor.direction && checkForTentacleEntity.IsMine != isMine)
{
return false;
}
}
}
return true;
}
return false;
}
public bool ValidateLocation(Point2d location, OrganDirection nextDirection)
{
return ValidateLocation(GetNextLocation(location, nextDirection));
}
public bool ValidateLocation(Point2d location)
{
return location != null;
}
public bool GetEntityWithDirection(Point2d currentLocation, OrganDirection nextDirection, out Entity entity)
{
var location = GetNextLocation(currentLocation, nextDirection);
entity = null;
return ValidateLocation(location) && GetEntity(location, out entity);
}
public Point2d GetNextLocation(Point2d currentLocation, OrganDirection nextDirection)
{
return _locationCache[(int)currentLocation.x + 1][(int)currentLocation.y + 1][(int)nextDirection];
}
private Point2d GetNextLocationInternl(int x, int y, OrganDirection nextDirection)
{
switch (nextDirection)
{
case OrganDirection.North:
return new Point2d(x, y - 1, GetNodeIndexInternal(x, y - 1));
case OrganDirection.South:
return new Point2d(x, y + 1, GetNodeIndexInternal(x, y + 1));
case OrganDirection.East:
return new Point2d(x + 1, y, GetNodeIndexInternal(x + 1, y));
case OrganDirection.West:
return new Point2d(x - 1, y, GetNodeIndexInternal(x - 1, y));
default:
return new Point2d(x, y, GetNodeIndexInternal(x, y));
}
}
public void Harvest(bool isMine, int[] proteins)
{
var harvesters = GetHarvesterEntities(isMine);
List<int> harvestedLocations = new List<int>();
foreach (Entity harvester in harvesters)
{
if (GetEntityWithDirection(harvester.Location, harvester.OrganDirection, out Entity entity) && entity.IsOpenSpace() && !harvestedLocations.Contains(entity.Location.index))
{
proteins[entity.Type - EntityType.A]++;
harvestedLocations.Add(entity.Location.index);
}
}
}
public bool GetEntity(int entityIndex, out Entity entity)
{
entity = Entities[entityIndex];
if (entity == null)
return false;
return true;
}
public bool GetEntity(Point2d location, out Entity entity)
{
return GetEntity(GetNodeIndex(location), out entity);
}
public List<Entity> GetHarvestableEntities()
{
var key = "harvestable";
if (!_entityCache.TryGetValue(key, out var entities))
{
entities = GetEntitiesList().Where(e => e.IsOpenSpace()).ToList();
_entityCache[key] = entities;
}
return entities;
}
public bool GetEntityByLocation(Point2d location, out Entity entity)
{
return GetEntity(location, out entity);
}
public Entity GetEntityByLocation(Point2d location)
{
Entity entity = null;
GetEntity(location, out entity);
return entity;
}
public List<Entity> GetHarvesterEntities(bool isMine)
{
var key = isMine ? "harvest1" : "harvest0";
if (!_entityCache.TryGetValue(key, out var entities))
{
entities = GetEntities(isMine).Where(e => e.Type == EntityType.HARVESTER).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetRootEntities(bool isMine)
{
var key = isMine ? "root1" : "root0";
if (!_entityCache.TryGetValue(key, out var entities))
{
entities = GetEntities(isMine).Where(e => e.Type == EntityType.ROOT).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetSporerEntities(int organRootId, bool isMine)
{
var key = isMine ? "sporer1" : "sporer0";
if (!_entityCache.TryGetValue(key, out var entities))
{
entities = GetEntitiesByRoot(organRootId, isMine).Where(e => e.Type == EntityType.SPORER).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetTentacleEntities(bool isMine)
{
var key = isMine ? "tentacles1" : "tentacles0";
if (!_entityCache.TryGetValue(key, out var entities))
{
entities = GetTentacleEntities().Where(e => e.IsMine == isMine).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetTentacleEntities()
{
var key = "tentacles";
if (!_entityCache.TryGetValue(key, out var entities))
{
entities = GetEntitiesList().Where(e => e.Type == EntityType.TENTACLE).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetEntitiesList()
{
var key = "all";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = Entities.Where(e => e != null).ToList();
_entityCache[key] = entities;
}
return entities;
}
private Dictionary<string, List<Entity>> _entityCache = new Dictionary<string, List<Entity>>();
public List<Entity> GetEntities(bool isMine)
{
var key = isMine ? "e1" : "e0";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = GetEntitiesList().Where(e => e.IsMine.HasValue && e.IsMine == isMine).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetEntitiesByRoot(int organRootId, bool isMine)
{
var key = $"{organRootId}_{isMine}";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = GetEntities(isMine).Where(e => e.OrganRootId == organRootId).ToList();
_entityCache[key] = entities;
}
return entities;
}
public Entity[] GetEntities()
{
return Entities;
}
private int _myEntityCount = -1;
public int GetMyEntityCount()
{
if (_myEntityCount < 0)
{
_myEntityCount = GetEntities(true).Count;
}
return _myEntityCount;
}
private int _oppEntityCount = -1;
public int GetOppEntityCount()
{
if (_oppEntityCount < 0)
{
_oppEntityCount = GetEntities(false).Count;
}
return _oppEntityCount;
}
public void SetEntities(IList<Entity> entities)
{
UpdateBoard();
Array.Clear(Entities);
foreach (Entity entity in entities)
{
Entities[GetNodeIndex(entity.Location)] = entity;
if (entity.OrganId > 0 && GlobalOrganId <= entity.OrganId)
{
GlobalOrganId = entity.OrganId + 1;
}
}
}
public Board Clone()
{
return new Board(this);
}
public double? GetWinner()
{
return null;
}
public void Print()
{
for (int y = 0; y < Height; y++)
{
StringBuilder stringBuilder = new StringBuilder();
for (int x = 0; x < Width; x++)
{
if (!GetEntity(GetNodeIndex(x, y), out Entity entity))
{
stringBuilder.Append(" ");
}
else
{
stringBuilder.Append(GetCharacter(entity.Type, entity.IsMine));
}
}
Console.Error.WriteLine(stringBuilder.ToString());
}
}
public char GetCharacter(EntityType type, bool? isMine)
{
bool isMineInt = isMine.HasValue && isMine.Value;
switch (type)
{
case EntityType.WALL:
return 'X';
case EntityType.ROOT:
return isMineInt ? 'R' : 'r';
case EntityType.BASIC:
return isMineInt ? 'B' : 'b';
case EntityType.TENTACLE:
return isMineInt ? 'T' : 't';
case EntityType.HARVESTER:
return isMineInt ? 'H' : 'h';
case EntityType.SPORER:
return isMineInt ? 'S' : 's';
case EntityType.A:
return 'A';
case EntityType.B:
return 'B';
case EntityType.C:
return 'C';
case EntityType.D:
return 'D';
}
throw new ArgumentException($"Type: {type} not supported");
}
public void UpdateBoard()
{
_myEntityCount = -1;
_oppEntityCount = -1;
_moveActionCache = new Dictionary<string, List<MoveAction>>();
_entityCache = new Dictionary<string, List<Entity>>();
}
public readonly struct LocationNeighbor
{
public Point2d point { get; }
public OrganDirection direction { get; }
public LocationNeighbor(int x, int y, int index, OrganDirection direction)
{
this.point = new Point2d(x, y, index);
this.direction = direction;
}
}
private Point2d[][][] _locationCache;
private int[][] _locationIndexCache = null;
private List<LocationNeighbor>[] _locationNeighbors = null;
public void InitializeBoard()
{
_locationIndexCache = new int[Width][];
for (int x = 0; x < Width; x++)
{
_locationIndexCache[x] = new int[Height];
for (int y = 0; y < Height; y++)
{
_locationIndexCache[x][y] = GetNodeIndexInternal(x, y);
}
}
_locationCache = new Point2d[Width + 2][][];
for (int x = 0; x < Width + 2; x++)
{
_locationCache[x] = new Point2d[Height + 2][];
for (int y = 0; y < Height + 2; y++)
{
_locationCache[x][y] = new Point2d[4];
for (int z = 0; z < 4; z++)
{
var nextLocation = GetNextLocationInternl(x - 1, y - 1, PossibleDirections[z]);
if (nextLocation.x > -1 && nextLocation.y > -1 && nextLocation.x < Width && nextLocation.y < Height)
{
_locationCache[x][y][z] = nextLocation;
}
else
{
_locationCache[x][y][z] = null;
}
}
}
}
_locationNeighbors = new List<LocationNeighbor>[Width * Height];
for (int x = 0; x < Width; x++)
{
for (int y = 0; y < Height; y++)
{
var index = GetNodeIndex(x, y);
var node = new Node(index);
Graph.AddNode(node);
_locationNeighbors[index] = new List<LocationNeighbor>();
for (int z = 0; z < 4; z++)
{
var location = GetNextLocation(new Point2d(x, y, GetNodeIndex(x, y)), PossibleDirections[z]);
if (ValidateLocation(location))
{
var nextIndex = GetNodeIndex(location);
node.AddLink(new Link(node, new Node(nextIndex), 1));
_locationNeighbors[index].Add(new LocationNeighbor(location.x, location.y, nextIndex, PossibleDirections[z]));
}
}
}
}
Graph.CalculateShortestPaths();
}
private int GetNodeIndexInternal(int x, int y)
{
return x * Height + y;
}
public List<LocationNeighbor> GetLocationNeighbors(int nodeIndex)
{
return _locationNeighbors[nodeIndex];
}
public List<LocationNeighbor> GetLocationNeighbors(Point2d location)
{
return _locationNeighbors[location.index];
}
public int GetNodeIndex(int x, int y)
{
return _locationIndexCache[x][y];
}
public int GetNodeIndex(Point2d location)
{
return location.index;
}
}
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
//WALL, ROOT, BASIC, TENTACLE, HARVESTER, SPORER, A, B, C, D
public enum EntityType
{
WALL = 0,
NONE,
ROOT,
BASIC,
TENTACLE,
HARVESTER,
SPORER,
A,
B,
C,
D,
}
public enum OrganDirection
{
North = 0,
South,
East,
West,
None
}
public class Entity
{
public bool? IsMine { get; set; }
public Point2d Location { get; set; }
public EntityType Type { get; set; }
public int OrganId { get; set; }
public OrganDirection OrganDirection { get; set; }
public int OrganParentId { get; set; }
public int OrganRootId { get; set; }
private bool _IsOpenSpace { get; set; }
public Entity(int x, int y, int index, string type, int owner, int organId, string organDir, int organParentId, int organRootId)
{
Location = new Point2d(x, y, index);
IsMine = owner == 1 ? true : owner == -1 ? (bool?)null : false;
Type = GetType(type);
OrganDirection = GetOrganDirection(organDir);
OrganId = organId;
OrganParentId = organParentId;
OrganRootId = organRootId;
_IsOpenSpace = IsOpenSpaceInternal();
}
public Entity(Point2d location, EntityType type, bool? isMine, int organId, int organParentId, int organRootId, OrganDirection organDirection)
{
Location = location;
IsMine = isMine;
Type = type;
OrganId = organId;
OrganParentId = organParentId;
OrganRootId = organRootId;
OrganDirection = organDirection;
_IsOpenSpace = IsOpenSpaceInternal();
}
public Entity(Entity entity)
{
this.IsMine = entity.IsMine;
this.Type = entity.Type;
this.OrganDirection = entity.OrganDirection;
this.Location = entity.Location.Clone();
this.OrganId = entity.OrganId;
this.OrganParentId = entity.OrganParentId;
this.OrganRootId = entity.OrganRootId;
_IsOpenSpace = entity._IsOpenSpace;
}
public OrganDirection GetOrganDirection(string organDir)
{
switch (organDir)
{
case "N":
return OrganDirection.North;
case "E":
return OrganDirection.East;
case "W":
return OrganDirection.West;
case "S":
return OrganDirection.South;
case "X":
return OrganDirection.None;
}
throw new ArgumentException($"Invalid direction: {organDir}", nameof(organDir));
}
public EntityType GetType(string type)
{
switch (type)
{
case "WALL":
return EntityType.WALL;
case "ROOT":
return EntityType.ROOT;
case "BASIC":
return EntityType.BASIC;
case "TENTACLE":
return EntityType.TENTACLE;
case "HARVESTER":
return EntityType.HARVESTER;
case "SPORER":
return EntityType.SPORER;
case "A":
return EntityType.A;
case "B":
return EntityType.B;
case "C":
return EntityType.C;
case "D":
return EntityType.D;
}
throw new ArgumentException($"Invalid type: {type}", nameof(type));
}
public bool IsOpenSpace()
{
return _IsOpenSpace;
}
private bool IsOpenSpaceInternal()
{
return Type == EntityType.A || Type == EntityType.B || Type == EntityType.C || Type == EntityType.D;
}
public Entity Clone()
{
return new Entity(this);
}
public bool Equals(Entity entity)
{
return entity.IsMine == IsMine && entity.OrganParentId == OrganParentId && entity.OrganRootId == OrganRootId && entity.Type == Type && entity.Location.Equals(Location) && entity.OrganId == OrganId && entity.OrganDirection == OrganDirection;
}
public override string ToString()
{
return "";
}
}
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
public enum MoveType
{
WAIT = 0,
GROW,
SPORE
};
public class MoveAction
{
public MoveType Type { get; set; }
public int OrganId { get; set; }
public Point2d Location { get; set; }
public EntityType EntityType { get; set; }
public int OrganRootId { get; set; }
public double Score { get; set; }
public OrganDirection OrganDirection { get; set; }
public MoveAction(MoveType moveType)
{
Type = moveType;
}
public static int[][] EntityCosts = new int[][]
{
  new int[]{0, 0, 0, 0 },
  new int[]{1, 1, 1, 1},
  new int[]{ 1, 0, 0, 0 },
  new int[]{0, 1, 1, 0},
  new int[]{0, 0, 1, 1 },
  new int[]{0, 1, 0, 1 }
};
public int[] GetCost()
{
return EntityCosts[EntityType - EntityType.NONE];
}
public static MoveAction CreateGrow(int organId, Point2d location, EntityType type, int organRootId, OrganDirection organDirection = OrganDirection.North)
{
var action = new MoveAction(MoveType.GROW);
action.OrganId = organId;
action.Location = location;
action.EntityType = type;
action.OrganRootId = organRootId;
action.OrganDirection = organDirection;
return action;
}
public static MoveAction CreateWait()
{
var action = new MoveAction(MoveType.WAIT);
action.EntityType = EntityType.NONE;
return action;
}
public static MoveAction CreateSpore(int sporeOrganId, Point2d location)
{
var action = new MoveAction(MoveType.SPORE);
action.OrganId = sporeOrganId;
action.Location = location;
action.EntityType = EntityType.ROOT;
return action;
}
}
public class Move
{
public MoveAction[] Actions { get; set; }
public Move()
{
}
public Move(Move move)
{
Actions = move.Actions.Select(m => m).ToArray();
}
private int[] _costs = null;
public int[] GetCost()
{
if (_costs == null)
{
_costs = new int[] { 0, 0, 0, 0 };
foreach (MoveAction action in Actions)
{
int[] actionCost = action.GetCost();
for (int i = 0; i < 4; i++)
{
_costs[i] += actionCost[i];
}
}
}
return _costs;
}
public void SetActions(MoveAction[] actions)
{
Actions = actions;
}
public Move Clone()
{
return new Move(this);
}
public override string ToString()
{
StringBuilder moveStr = new StringBuilder();
foreach (MoveAction move in Actions)
{
switch (move.Type)
{
case MoveType.GROW:
moveStr.Append("GROW " + move.OrganId + " " + move.Location.x + " " + move.Location.y + " " + move.EntityType.ToString() + " " + GetGrowDirection(move.OrganDirection) + ";");
break;
case MoveType.SPORE:
moveStr.Append("SPORE " + move.OrganId + " " + move.Location.x + " " + move.Location.y + ";");
break;
case MoveType.WAIT:
moveStr.Append("WAIT;");
break;
}
}
return moveStr.ToString().Substring(0, moveStr.Length - 1);
}
public char GetGrowDirection(OrganDirection direction)
{
switch (direction)
{
case OrganDirection.North:
return 'N';
case OrganDirection.South:
return 'S';
case OrganDirection.West:
return 'W';
case OrganDirection.East:
return 'E';
}
throw new Exception("Invalid direction");
}
public void Print()
{
foreach (string action in ToString().Split(';'))
{
Console.WriteLine(action);
}
}
}
}
//*** SourceCombiner -> original file Point2d.cs ***
namespace GameSolution.Entities
{
public class Point2d
{
public readonly int x, y, index; // Make fields readonly for better performance and clarity
// Constructor that initializes the point
public Point2d(int x, int y, int index)
{
this.x = x;
this.y = y;
this.index = index;
}
// Copy constructor (reuse the existing constructor to avoid redundancy)
public Point2d(Point2d point) : this(point.x, point.y, point.index) { }
// Clone method that uses the copy constructor
public Point2d Clone() => new Point2d(this);
// Override Equals method with a direct type check
public override bool Equals(object obj)
{
return obj is Point2d point && point.x == this.x && point.y == this.y;
}
// Override GetHashCode for better performance
public override int GetHashCode()
{
// Combine x and y in a more efficient way
unchecked // Disable overflow checking
{
return (x * 397) ^ y; // Simple prime multiplication for better hash distribution
}
}
}
}
//*** SourceCombiner -> original file GameBuilder.cs ***
namespace GameSolution.Game
{
public static class GameBuilder
{
public static GameState BuildEmptyGame(bool setNextTurn = true)
{
GameState game = new GameState();
return game;
}
public static GameState BuildWood4Game()
{
GameState game = new GameState();
Board board = new Board(18, 9);
List<Entity> entities = new List<Entity>()
{
new Entity(1, 2, board.GetNodeIndex(1, 2), "ROOT", 1, 1, "N", 1, 1),
new Entity(1, 6,board.GetNodeIndex(1, 6), "ROOT", 0, 2, "N", 2, 2),
new Entity(4, 1, board.GetNodeIndex(4, 1), "A", -1, 0, "X", 0, 0),
new Entity(6, 1, board.GetNodeIndex(6, 1), "A", -1, 0, "X", 0, 0),
new Entity(8, 2, board.GetNodeIndex(8, 2), "A", -1, 0, "X", 0, 0),
new Entity(12, 2, board.GetNodeIndex(12, 2), "A", -1, 0, "X", 0, 0),
new Entity(16, 2, board.GetNodeIndex(16, 2), "A", -1, 0, "X", 0, 0),
new Entity(3, 3, board.GetNodeIndex(3, 3), "A", -1, 0, "X", 0, 0),
new Entity(5, 3, board.GetNodeIndex(5, 3), "A", -1, 0, "X", 0, 0),
new Entity(10, 3, board.GetNodeIndex(10, 3), "A", -1, 0, "X", 0, 0),
new Entity(14, 3, board.GetNodeIndex(14, 3), "A", -1, 0, "X", 0, 0),
new Entity(4, 5, board.GetNodeIndex(4, 5), "A", -1, 0, "X", 0, 0),
new Entity(6, 5, board.GetNodeIndex(6, 5), "A", -1, 0, "X", 0, 0),
new Entity(8, 6, board.GetNodeIndex(8, 6), "A", -1, 0, "X", 0, 0),
new Entity(12, 6, board.GetNodeIndex(12, 6), "A", -1, 0, "X", 0, 0),
new Entity(16, 6, board.GetNodeIndex(16, 6), "A", -1, 0, "X", 0, 0),
new Entity(3, 7, board.GetNodeIndex(3, 7), "A", -1, 0, "X", 0, 0),
new Entity(4, 7, board.GetNodeIndex(4, 7), "A", -1, 0, "X", 0, 0),
new Entity(10, 7, board.GetNodeIndex(10, 7), "A", -1, 0, "X", 0, 0),
new Entity(14, 7, board.GetNodeIndex(14, 7), "A", -1, 0, "X", 0, 0)
};
for (int x = 0; x < 18; x++)
{
entities.Add(new Entity(x, 0, board.GetNodeIndex(x, 0), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(x, 8, board.GetNodeIndex(x, 8), "WALL", -1, 0, "X", 0, 0));
if (x != 16)
{
entities.Add(new Entity(0, 4, board.GetNodeIndex(x, 4), "WALL", -1, 0, "X", 0, 0));
}
}
for (int y = 0; y < 8; y++)
{
if (y != 4)
{
entities.Add(new Entity(0, y, board.GetNodeIndex(0, y), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(17, y, board.GetNodeIndex(17, y), "WALL", -1, 0, "X", 0, 0));
}
}
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 10, 0, 0, 0 }, new int[] { 10, 0, 0, 0 });
return game;
}
public static GameState BuildWood3Game()
{
GameState game = new GameState();
Board board = new Board(18, 9);
List<Entity> entities = new List<Entity>()
{
new Entity(1, 2, board.GetNodeIndex(1, 2), "ROOT", 1, 1, "N", 1, 1),
new Entity(1, 6, board.GetNodeIndex(1, 6), "ROOT", 0, 2, "N", 2, 2),
new Entity(4, 1, board.GetNodeIndex(4, 1), "A", -1, 0, "X", 0, 0),
new Entity(4, 5, board.GetNodeIndex(4, 5), "A", -1, 0, "X", 0, 0)
};
for (int x = 0; x < 18; x++)
{
entities.Add(new Entity(x, 0, board.GetNodeIndex(x, 0), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(x, 8, board.GetNodeIndex(x, 8), "WALL", -1, 0, "X", 0, 0));
if (x != 16)
{
entities.Add(new Entity(0, 4, board.GetNodeIndex(x, 4), "WALL", -1, 0, "X", 0, 0));
}
}
for (int y = 0; y < 8; y++)
{
if (y != 4)
{
entities.Add(new Entity(0, y, board.GetNodeIndex(0, y), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(17, y, board.GetNodeIndex(17, y), "WALL", -1, 0, "X", 0, 0));
}
}
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 10, 0, 1, 1 }, new int[] { 10, 0, 1, 1 });
return game;
}
public static GameState BuildWood2Game()
{
GameState game = new GameState();
Board board = new Board(18, 8);
List<Entity> entities = new List<Entity>()
  {
 new Entity(1, 2, board.GetNodeIndex(1, 2), "ROOT", 1, 1, "N", 1, 1),
 new Entity(16, 5, board.GetNodeIndex(16, 5), "ROOT", 0, 2, "N", 2, 2)
  };
for (int x = 0; x < 18; x++)
{
entities.Add(new Entity(x, 0, board.GetNodeIndex(x, 0), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(x, 1, board.GetNodeIndex(x, 1), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(x, 6, board.GetNodeIndex(x, 6), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(x, 7, board.GetNodeIndex(x, 7), "WALL", -1, 0, "X", 0, 0));
}
for (int y = 0; y < 8; y++)
{
entities.Add(new Entity(0, y, board.GetNodeIndex(0, y), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(17, y, board.GetNodeIndex(17, y), "WALL", -1, 0, "X", 0, 0));
}
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 50, 05, 05, 0 }, new int[] { 50, 05, 05, 0 });
return game;
}
public static GameState BuildWood1Game()
{
GameState game = new GameState();
Board board = new Board(18, 9);
List<Entity> entities = new List<Entity>()
{
new Entity(1, 2, board.GetNodeIndex(1, 2), "ROOT", 1, 1, "N", 1, 1),
new Entity(1, 6, board.GetNodeIndex(1, 6), "ROOT", 0, 2, "N", 2, 2),
new Entity(16, 1, board.GetNodeIndex(16, 1), "A", -1, 0, "X", 0, 0),
new Entity(16, 5, board.GetNodeIndex(16, 5), "A", -1, 0, "X", 0, 0)
};
for (int x = 0; x < 18; x++)
{
entities.Add(new Entity(x, 0, board.GetNodeIndex(x, 0), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(x, 8, board.GetNodeIndex(x, 8), "WALL", -1, 0, "X", 0, 0));
if (x != 16)
entities.Add(new Entity(x, 4, board.GetNodeIndex(x, 4), "WALL", -1, 0, "X", 0, 0));
}
for (int y = 1; y < 8; y++)
{
if (y != 4)
{
entities.Add(new Entity(0, y, board.GetNodeIndex(0, y), "WALL", -1, 0, "X", 0, 0));
entities.Add(new Entity(17, y, board.GetNodeIndex(17, y), "WALL", -1, 0, "X", 0, 0));
}
}
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 6, 2, 2, 3 }, new int[] { 6, 2, 2, 3 });
return game;
}
public static GameState BuildSilverGame()
{
GameState game = new GameState();
Board board = new Board(16, 8);
List<Entity> entities = new List<Entity>()
  {
 new Entity(1, 2, board.GetNodeIndex(1,2), "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 2, board.GetNodeIndex(2, 2), "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 1, board.GetNodeIndex(6, 1), "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 1, board.GetNodeIndex(9, 1), "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 1, board.GetNodeIndex(13,1), "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 1, board.GetNodeIndex(14,1), "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 2, board.GetNodeIndex(12,2), "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 3, board.GetNodeIndex(5,3), "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 3, board.GetNodeIndex(8,3), "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 4, board.GetNodeIndex(7,4), "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 4, board.GetNodeIndex(10,4), "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 5, board.GetNodeIndex(3,5), "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 5, board.GetNodeIndex(13,5), "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 5, board.GetNodeIndex(14,5), "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 6, board.GetNodeIndex(1,6), "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 6, board.GetNodeIndex(2,6), "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 6, board.GetNodeIndex(6,6), "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 6, board.GetNodeIndex(9,6), "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 1, board.GetNodeIndex(3,1), "ROOT", 1, 1, "N", 1, 1),
 new Entity(12, 6, board.GetNodeIndex(12,6), "ROOT", 0, 2, "N", 2, 2),
 new Entity(10, 1, board.GetNodeIndex(10,1), "A", -1, 0, "X", 0, 0),
 new Entity(0, 2, board.GetNodeIndex(0,2), "A", -1, 0, "X", 0, 0),
 new Entity(15, 5, board.GetNodeIndex(15,5), "A", -1, 0, "X", 0, 0),
 new Entity(5, 6, board.GetNodeIndex(5,6), "A", -1, 0, "X", 0, 0),
 new Entity(6, 0, board.GetNodeIndex(6,0), "B", -1, 0, "X", 0, 0),
 new Entity(4, 2, board.GetNodeIndex(4,2), "B", -1, 0, "X", 0, 0),
 new Entity(11, 5, board.GetNodeIndex(11,5), "B", -1, 0, "X", 0, 0),
 new Entity(9, 7, board.GetNodeIndex(9,7), "B", -1, 0, "X", 0, 0),
 new Entity(2, 1, board.GetNodeIndex(2,1), "C", -1, 0, "X", 0, 0),
 new Entity(6, 2, board.GetNodeIndex(6,2), "C", -1, 0, "X", 0, 0),
 new Entity(9, 5, board.GetNodeIndex(9,5), "C", -1, 0, "X", 0, 0),
 new Entity(13, 6, board.GetNodeIndex(13,6), "C", -1, 0, "X", 0, 0),
 new Entity(5, 0, board.GetNodeIndex(5,0), "D", -1, 0, "X", 0, 0),
 new Entity(13, 0, board.GetNodeIndex(13,0), "D", -1, 0, "X", 0, 0),
 new Entity(2, 7, board.GetNodeIndex(2,7), "D", -1, 0, "X", 0, 0),
 new Entity(10, 7, board.GetNodeIndex(10,7), "D", -1, 0, "X", 0, 0)
  };
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 6, 2, 2, 3 }, new int[] { 6, 2, 2, 3 });
return game;
}
}
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Game
{
public class GameHelper
{
GameState State { get; set; }
public GameHelper(GameState state)
{
State = state;
}
public Move GetMove()
{
Move move = new Move();
move.SetActions(new MoveAction[] { MoveAction.CreateWait() });
return move;
}
}
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Game
{
public class GameState : IGameState
{
public static int MaxTurns = 100;
public Board Board { get; private set; }
public int Turn { get; set; }
public int[] MyProtein { get; set; }
public int[] OppProtein { get; set; }
public Move? maxMove { get; set; }
public Move? minMove { get; set; }
public GameState()
{
Turn = 0;
maxMove = null;
minMove = null;
}
public GameState(GameState state)
{
Board = state.Board.Clone();
Turn = state.Turn;
MyProtein = state.MyProtein.ToArray();
OppProtein = state.OppProtein.ToArray();
maxMove = state.maxMove;
minMove = state.minMove;
}
public void SetNextTurn(Board board, int[] myProtein, int[] oppProtein)
{
Turn++;
this.Board = board;
MyProtein = myProtein;
OppProtein = oppProtein;
UpdateGameState();
}
public void UpdateGameState()
{
Board.UpdateBoard();
}
public void ApplyMove(object move, bool isMax)
{
Move m = (Move)move;
if (isMax)
{
maxMove = m;
minMove = null;
}
else
{
if (maxMove == null)
throw new Exception("Expected max to play first.");
minMove = m;
}
if (maxMove != null && minMove != null)
{
ApplyMove(maxMove, MyProtein);
ApplyMove(minMove, OppProtein);
Board.ApplyMove(maxMove, minMove);
Board.Harvest(true, MyProtein);
Board.Harvest(false, OppProtein);
Board.Attack();
SetNextTurn(Board, MyProtein, OppProtein);
}
}
public void ApplyMove(Move move, int[] proteins)
{
foreach (MoveAction action in move.Actions)
{
if (action.Type == MoveType.GROW || action.Type == MoveType.SPORE)
{
ApplyCost(proteins, action.GetCost());
if (action.EntityType == EntityType.BASIC)
{
Entity entity = Board.GetEntityByLocation(action.Location);
if (entity != null)
{
proteins[entity.Type - EntityType.A] += 3;
}
}
}
}
}
public void ApplyCost(int[] proteins, int[] cost)
{
for (int i = 0; i < 4; i++)
{
proteins[i] -= cost[i];
if (proteins[i] < 0)
{
throw new Exception("Invalid move played; proteins can't be negative");
}
}
}
public IGameState Clone()
{
return new GameState(this);
}
public bool Equals(IGameState state)
{
GameState gameState = state as GameState;
if (this.Turn != gameState.Turn)
return false;
if ((maxMove == null && gameState.maxMove != null) || (maxMove != null && gameState.maxMove == null))
return false;
if ((minMove == null && gameState.minMove != null) || (minMove != null && gameState.minMove == null))
return false;
for (int i = 0; i < 4; i++)
{
if (this.MyProtein[i] != gameState.MyProtein[i])
return false;
if (this.OppProtein[i] != gameState.OppProtein[i])
return false;
}
if (!this.Board.Equals(gameState.Board))
return false;
return true;
}
public int GetGlobalOrganId()
{
return Board.GlobalOrganId;
}
public double Evaluate(bool isMax)
{
double value;
var myEntities = Board.GetMyEntityCount();
var oppEntities = Board.GetOppEntityCount();
var myHarvestProteins = Board.GetHarvestProteins(true);
double myHarvestProteinsSum = myHarvestProteins.Sum();
var oppHarvestProteins = Board.GetHarvestProteins(false);
double oppHarvestProteinsSum = oppHarvestProteins.Sum();
bool hasAllMyProteins = myHarvestProteins.All(p => p > 1);
bool hasAllOppProteins = oppHarvestProteins.All(p => p > 1);
int myProteinBoost = hasAllMyProteins ? 20 : 0;
int oppProteinBoost = hasAllOppProteins ? 20 : 0;
var proteinValue = (myHarvestProteinsSum + myProteinBoost - oppProteinBoost - oppHarvestProteinsSum) / (myHarvestProteinsSum + oppHarvestProteinsSum + 1 + myProteinBoost + oppProteinBoost) * 0.2;
var myProtein = MyProtein.Sum();
var oppProtein = OppProtein.Sum();
value = (((double)myEntities - oppEntities) / (myEntities + oppEntities + 1) * 0.1) + (((double)myProtein - oppProtein) / (myProtein + oppProtein + 1) * 0.0001) + proteinValue;
if (value > 1 || value < -1)
Console.Error.WriteLine("Evaluation too high");
return value;
}
public object GetMove(bool isMax)
{
return isMax ? maxMove : minMove;
}
public int[] GetProteins(bool isMine)
{
return isMine ? MyProtein : OppProtein;
}
public IList GetPossibleMoves(bool isMax)
{
int[] proteins = GetProteins(isMax);
return Board.GetMoves(proteins, isMax);
}
public double? GetWinner()
{
double? winner = null;
var myEntities = Board.GetMyEntityCount();
var oppEntities = Board.GetOppEntityCount();
if (Turn < 100)
{
if (myEntities == 0 && oppEntities > 0)
winner = -1;
else if (myEntities > 0 && oppEntities == 0)
winner = 1;
else if (myEntities == 0 && oppEntities == 0)
winner = 0;
bool hasNoMyProteinsToBuild = MyProtein[0] == 0 && ((MyProtein[1] == 0 && MyProtein[2] == 0) || (MyProtein[1] == 0 && MyProtein[3] == 0) || (MyProtein[2] == 0 && MyProtein[3] == 0));
bool hasNoOppProteinsToBuild = OppProtein[0] == 0 && ((OppProtein[1] == 0 && OppProtein[2] == 0) || (OppProtein[1] == 0 && OppProtein[3] == 0) || (OppProtein[2] == 0 && OppProtein[3] == 0));
if (hasNoMyProteinsToBuild && myEntities < oppEntities)
winner = -1;
if (hasNoOppProteinsToBuild && oppEntities < myEntities)
winner = 1;
if (hasNoMyProteinsToBuild && hasNoOppProteinsToBuild && myEntities == oppEntities)
winner = 0;
}
if (Turn == 100 || Board.IsFull())
{
if (myEntities > oppEntities)
{
winner = 1;
}
else if (myEntities < oppEntities)
{
winner = -1;
}
else
{
if (MyProtein.Sum() > OppProtein.Sum())
{
winner = 1;
}
else if (MyProtein.Sum() < OppProtein.Sum())
{
winner = -1;
}
else winner = 0;
}
}
return winner;
}
public void Print()
{
Console.Error.WriteLine(Turn);
Console.Error.WriteLine(string.Join(',', MyProtein));
Console.Error.WriteLine(string.Join(',', OppProtein));
Board.Print();
}
}
}
