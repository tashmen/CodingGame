/*
 * File generated by SourceCombiner.exe using 8 source files.
 * Created On: 12/24/2024 8:47:41 AM
*/
using Algorithms.GameComponent;
using Algorithms.Graph;
using Algorithms.Space;
using Algorithms.Trees;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
static void Main(string[] args)
{
GameState gameState = new GameState();
string[] inputs;
inputs = Console.ReadLine().Split(' ');
int width = int.Parse(inputs[0]); // columns in the game grid
int height = int.Parse(inputs[1]); // rows in the game grid
Board board = null;
// game loop
while (true)
{
int entityCount = int.Parse(Console.ReadLine());
List<Entity> entities = new List<Entity>();
for (int i = 0; i < entityCount; i++)
{
inputs = Console.ReadLine().Split(' ');
int x = int.Parse(inputs[0]);
int y = int.Parse(inputs[1]);
string type = inputs[2];
int owner = int.Parse(inputs[3]);
int organId = int.Parse(inputs[4]);
string organDir = inputs[5];
int organParentId = int.Parse(inputs[6]);
int organRootId = int.Parse(inputs[7]);
Entity entity = new Entity(x, y, type, owner, organId, organDir, organParentId, organRootId);
entities.Add(entity);
}
inputs = Console.ReadLine().Split(' ');
int myA = int.Parse(inputs[0]);
int myB = int.Parse(inputs[1]);
int myC = int.Parse(inputs[2]);
int myD = int.Parse(inputs[3]);
inputs = Console.ReadLine().Split(' ');
int oppA = int.Parse(inputs[0]);
int oppB = int.Parse(inputs[1]);
int oppC = int.Parse(inputs[2]);
int oppD = int.Parse(inputs[3]);
int requiredActionsCount = int.Parse(Console.ReadLine());
int[] myProtein = new int[] { myA, myB, myC, myD };
int[] oppProtein = new int[] { oppA, oppB, oppC, oppD };
Stopwatch watch = new Stopwatch();
watch.Start();
if (gameState.Turn == 0)
{
board = new Board(width, height);
}
board.SetEntities(entities);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
gameState.SetNextTurn(board, myProtein, oppProtein);
MonteCarloTreeSearch search = new MonteCarloTreeSearch();
search.SetState(gameState, true, gameState.Turn < 5);
Move move = (Move)search.GetNextMove(watch, gameState.Turn > 1 ? 20 : 970, 20, 1);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
board.Print();
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
watch.Stop();
move.Print();
}
}
}
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 5/28/2023 8:05:44 PM
*/
namespace Algorithms.GameComponent
{
public interface IGameState
{
IList GetPossibleMoves(bool isMax);
void ApplyMove(object move, bool isMax);
object GetMove(bool isMax);
IGameState Clone();
double? GetWinner();
bool Equals(IGameState state);
double Evaluate(bool isMax);
}
}
namespace Algorithms.Trees
{
public class GameTreeNode
{
public IGameState state;
public IList moves;
public List<GameTreeNode> children;
public double wins = 0;
public double loses = 0;
public int totalPlays = 0;
public GameTreeNode parent;
public bool isMax;
public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
{
this.state = state;
moves = new List<object>(200);
var possibleMoves = state.GetPossibleMoves(isMax);
for (int i = 0; i < possibleMoves.Count; i++)
{
var obj = possibleMoves[i];
moves.Add(obj);
}
children = new List<GameTreeNode>(200);
this.parent = parent;
this.isMax = isMax;
}
public double GetScore(bool isMax)
{
double totalPlays = TotalPlays();
if (totalPlays == 0)
return 0;
if (isMax)
{
return (wins - loses) / totalPlays;
}
else
{
return (loses - wins) / totalPlays;
}
}
public int TotalPlays()
{
return totalPlays;
}
public double? GetWinner()
{
return state.GetWinner();
}
public void ApplyWinner(double? winner)
{
if (winner.HasValue)
{
if (winner > 0)
{
wins += winner.Value;
}
else if (winner < 0)
{
loses += Math.Abs(winner.Value);
}
totalPlays++;
}
}
public double Evaluate()
{
return state.Evaluate(isMax);
}
}
}
namespace Algorithms.Trees
{
public class Minimax : TreeAlgorithm
{
public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
{
double val = 99999999;
val *= RootNode.isMax ? -1 : 1;
object bestMove = null;
foreach (object move in RootNode.moves)
{
GameTreeNode child = Expand(RootNode, move);
double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
{
bestMove = move;
val = currentVal;
}
if (watch.ElapsedMilliseconds >= timeLimit)
{
break;
}
}
return bestMove;
}
public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
{
if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
{
double eval = currentNode.Evaluate();
return eval;
}
double? winner = currentNode.GetWinner();
if (winner.HasValue)
{
return winner.Value;
}
if (currentNode.isMax)
{
double value = -99999;
double minMax;
foreach (object move in currentNode.moves)
{
GameTreeNode childNode = Expand(currentNode, move);
minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
value = Math.Max(value, minMax);
alpha = Math.Max(alpha, value);
if (alpha >= beta)
{
break;
}
}
return value;
}
else
{
double value = 99999;
double minMax;
foreach (object move in currentNode.moves)
{
GameTreeNode childNode = Expand(currentNode, move);
minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
value = Math.Min(value, minMax);
beta = Math.Min(beta, value);
if (beta <= alpha)
{
break;
}
}
return value;
}
}
}
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
public class MonteCarloTreeSearch : TreeAlgorithm
{
private Random rand;
private bool printErrors;
private SearchStrategy strategy;
public enum SearchStrategy
{
Random = 0,
Sequential = 1
}
public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random)
{
rand = new Random();
printErrors = showErrors;
strategy = searchStrategy;
}
public IGameState GetRootState()
{
return RootNode.state;
}
/// <summary>
/// Get the next move
/// </summary>
/// <param name="watch">timer</param>
/// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
/// <param name="depth">How deep to run the simulations; does not impact how deep it goes in the game tree.</param>
/// <param name="numRollouts">The number of roll outs to play per expansion</param>
/// <returns></returns>
public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
{
if (exploration == null)
{
exploration = Math.Sqrt(2);
}
int count = 0;
do
{
GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
if (selectedNode == null)
{
if (printErrors)
Console.Error.WriteLine("Found no more moves!");
break;
}
object move = SelectMove(selectedNode);
GameTreeNode childNode = Expand(selectedNode, move);
double? winner = childNode.GetWinner();
if (winner.HasValue)
{
BackPropagate(childNode, winner);
}
else
{
for (int i = 0; i < numRollouts; i++)
{
var clonedState = childNode.state.Clone();
winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
if (!winner.HasValue)
break;//We simulated a game, but it didn't end so we are out of time...
BackPropagate(childNode, winner);
count++;
}
}
}
while (watch.ElapsedMilliseconds < timeLimit);
if (printErrors)
Console.Error.WriteLine($"Played {count} games!");
GameTreeNode bestChild = null;
double bestScore = double.MinValue;
for (int i = 0; i < RootNode.children.Count; i++)
{
var child = RootNode.children[i];
double score = child.GetScore(RootNode.isMax);
if (bestScore < score)
{
bestChild = child;
bestScore = score;
}
if (printErrors)
Console.Error.WriteLine($"w: {(RootNode.isMax ? child.wins : child.loses)} l: {(RootNode.isMax ? child.loses : child.wins)} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
}
if (printErrors)
Console.Error.WriteLine($"Best: w: {(RootNode.isMax ? bestChild.wins : bestChild.loses)} l: {(RootNode.isMax ? bestChild.loses : bestChild.wins)} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
return bestChild.state.GetMove(RootNode.isMax);
}
private void BackPropagate(GameTreeNode selectedNode, double? winner)
{
selectedNode.ApplyWinner(winner);
GameTreeNode tempNode = selectedNode.parent;
while (tempNode != null)
{
tempNode.ApplyWinner(winner);
tempNode = tempNode.parent;
}
}
private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
{
double? winner;
do
{
if (watch.ElapsedMilliseconds >= timeLimit)
{
return null;
}
object move = SelectMoveAtRandom(state, isMax);
state.ApplyMove(move, isMax);
if (watch.ElapsedMilliseconds >= timeLimit)
{
return null;
}
depth--;
isMax = !isMax;
winner = state.GetWinner();
}
while (!winner.HasValue && depth != 0);
if (winner.HasValue)
{
return winner;
}
if (depth == 0)
{
double eval = state.Evaluate(isMax);
if (eval > 1)
{
return 1;
}
else if (eval < -1)
return -1;
else return eval;
}
throw new InvalidOperationException("Could not find a winner for simulation!");
}
private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
{
Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
queue.Enqueue(node);
GameTreeNode tempNode;
GameTreeNode bestNode = null;
double maxValue = -1;
while (queue.Count > 0)
{
tempNode = queue.Dequeue();
if (tempNode.moves.Count == 0)
{
for (int i = 0; i < tempNode.children.Count; i++)
{
var child = tempNode.children[i];
queue.Enqueue(child);
}
}
else if (tempNode.parent != null)
{
double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
double nodeTotal = tempNode.TotalPlays();
double parentTotal = tempNode.parent.TotalPlays();
double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
if (value > maxValue)
{
maxValue = value;
bestNode = tempNode;
}
}
else return tempNode;
}
return bestNode;
}
private object SelectMoveAtRandom(IGameState state, bool isMax)
{
IList moves = state.GetPossibleMoves(isMax);
if (moves.Count == 0)
{
throw new Exception("No moves available!");
}
int index = rand.Next(0, moves.Count);
return moves[index];
}
private object SelectMove(GameTreeNode node)
{
switch (strategy)
{
case SearchStrategy.Random:
return SelectMoveAtRandom(node);
case SearchStrategy.Sequential:
return SelectMoveSequentially(node);
}
throw new InvalidOperationException("strategy not supported");
}
private object SelectMoveSequentially(GameTreeNode node)
{
object move;
if (node.moves.Count == 0)//If there are no more moves then that is a problem...
{
throw new Exception("No moves found!");
}
else
{
move = node.moves[0];
node.moves.RemoveAt(0);
}
return move;
}
private object SelectMoveAtRandom(GameTreeNode node)
{
object move;
if (node.moves.Count == 0)//If there are no more moves then that is a problem...
{
throw new Exception("No moves found!");
}
else
{
int index = rand.Next(0, node.moves.Count);
move = node.moves[index];
node.moves.RemoveAt(index);
}
return move;
}
}
}
namespace Algorithms.Trees
{
public class TreeAlgorithm
{
protected GameTreeNode RootNode;
public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
{
if (RootNode != null && findState)
{
bool isFound = false;
for (int i = 0; i < RootNode.moves.Count; i++)
{
var move = RootNode.moves[i];
Expand(RootNode, move);
}
for (int i = 0; i < RootNode.children.Count; i++)
{
var child = RootNode.children[i];
if (child.state.Equals(rootState))
{
RootNode = child;
isFound = true;
break;
}
for (int j = 0; j < child.moves.Count; j++)
{
var move = child.moves[j];
Expand(child, move);
}
for (int j = 0; j < child.children.Count; j++)
{
var descendent = child.children[j];
if (descendent.state.Equals(rootState))
{
RootNode = descendent;
isFound = true;
break;
}
}
}
if (!isFound)
{
Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
RootNode = new GameTreeNode(rootState.Clone(), isMax);
}
else
{
RootNode.parent = null;
}
}
else
{
RootNode = new GameTreeNode(rootState.Clone(), isMax);
}
}
protected GameTreeNode Expand(GameTreeNode node, object move)
{
IGameState nextState = node.state.Clone();
nextState.ApplyMove(move, node.isMax);
GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
node.children.Add(childNode);
return childNode;
}
}
}
namespace Algorithms.Utility
{
public static class BitFunctions
{
public static bool IsBitSet(long value, int location)
{
long mask = GetBitMask(location);
return (value & mask) == mask;
}
public static long SetBit(long value, int location)
{
return value | (GetBitMask(location));
}
public static long ClearBit(long value, int location)
{
return value & (~(GetBitMask(location)));
}
public static long SetOrClearBit(long value, int location, bool isSet)
{
if (isSet)
return SetBit(value, location);
return ClearBit(value, location);
}
public static int NumberOfSetBits(long i)
{
i = i - ((i >> 1) & 0x5555555555555555);
i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
}
public static long GetBitMask(int index)
{
return (long)1 << index;
}
}
}
namespace Algorithms.Space
{
public class Point2d
{
public double x;
public double y;
public Point2d(double x, double y)
{
this.x = x;
this.y = y;
}
public Point2d(Point2d point)
{
x = point.x;
y = point.y;
}
public override string ToString()
{
return $"({x},{y})";
}
public override bool Equals(object objPoint)
{
Point2d point = objPoint as Point2d;
return point.x == this.x && point.y == this.y;
}
public override int GetHashCode()
{
return Tuple.Create(x, y).GetHashCode();
}
public Point2d GetTruncatedPoint()
{
return new Point2d(Math.Truncate(this.x), Math.Truncate(this.y));
}
public Point2d GetRoundedPoint()
{
return new Point2d(Math.Round(this.x), Math.Round(this.y));
}
public Point2d GetCeilingPoint()
{
return new Point2d(Math.Ceiling(x), Math.Ceiling(y));
}
public int GetTruncatedX()
{
return (int)x;
}
public int GetTruncatedY()
{
return (int)y;
}
public double GetAngle(Point2d point)
{
return Math.Atan2(point.y - y, point.x - x);
}
public int GetManhattenDistance(Point2d point)
{
return (int)(Math.Abs(point.x - x) + Math.Abs(point.y - y));
}
public double GetDistance(Point2d point)
{
return GetDistance(point.x, point.y, x, y);
}
public Point2d GetMidPoint(Point2d point)
{
return GetMidPoint(point.x, point.y, x, y);
}
public double LengthSquared()
{
return x * x + y * y;
}
public double Length()
{
return Math.Sqrt(LengthSquared());
}
public Point2d Normalize()
{
var length = Length();
if (length == 0)
{
x = 0;
y = 0;
}
else
{
x /= length;
y /= length;
}
return this;
}
public Point2d Multiply(double scalar)
{
x *= scalar;
y *= scalar;
return this;
}
public Point2d Add(Point2d vector)
{
x += vector.x;
y += vector.y;
return this;
}
public Point2d Subtract(Point2d vector)
{
x -= vector.x;
y -= vector.y;
return this;
}
public Point2d Truncate()
{
x = GetTruncatedX();
y = GetTruncatedY();
return this;
}
public Point2d SymmetricTruncate(Point2d origin)
{
Subtract(origin).Truncate().Add(origin);
return this;
}
public Point2d GetRoundedAwayFromZeroPoint()
{
return new Point2d(Math.Round(x, MidpointRounding.AwayFromZero), Math.Round(y, MidpointRounding.AwayFromZero));
}
public Point2d Clone()
{
return new Point2d(x, y);
}
public void Fill(Point2d point)
{
x = point.x;
y = point.y;
}
public static double GetDistance(double x1, double y1, double x2, double y2)
{
return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));
}
public static Point2d GetMidPoint(double x1, double y1, double x2, double y2)
{
return new Point2d((x1 + x2) / 2, (y1 + y2) / 2);
}
}
}
namespace Algorithms.Graph
{
public class Graph
{
private Dictionary<int, INode> Nodes;
//Will hold shortest paths from a start node id to an end node id
private Dictionary<int, Dictionary<int, List<ILink>>> Paths;
public Graph()
{
Nodes = new Dictionary<int, INode>();
}
public void AddNode(INode node)
{
Nodes[node.Id] = node;
}
/// <summary>
/// Calculates all of the shortest paths in the node links
/// </summary>
public void CalculateShortestPaths()
{
Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
foreach (INode vertex in Nodes.Values)
{
InternalBuildShortestPathsFromStartNode2(vertex);
}
}
public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
{
Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
InternalBuildShortestPathsFromStartNode2(startNode, maxDistance);
}
//With a little help from Chat GPT improved the performance significantly.
private void InternalBuildShortestPathsFromStartNode2(INode startNode, double maxDistance = double.MaxValue)
{
// Initialize exploration state and paths
foreach (INode node in Nodes.Values)
{
node.IsExplored = false;
}
var minimumSpanningTree = new HashSet<ILink>();
var priorityQueue = new SortedSet<(double Distance, int StepCount, ILink Link)>(Comparer<(double Distance, int StepCount, ILink Link)>.Create((a, b) =>
{
// Compare first by distance, then by step count (in case of tie)
int result = a.Distance.CompareTo(b.Distance);
if (result != 0) return result;
result = a.StepCount.CompareTo(b.StepCount);
if (result != 0) return result;
return a.Link.EndNodeId.CompareTo(b.Link.EndNodeId);
}));
Paths[startNode.Id] = new Dictionary<int, List<ILink>>();
Paths[startNode.Id][startNode.Id] = new List<ILink>();
startNode.IsExplored = true;
// Add initial links of the startNode to the priority queue
foreach (var link in startNode.GetLinks())
{
priorityQueue.Add((link.Distance, 1, link));  // Distance, StepCount (1), Link
}
while (minimumSpanningTree.Count < Nodes.Count && priorityQueue.Count > 0)
{
// Get the link with the minimum distance and fewest steps
var (currentDist, stepCount, bestLink) = priorityQueue.Min;
priorityQueue.Remove(priorityQueue.Min);
var currentNode = Nodes[bestLink.StartNodeId];
var adjacentNode = Nodes[bestLink.EndNodeId];
if (adjacentNode.IsExplored)
{
continue; // Skip already explored nodes
}
adjacentNode.IsExplored = true;
minimumSpanningTree.Add(bestLink);
// Update paths
if (!Paths[startNode.Id].TryGetValue(currentNode.Id, out var currentPath))
{
currentPath = new List<ILink>();
}
else
{
currentPath = new List<ILink>(currentPath); // Copy the existing path
}
// Add the new link to the current path
currentPath.Add(bestLink);
// Store the complete path from the start node to the adjacent node
Paths[startNode.Id][bestLink.EndNodeId] = currentPath;
// Exit if the distance exceeds the maximum allowed
if (currentDist >= maxDistance)
return;
// Add adjacent links of the newly explored node to the queue
foreach (ILink adjacentLink in adjacentNode.GetLinks())
{
var nextNode = Nodes[adjacentLink.EndNodeId];
if (!nextNode.IsExplored)
{
// Calculate the new distance and step count for the adjacent link
double newDist = currentDist + adjacentLink.Distance;
int newStepCount = stepCount + 1;
priorityQueue.Add((newDist, newStepCount, adjacentLink));
}
}
}
}
private void InternalBuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
{
foreach (INode node in Nodes.Values)
{
node.IsExplored = false;
}
List<ILink> minimumSpanningTree = new List<ILink>();
Paths[startNode.Id] = new Dictionary<int, List<ILink>>();
Paths[startNode.Id][startNode.Id] = new List<ILink>();
minimumSpanningTree.Add(new Link(startNode.Id, startNode.Id, 0));
startNode.IsExplored = true;
int vertexCount = Nodes.Count;
double currentDist;
while (minimumSpanningTree.Count < vertexCount)
{
double minDist = 99999;
ILink bestLink = null;
ILink parentLink = null;
foreach (ILink currentLink in minimumSpanningTree)
{
INode currentNode = Nodes[currentLink.EndNodeId];
currentDist = currentLink.GetDistance(Paths[startNode.Id][currentNode.Id]);
foreach (ILink adjacent in currentNode.GetLinks())
{
INode adjacentNode = Nodes[adjacent.EndNodeId];
if (adjacentNode.IsExplored)
{
continue;//skip nodes already in minimum spanning tree
}
double distance = currentDist + adjacent.Distance;
if (distance < minDist)
{
minDist = distance;
bestLink = adjacent;
parentLink = currentLink;
}
else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
{
Paths[startNode.Id].TryGetValue(currentNode.Id, out List<ILink> pathCurrent);
int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
Paths[startNode.Id].TryGetValue(parentLink.EndNodeId, out List<ILink> pathPrevious);
int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
if (lengthCurrent < lengthPrevious)
{
minDist = distance;
bestLink = adjacent;
parentLink = currentLink;
}
}
}
}
if (parentLink == null)
{
return;//no possible paths
}
minimumSpanningTree.Add(bestLink);
Nodes[bestLink.EndNodeId].IsExplored = true;
List<ILink> currentPath = null;
if (!parentLink.EndNodeId.Equals(startNode.Id))
{
Paths[startNode.Id].TryGetValue(parentLink.EndNodeId, out currentPath);
}
if (currentPath == null)
{
currentPath = new List<ILink>();
}
else
{
currentPath = new List<ILink>(currentPath);
}
Paths[startNode.Id].Add(bestLink.EndNodeId, currentPath);
currentPath.Add(bestLink);
if (minDist >= maxDistance)
return;
}
}
/// <summary>
/// Retrieves the next node along the path from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The next node in the path</returns>
public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
{
Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startNode.Id);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
throw new InvalidOperationException();
}
INode shortest = Nodes[paths.First().EndNodeId];
Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
return shortest;
}
/// <summary>
/// Retrieves all nodes along the shortest path between two points
/// </summary>
/// <param name="startNodeId">Start node id</param>
/// <param name="endNodeId">End node id</param>
/// <returns>The full path from start to end</returns>
/// <exception cref="InvalidOperationException"></exception>
public IList<ILink> GetShortestPathAll(int startNodeId, int endNodeId)
{
Paths.TryGetValue(startNodeId, out Dictionary<int, List<ILink>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startNodeId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endNodeId, out List<ILink> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endNodeId + " start: " + startNodeId);
throw new InvalidOperationException();
}
return paths;
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node</param>
/// <param name="endId">The ending node</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(INode startNode, INode endNode)
{
return GetShortestPathDistance(startNode.Id, endNode.Id);
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<ILink>> endPoints);
if (endPoints == null)
{
return double.MaxValue;
}
endPoints.TryGetValue(endId, out List<ILink> paths);
if (paths == null)
{
return double.MaxValue;
}
return paths.First().GetDistance(paths);
}
/// <summary>
/// Retrieves the straight line distance from start to end
/// </summary>
/// <param name="startId">The starting node</param>
/// <param name="endId">The ending node</param>
/// <returns>The distance from start to end</returns>
public double GetDistance(Node startNode, Node endNode)
{
return startNode.GetLinks().Where(l => l.EndNodeId.Equals(endNode.Id)).First().Distance;
}
}
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
public class GraphLinks
{
public class Node
{
public int Id;
public double Distance;
public bool IsExplored;
public Node(int id, double distance)
{
Id = id;
Distance = distance;
}
/// <summary>
/// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
/// </summary>
/// <param name="currentDist">The current distance from the starting node</param>
/// <returns>A clone of the node with the proper distance</returns>
public Node CreateAtDistance(double currentDist)
{
return new Node(Id, currentDist + Distance);
}
}
private Dictionary<int, List<Node>> Links;
private Dictionary<int, Dictionary<int, List<Node>>> Paths;
private bool IsByDirectional;
public GraphLinks(bool isByDirectional = true)
{
Links = new Dictionary<int, List<Node>>();
IsByDirectional = isByDirectional;
}
public bool ContainsLink(int id1, int id2)
{
return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
}
/// <summary>
/// Adds a link to the list
/// </summary>
/// <param name="id1">First id</param>
/// <param name="id2">Second id</param>
/// <param name="distance">The distance between the two nodes</param>
public void AddLink(int id1, int id2, double distance)
{
//Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
if (ContainsLink(id1, id2))
return;
AddLinkInternal(id1, id2, distance);
if (IsByDirectional)
AddLinkInternal(id2, id1, distance);
}
public void RemoveLink(int id1, int id2)
{
Links[id1].RemoveAll(n => n.Id == id2);
Links[id2].RemoveAll(n => n.Id == id1);
}
/// <summary>
/// Calculates all of the shortest paths in the node links
/// </summary>
public void CalculateShortestPaths()
{
Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
List<int> vertices = Links.Keys.ToList();
int vertexCount = vertices.Count;
foreach (int vertex in vertices)
{
CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
}
}
/// <summary>
/// Calculates the shortest paths from a start node
/// </summary>
/// <param name="startNode">id of the start node</param>
/// <param name="maxDistance">the fartheset distance to travel</param>
public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
{
Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
}
/// <summary>
/// Calculates the shortest paths from the start node to all other nodes
/// </summary>
/// <param name="startNode">The starting id</param>
/// <param name="vertexCount">The number of nodes</param>
/// <param name="maxDistance">the farthest distance to travel</param>
private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
{
List<Node> minimumSpanningTree = new List<Node>();
//Console.Error.WriteLine("Starting with " + startNode);
double currentDist = 0;
Paths[startNode] = new Dictionary<int, List<Node>>();
minimumSpanningTree.Add(new Node(startNode, currentDist));
while (minimumSpanningTree.Count < vertexCount)
{
double minDist = 99999;
Node bestNode = null;
Node parentNode = null;
foreach (Node currentNode in minimumSpanningTree)
{
currentDist = currentNode.Distance;
//Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
foreach (Node adjacent in GetLinks(currentNode.Id))
{
if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
{
adjacent.IsExplored = true;
continue;//skip nodes already in minimum spanning tree
}
double distance = currentDist + adjacent.Distance;
if (distance < minDist)
{
minDist = distance;
bestNode = adjacent.CreateAtDistance(currentDist);
parentNode = currentNode;
}
else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
{
Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
if (lengthCurrent < lengthPrevious)
{
minDist = distance;
bestNode = adjacent.CreateAtDistance(currentDist);
parentNode = currentNode;
}
}
}
}
if (parentNode == null)
{
return;//no possible paths
}
minimumSpanningTree.Add(bestNode);
List<Node> currentPath = null;
if (parentNode.Id != startNode)
{
Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
}
if (currentPath == null)
{
currentPath = new List<Node>();
}
else
{
currentPath = new List<Node>(currentPath);
}
Paths[startNode].Add(bestNode.Id, currentPath);
currentPath.Add(bestNode);
/*
if (startNode == 0)
{
Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
}
*/
if (minDist >= maxDistance)
return;
}
}
/// <summary>
/// Retrieves the links that are adjacent to the given node
/// </summary>
/// <param name="id">The node id</param>
/// <returns></returns>
public List<Node> GetLinks(int id)
{
return Links[id];
}
public Dictionary<int, List<Node>> GetPaths(int startId)
{
return Paths[startId];
}
/// <summary>
/// Retrieves the straight line distance from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance from start to end</returns>
public double GetDistance(int startId, int endId)
{
return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
return 99999;
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
return 99999;
}
return paths.Last().Distance;
}
/// <summary>
/// Retrieves the next node along the path from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The factory id that is first in the path</returns>
public int GetShortestPath(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
throw new InvalidOperationException();
}
int shortest = paths.First().Id;
Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
return shortest;
}
/// <summary>
/// Retrieves the full path from start to end
/// </summary>
/// <param name="startId">the start id</param>
/// <param name="endId">the end id</param>
/// <returns>The full path</returns>
public List<Node> GetShortestPathAll(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
throw new InvalidOperationException();
}
return paths;
}
//Adds links to the node links
private void AddLinkInternal(int startNode, int endNode, double distance)
{
List<Node> nodeLinks;
if (Links.ContainsKey(startNode))
{
nodeLinks = Links[startNode];
}
else
{
nodeLinks = new List<Node>();
Links[startNode] = nodeLinks;
}
nodeLinks.Add(new Node(endNode, distance));
}
}
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
public interface INode
{
int Id { get; }
bool IsExplored { get; set; }
List<ILink> GetLinks();
}
public class Node : INode
{
public int Id { get; private set; }
public bool IsExplored { get; set; }
private List<ILink> Links;
public Node(int id)
{
Id = id;
IsExplored = false;
Links = new List<ILink>();
}
public void AddLink(ILink link)
{
Links.Add(link);
}
public List<ILink> GetLinks()
{
return Links;
}
public bool Equals(INode node)
{
return node.Id == Id;
}
}
public interface ILink
{
int StartNodeId { get; }
int EndNodeId { get; }
double Distance { get; }
double GetDistance(List<ILink> currentPath);
}
public class Link : ILink
{
public int StartNodeId { get; private set; }
public int EndNodeId { get; private set; }
public double Distance { get; private set; }
public Link(int startNodeId, int endNodeId, double distance)
{
StartNodeId = startNodeId;
EndNodeId = endNodeId;
Distance = distance;
}
public Link(INode startNode, INode endNode, double distance)
{
StartNodeId = startNode.Id;
EndNodeId = endNode.Id;
Distance = distance;
}
public double GetDistance(List<ILink> currentPath)
{
double distance = 0;
foreach (ILink link in currentPath)
{
distance += link.Distance;
}
return distance;
}
}
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
public class Board
{
public int Width { get; private set; }
public int Height { get; private set; }
private Entity[] Entities { get; set; }
public int GlobalOrganId { get; set; } = -1;
public Graph Graph { get; set; }
public static OrganDirection[] PossibleDirections = new OrganDirection[] { OrganDirection.North, OrganDirection.South, OrganDirection.East, OrganDirection.West };
public Board(int width, int height)
{
Width = width;
Height = height;
Entities = new Entity[Width * Height];
Graph = new Graph();
InitializeBoard();
UpdateBoard();
}
public Board(Board board)
{
Width = board.Width;
Height = board.Height;
Entities = board.Entities.Select(e => e == null ? null : e.Clone()).ToArray();
GlobalOrganId = board.GlobalOrganId;
Graph = board.Graph;
_entityCache = board._entityCache;
_moveActionCache = board._moveActionCache;
_myEntityCount = board._myEntityCount;
_oppEntityCount = board._oppEntityCount;
_locationCache = board._locationCache;
_locationIndexCache = board._locationIndexCache;
UpdateBoard();
}
public bool Equals(Board board)
{
if (Width != board.Width || Height != board.Height)
return false;
for (int x = 0; x < Width; x++)
{
for (int y = 0; y < Height; y++)
{
board.GetEntity(GetNodeIndex(x, y), out Entity entity);
GetEntity(GetNodeIndex(x, y), out Entity currentEntity);
if (entity == null && currentEntity == null)
continue;
if (entity == null && currentEntity != null)
return false;
if (entity != null && currentEntity == null)
return false;
else if (!entity.Equals(currentEntity))
return false;
}
}
return true;
}
public void Attack()
{
var tentacles = GetEntitiesList().Where(e => e.Type == EntityType.TENTACLE);
List<Entity> deadEntities = new List<Entity>();
foreach (Entity tentacle in tentacles)
{
if (GetEntityWithDirection(tentacle.Location, tentacle.OrganDirection, out Entity entity) && entity.IsMine.HasValue && entity.IsMine != tentacle.IsMine)
{
deadEntities.Add(entity);
}
}
foreach (Entity deadEntity in deadEntities)
{
var deathToChildren = GetEntitiesList().Where(e => e.OrganParentId == deadEntity.OrganId);
foreach (Entity kill in deathToChildren)
{
Entities[GetNodeIndex(kill.Location)] = null;
}
}
}
public void ApplyMove(Move myMove, Move oppMove)
{
foreach (MoveAction action in myMove.Actions)
{
if (action.Type != MoveType.WAIT)
{
var collisionActions = oppMove.Actions.Where(a => (a.Type == MoveType.GROW || a.Type == MoveType.SPORE) && a.Location.Equals(action.Location));
if (collisionActions.Count() > 0)
{
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, EntityType.WALL, null, 0, 0, 0, OrganDirection.None);
}
else
{
ApplyAction(action, true);
}
}
}
foreach (MoveAction action in oppMove.Actions)
{
ApplyAction(action, false);
}
}
public void ApplyAction(MoveAction action, bool isMine)
{
switch (action.Type)
{
case MoveType.GROW:
Entity growEntity = Entities[GetNodeIndex(action.Location)];
if (growEntity == null || growEntity.IsOpenSpace())
{
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, action.EntityType, isMine, GlobalOrganId++, action.OrganId, action.OrganRootId, action.OrganDirection);
}
break;
case MoveType.SPORE:
Entity sporeEntity = Entities[GetNodeIndex(action.Location)];
if (sporeEntity == null || sporeEntity.IsOpenSpace())
{
var organId = GlobalOrganId++;
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, action.EntityType, isMine, organId, organId, organId, action.OrganDirection);
}
break;
}
}
public List<Move> GetMoves(int[] proteins, bool isMine)
{
var moves = new List<Move>();
var rootEntities = GetRootEntities(isMine);
rootEntities.Sort((e1, e2) => e2.OrganId.CompareTo(e1.OrganId));
var organismCount = rootEntities.Count();
MoveAction[][] organismToMoveActions = new MoveAction[organismCount][];
int i = 0;
int maxOrgans = 3;//Put a limit on the number of organs we calculate moves for as this is exploding the action space
foreach (Entity root in rootEntities)
{
var moveActions = new List<MoveAction>
{
MoveAction.CreateWait()
};
if (maxOrgans > 0)
{
bool canHarvest = false;
if (proteins[2] > 0 && proteins[3] > 0)
{
var harvestActions = GetHarvestMoveActions(root.OrganRootId, isMine);
moveActions.AddRange(harvestActions);
canHarvest = harvestActions.Count > 0;
}
if (!canHarvest && proteins[0] > 0)
{
moveActions.AddRange(GetGrowBasicMoveActions(root.OrganRootId, isMine));
}
if (!canHarvest && proteins[1] > 0 && proteins[2] > 0)
{
moveActions.AddRange(GetTentacleMoveActions(root.OrganRootId, isMine, moveActions.Count > 1));
}
if (!canHarvest && proteins[1] > 0 && proteins[3] > 0)
{
moveActions.AddRange(GetSporerMoveActions(root.OrganRootId, isMine));
}
bool canRoot = true;
for (int j = 0; j < 4; j++)
{
if (proteins[j] <= 0)
{
canRoot = false;
break;
}
}
if (!canHarvest && canRoot)
{
moveActions.AddRange(GetSporeMoveActions(root.OrganRootId, isMine));
}
}
organismToMoveActions[i] = moveActions.ToArray();
i++;
maxOrgans--;
}
if (organismCount > 0)
{
var theMoves = CartesianProduct(organismToMoveActions);
bool hasSufficientProteins = (proteins[0] > organismCount || proteins[0] == 0) && (proteins[1] > organismCount || proteins[1] == 0) && (proteins[2] > organismCount || proteins[2] == 0) && (proteins[3] > organismCount || proteins[3] == 0);
foreach (MoveAction[] actions in theMoves)
{
var move = new Move();
move.SetActions(actions);
if (hasSufficientProteins || ValidateCost(proteins, move))
{
moves.Add(move);
}
}
}
else
{
foreach (MoveAction[] actions in organismToMoveActions)
{
var move = new Move();
move.AddAction(actions.First());
moves.Add(move);
}
}
return moves;
}
public bool ValidateCost(int[] proteins, Move move)
{
int[] theCosts = move.GetCost();
for (int i = 0; i < 4; i++)
{
if (proteins[i] < theCosts[i])
return false;
}
return true;
}
//slower
public static IEnumerable<MoveAction[]> CartesianProductRecursive(MoveAction[][] arrays)
{
IEnumerable<MoveAction[]> Helper(int depth)
{
if (depth == arrays.Length)
{
yield return new MoveAction[0];
yield break;
}
foreach (var item in arrays[depth])
{
foreach (var product in Helper(depth + 1))
{
yield return new[] { item }.Concat(product).ToArray();
}
}
}
return Helper(0);
}
//slower
public static IEnumerable<MoveAction[]> CartesianProductLinq(MoveAction[][] arrays)
{
return arrays.Aggregate(
  new List<MoveAction[]> { new MoveAction[0] }, // Seed
  (acc, array) => acc.SelectMany(
 product => array.Select(item => product.Concat(new[] { item }).ToArray())
  ).ToList()
);
}
public static IEnumerable<T[]> CartesianProduct<T>(T[][] sequences)
{
// Convert sequences to arrays for efficient access
var arrays = sequences.Select(s => s.ToArray()).ToArray();
// Early exit if no input sequences
if (arrays.Length == 0)
yield break;
// Stack to hold indices
var indices = new int[arrays.Length];
while (true)
{
// Yield the current combination
yield return indices.Select((index, i) => arrays[i][index]).ToArray();
// Increment the indices from the rightmost sequence
int position = arrays.Length - 1;
while (position >= 0)
{
indices[position]++;
if (indices[position] < arrays[position].Length)
break;
// Reset this position and carry over to the next
indices[position] = 0;
position--;
}
// Break if we've exhausted all combinations
if (position < 0)
yield break;
}
}
public List<MoveAction> GetSporeMoveActions(int organRootId, bool isMine)
{
List<MoveAction> moveActions = new List<MoveAction>();
IEnumerable<Entity> sporers = GetSporerEntities(organRootId, isMine);
foreach (Entity sporer in sporers)
{
var location = sporer.Location;
while (true)
{
if (IsOpenSpace(location, sporer.OrganDirection))
{
location = GetNextLocation(location, sporer.OrganDirection);
if (IsHarvestWithin3Spaces(location))
{
moveActions.Add(MoveAction.CreateSpore(sporer.OrganId, location));
}
}
else
{
break;
}
}
}
return moveActions;
}
public List<MoveAction> GetSporerMoveActions(int organRootId, bool isMine)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowBasicMoveActions(organRootId, isMine);
foreach (MoveAction growAction in growMoveActions)
{
foreach (OrganDirection sporerDirection in PossibleDirections)
{
var location = growAction.Location;
bool isOpen = true;
for (int i = 0; i < 4; i++)
{
if (!IsOpenSpace(location, sporerDirection))
{
isOpen = false;
break;
}
location = GetNextLocation(location, sporerDirection);
}
if (isOpen)
{
moveActions.Add(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.SPORER, growAction.OrganRootId, sporerDirection));
}
}
}
return moveActions;
}
public List<MoveAction> GetTentacleMoveActions(int organRootId, bool isMine, bool hasActions)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowBasicMoveActions(organRootId, isMine);
foreach (MoveAction growAction in growMoveActions)
{
foreach (OrganDirection tentacleDirection in PossibleDirections)
{
if (IsOpponentOrEmptySpace(growAction.Location, tentacleDirection, isMine))
{
if (!hasActions || IsOpponentWithin3Spaces(growAction.Location, isMine))
{
moveActions.Add(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.TENTACLE, growAction.OrganRootId, tentacleDirection));
}
}
}
}
return moveActions;
}
public bool IsFull()
{
foreach (Entity entity in Entities)
{
if (entity == null)
{
return false;
}
}
return true;
}
private Dictionary<string, List<MoveAction>> _moveActionCache = new Dictionary<string, List<MoveAction>>();
public List<MoveAction> GetGrowBasicMoveActions(int organRootId, bool isMine)
{
var key = organRootId.ToString() + isMine.ToString();
if (!_moveActionCache.TryGetValue(key, out List<MoveAction> moveActions))
{
moveActions = new List<MoveAction>();
var potentialMoveActions = new List<MoveAction>();
var entities = GetEntitiesByRoot(organRootId, isMine);
foreach (Entity entity in entities)
{
foreach (OrganDirection direction in PossibleDirections)
{
if (IsOpenSpace(entity.Location, direction))
{
var moveAction = MoveAction.CreateGrow(entity.OrganId, GetNextLocation(entity.Location, direction), EntityType.BASIC, entity.OrganRootId);
if (!IsHarvesting(GetNextLocation(entity.Location, direction), isMine))
{
moveActions.Add(moveAction);
}
else
{
potentialMoveActions.Add(moveAction);
}
}
}
}
if (moveActions.Count == 0)
{
moveActions = potentialMoveActions;
}
_moveActionCache[key] = moveActions;
}
int maxMoves = 5;
if (moveActions.Count > maxMoves)
{
var oppRootEntities = GetEntitiesByRoot(organRootId, !isMine);
foreach (Entity oppRoot in oppRootEntities)
{
moveActions.Sort((m1, m2) => Graph.GetShortestPathDistance(GetNodeIndex(oppRoot.Location), GetNodeIndex(m1.Location)).CompareTo(Graph.GetShortestPathDistance(GetNodeIndex(oppRoot.Location), GetNodeIndex(m2.Location))));
moveActions = moveActions.Take(maxMoves).ToList();
}
}
return moveActions;
}
public List<MoveAction> GetHarvestMoveActions(int organRootId, bool isMine)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowBasicMoveActions(organRootId, isMine);
foreach (MoveAction growAction in growMoveActions)
{
foreach (OrganDirection direction in PossibleDirections)
{
if (IsHarvestSpace(growAction.Location, direction) && !IsHarvesting(GetNextLocation(growAction.Location, direction), isMine))
{
var harvestAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, direction);
//Prioritize A harvests
if (GetEntityWithDirection(growAction.Location, direction, out Entity entity) && entity.Type == EntityType.A)
{
return new List<MoveAction>()
{
harvestAction
};
}
moveActions.Add(harvestAction);
}
}
}
return moveActions;
}
public bool IsHarvesting(Point2d location, bool isMine)
{
if (ValidateLocation(location) && GetEntity(location, out Entity harvestSpace) && harvestSpace.IsOpenSpace())
{
foreach (OrganDirection direction in PossibleDirections)
{
var locationCheck = GetNextLocation(location, direction);
if (ValidateLocation(locationCheck) && GetEntity(locationCheck, out Entity entity) && entity.Type == EntityType.HARVESTER && entity.IsMine.HasValue && entity.IsMine == isMine && entity.OrganDirection == GetOpposingDirection(direction))
{
return true;
}
}
}
return false;
}
public OrganDirection GetOpposingDirection(OrganDirection direction)
{
switch (direction)
{
case OrganDirection.North:
return OrganDirection.South;
case OrganDirection.South:
return OrganDirection.North;
case OrganDirection.East:
return OrganDirection.West;
case OrganDirection.West:
return OrganDirection.East;
}
throw new Exception("No direction given");
}
public bool IsHarvestWithin3Spaces(Point2d location)
{
var harvestEntities = GetHarvestableEntities();
foreach (var entity in harvestEntities)
{
if (location.Equals(entity.Location))
return true;
double distance = Graph.GetShortestPathDistance(GetNodeIndex(location), GetNodeIndex(entity.Location));
if (distance <= 3)
{
return true;
}
}
return false;
}
public bool IsOpponentWithin3Spaces(Point2d location, bool isMine)
{
var oppEntities = GetEntities(!isMine);
foreach (var oppEntity in oppEntities)
{
double distance = Graph.GetShortestPathDistance(GetNodeIndex(location), GetNodeIndex(oppEntity.Location));
if (distance <= 3)
return true;
}
return false;
}
public bool IsOpponentOrEmptySpace(Point2d location, OrganDirection direction, bool isMine)
{
return ValidateLocation(location, direction) && (!GetEntityWithDirection(location, direction, out Entity entity) || (entity.IsMine.HasValue && entity.IsMine != isMine));
}
public bool IsOpponentSpace(Point2d location, OrganDirection direction, bool isMine)
{
return ValidateLocation(location, direction) && GetEntityWithDirection(location, direction, out Entity entity) && entity.IsMine != isMine;
}
public bool IsHarvestSpace(Point2d location, OrganDirection nextDirection)
{
return ValidateLocation(location, nextDirection) && GetEntityWithDirection(location, nextDirection, out Entity entity) && entity.IsOpenSpace();
}
public bool IsOpenSpace(Point2d location, OrganDirection nextDirection)
{
return ValidateLocation(location, nextDirection) && (!GetEntityWithDirection(location, nextDirection, out Entity entity) || entity.IsOpenSpace());
}
public bool ValidateLocation(Point2d location, OrganDirection nextDirection)
{
return ValidateLocation(GetNextLocation(location, nextDirection));
}
public bool ValidateLocation(Point2d location)
{
return location != null;
}
public bool GetEntityWithDirection(Point2d currentLocation, OrganDirection nextDirection, out Entity entity)
{
return GetEntity(GetNextLocation(currentLocation, nextDirection), out entity);
}
public Point2d GetNextLocation(Point2d currentLocation, OrganDirection nextDirection)
{
return _locationCache[(int)currentLocation.x + 1][(int)currentLocation.y + 1][(int)nextDirection];
}
private Point2d GetNextLocationInternl(Point2d currentLocation, OrganDirection nextDirection)
{
switch (nextDirection)
{
case OrganDirection.North:
return new Point2d(currentLocation.x, currentLocation.y - 1);
case OrganDirection.South:
return new Point2d(currentLocation.x, currentLocation.y + 1);
case OrganDirection.East:
return new Point2d(currentLocation.x + 1, currentLocation.y);
case OrganDirection.West:
return new Point2d(currentLocation.x - 1, currentLocation.y);
default:
return currentLocation;
}
}
public void Harvest(bool isMine, int[] proteins)
{
var harvesters = GetEntities(isMine).Where(e => e.Type == EntityType.HARVESTER);
List<int> harvestedLocations = new List<int>();
foreach (Entity harvester in harvesters)
{
if (GetEntityWithDirection(harvester.Location, harvester.OrganDirection, out Entity entity) && entity.IsOpenSpace() && !harvestedLocations.Contains(GetNodeIndex(entity.Location)))
{
proteins[entity.Type - EntityType.A]++;
harvestedLocations.Add(GetNodeIndex(entity.Location));
}
}
}
public bool GetEntity(int entityIndex, out Entity entity)
{
entity = Entities[entityIndex];
if (entity == null)
return false;
return true;
}
public bool GetEntity(Point2d location, out Entity entity)
{
return GetEntity(GetNodeIndex(location), out entity);
}
public List<Entity> GetHarvestableEntities()
{
return GetEntitiesList().Where(e => e.IsOpenSpace()).ToList();
}
public Entity GetEntityByLocation(Point2d location)
{
Entity entity = null;
GetEntity(location, out entity);
return entity;
}
public List<Entity> GetRootEntities(bool isMine)
{
return GetEntities(isMine).Where(e => e.Type == EntityType.ROOT).ToList();
}
public List<Entity> GetSporerEntities(int organRootId, bool isMine)
{
return GetEntitiesByRoot(organRootId, isMine).Where(e => e.Type == EntityType.SPORER).ToList();
}
public List<Entity> GetEntitiesList()
{
var key = "all";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = Entities.Where(e => e != null).ToList();
}
return entities;
}
private Dictionary<string, List<Entity>> _entityCache = new Dictionary<string, List<Entity>>();
public List<Entity> GetEntities(bool isMine)
{
var key = isMine.ToString();
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = GetEntitiesList().Where(e => e.IsMine.HasValue && e.IsMine == isMine).ToList();
}
return entities;
}
public List<Entity> GetEntitiesByRoot(int organRootId, bool isMine)
{
var key = organRootId.ToString() + isMine.ToString();
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = GetEntities(isMine).Where(e => e.OrganRootId == organRootId).ToList();
}
return entities;
}
public Entity[] GetEntities()
{
return Entities;
}
private int _myEntityCount = -1;
public int GetMyEntityCount()
{
if (_myEntityCount < 0)
{
_myEntityCount = GetEntities(true).Count();
}
return _myEntityCount;
}
private int _oppEntityCount = -1;
public int GetOppEntityCount()
{
if (_oppEntityCount < 0)
{
_oppEntityCount = GetEntities(false).Count();
}
return _oppEntityCount;
}
public void SetEntities(IList<Entity> entities)
{
UpdateBoard();
Array.Clear(Entities);
foreach (Entity entity in entities)
{
Entities[GetNodeIndex(entity.Location)] = entity;
if (entity.OrganId > 0 && GlobalOrganId <= entity.OrganId)
{
GlobalOrganId = entity.OrganId + 1;
}
}
}
public Board Clone()
{
return new Board(this);
}
public double? GetWinner()
{
return null;
}
public void Print()
{
for (int y = 0; y < Height; y++)
{
StringBuilder stringBuilder = new StringBuilder();
for (int x = 0; x < Width; x++)
{
if (!GetEntity(GetNodeIndex(x, y), out Entity entity))
{
stringBuilder.Append(" ");
}
else
{
stringBuilder.Append(GetCharacter(entity.Type, entity.IsMine));
}
}
Console.Error.WriteLine(stringBuilder.ToString());
}
}
public char GetCharacter(EntityType type, bool? isMine)
{
bool isMineInt = isMine.HasValue && isMine.Value;
switch (type)
{
case EntityType.WALL:
return 'X';
case EntityType.ROOT:
return isMineInt ? 'R' : 'r';
case EntityType.BASIC:
return isMineInt ? 'B' : 'b';
case EntityType.TENTACLE:
return isMineInt ? 'T' : 't';
case EntityType.HARVESTER:
return isMineInt ? 'H' : 'h';
case EntityType.SPORER:
return isMineInt ? 'S' : 's';
case EntityType.A:
return 'A';
case EntityType.B:
return 'B';
case EntityType.C:
return 'C';
case EntityType.D:
return 'D';
}
throw new ArgumentException($"Type: {type} not supported");
}
public void UpdateBoard()
{
_myEntityCount = -1;
_oppEntityCount = -1;
_moveActionCache = new Dictionary<string, List<MoveAction>>();
_entityCache = new Dictionary<string, List<Entity>>();
}
public Point2d[][][] _locationCache;
public void InitializeBoard()
{
_locationCache = new Point2d[Width + 2][][];
for (int x = 0; x < Width + 2; x++)
{
_locationCache[x] = new Point2d[Height + 2][];
for (int y = 0; y < Height + 2; y++)
{
_locationCache[x][y] = new Point2d[4];
for (int z = 0; z < 4; z++)
{
var nextLocation = GetNextLocationInternl(new Point2d(x - 1, y - 1), PossibleDirections[z]);
if (nextLocation.x > -1 && nextLocation.y > -1 && nextLocation.x < Width && nextLocation.y < Height)
{
_locationCache[x][y][z] = nextLocation;
}
else
{
_locationCache[x][y][z] = null;
}
}
}
}
_locationIndexCache = new int[Width][];
for (int x = 0; x < Width; x++)
{
_locationIndexCache[x] = new int[Height];
for (int y = 0; y < Height; y++)
{
_locationIndexCache[x][y] = x * Height + y;
}
}
for (int x = 0; x < Width; x++)
{
for (int y = 0; y < Height; y++)
{
var node = new Node(GetNodeIndex(new Point2d(x, y)));
Graph.AddNode(node);
for (int z = 0; z < 4; z++)
{
var location = GetNextLocation(new Point2d(x, y), PossibleDirections[z]);
if (location != null)
{
node.AddLink(new Link(node, new Node(GetNodeIndex(location)), 1));
}
}
}
}
Graph.CalculateShortestPaths();
}
private int[][] _locationIndexCache = null;
public int GetNodeIndex(int x, int y)
{
return _locationIndexCache[x][y];
}
public int GetNodeIndex(Point2d location)
{
int x = location.GetTruncatedX();
int y = location.GetTruncatedY();
return GetNodeIndex(x, y);
}
}
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
//WALL, ROOT, BASIC, TENTACLE, HARVESTER, SPORER, A, B, C, D
public enum EntityType
{
WALL = 0,
NONE,
ROOT,
BASIC,
TENTACLE,
HARVESTER,
SPORER,
A,
B,
C,
D,
}
public enum OrganDirection
{
North = 0,
South,
East,
West,
None
}
public class Entity
{
public bool? IsMine { get; set; }
public Point2d Location { get; set; }
public EntityType Type { get; set; }
public int OrganId { get; set; }
public OrganDirection OrganDirection { get; set; }
public int OrganParentId { get; set; }
public int OrganRootId { get; set; }
public Entity(int x, int y, string type, int owner, int organId, string organDir, int organParentId, int organRootId)
{
Location = new Point2d(x, y);
IsMine = owner == 1 ? true : owner == -1 ? (bool?)null : false;
Type = GetType(type);
OrganDirection = GetOrganDirection(organDir);
OrganId = organId;
OrganParentId = organParentId;
OrganRootId = organRootId;
}
public Entity(Point2d location, EntityType type, bool? isMine, int organId, int organParentId, int organRootId, OrganDirection organDirection)
{
Location = location;
IsMine = isMine;
Type = type;
OrganId = organId;
OrganParentId = organParentId;
OrganRootId = organRootId;
OrganDirection = organDirection;
}
public Entity(Entity entity)
{
this.IsMine = entity.IsMine;
this.Type = entity.Type;
this.OrganDirection = entity.OrganDirection;
this.Location = entity.Location.Clone();
this.OrganId = entity.OrganId;
this.OrganParentId = entity.OrganParentId;
this.OrganRootId = entity.OrganRootId;
}
public OrganDirection GetOrganDirection(string organDir)
{
switch (organDir)
{
case "N":
return OrganDirection.North;
case "E":
return OrganDirection.East;
case "W":
return OrganDirection.West;
case "S":
return OrganDirection.South;
case "X":
return OrganDirection.None;
}
throw new ArgumentException($"Invalid direction: {organDir}", nameof(organDir));
}
public EntityType GetType(string type)
{
switch (type)
{
case "WALL":
return EntityType.WALL;
case "ROOT":
return EntityType.ROOT;
case "BASIC":
return EntityType.BASIC;
case "TENTACLE":
return EntityType.TENTACLE;
case "HARVESTER":
return EntityType.HARVESTER;
case "SPORER":
return EntityType.SPORER;
case "A":
return EntityType.A;
case "B":
return EntityType.B;
case "C":
return EntityType.C;
case "D":
return EntityType.D;
}
throw new ArgumentException($"Invalid type: {type}", nameof(type));
}
public bool IsOpenSpace()
{
return Type == EntityType.A || Type == EntityType.B || Type == EntityType.C || Type == EntityType.D;
}
public Entity Clone()
{
return new Entity(this);
}
public bool Equals(Entity entity)
{
return entity.IsMine == IsMine && entity.OrganParentId == OrganParentId && entity.OrganRootId == OrganRootId && entity.Type == Type && entity.Location.Equals(Location) && entity.OrganId == OrganId && entity.OrganDirection == OrganDirection;
}
public override string ToString()
{
return "";
}
}
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
public enum MoveType
{
WAIT = 0,
GROW,
SPORE
};
public class MoveAction
{
public MoveType Type { get; set; }
public int OrganId { get; set; }
public Point2d Location { get; set; }
public EntityType EntityType { get; set; }
public int OrganRootId { get; set; }
public OrganDirection OrganDirection { get; set; }
public MoveAction(MoveType moveType)
{
Type = moveType;
}
public static int[][] EntityCosts = new int[][]
{
  new int[]{0, 0, 0, 0 },
  new int[]{1, 1, 1, 1},
  new int[]{ 1, 0, 0, 0 },
  new int[]{0, 1, 1, 0},
  new int[]{0, 0, 1, 1 },
  new int[]{0, 1, 0, 1 }
};
public int[] GetCost()
{
return EntityCosts[EntityType - EntityType.NONE];
}
public static MoveAction CreateGrow(int organId, Point2d location, EntityType type, int organRootId, OrganDirection organDirection = OrganDirection.North)
{
var action = new MoveAction(MoveType.GROW);
action.OrganId = organId;
action.Location = location;
action.EntityType = type;
action.OrganRootId = organRootId;
action.OrganDirection = organDirection;
return action;
}
public static MoveAction CreateWait()
{
var action = new MoveAction(MoveType.WAIT);
action.EntityType = EntityType.NONE;
return action;
}
public static MoveAction CreateSpore(int sporeOrganId, Point2d location)
{
var action = new MoveAction(MoveType.SPORE);
action.OrganId = sporeOrganId;
action.Location = location;
action.EntityType = EntityType.ROOT;
return action;
}
}
public class Move
{
public MoveAction[] Actions { get; set; }
private int _actionIndex = 0;
public Move()
{
Actions = new MoveAction[50];
_actionIndex = 0;
}
public Move(Move move)
{
Actions = move.Actions.Select(m => m).ToArray();
_actionIndex = move.Actions.Count(a => a != null);
}
private int[] _costs = null;
public int[] GetCost()
{
if (_costs == null)
{
_costs = new int[] { 0, 0, 0, 0 };
foreach (MoveAction action in Actions)
{
int[] actionCost = action.GetCost();
for (int i = 0; i < 4; i++)
{
_costs[i] += actionCost[i];
}
}
}
return _costs;
}
public void AddAction(MoveAction move)
{
Actions[_actionIndex++] = move;
}
public void SetActions(MoveAction[] actions)
{
Actions = actions;
_actionIndex = actions.Count(a => a != null);
}
public Move Clone()
{
return new Move(this);
}
public override string ToString()
{
StringBuilder moveStr = new StringBuilder();
foreach (MoveAction move in Actions)
{
switch (move.Type)
{
case MoveType.GROW:
moveStr.Append("GROW " + move.OrganId + " " + move.Location.x + " " + move.Location.y + " " + move.EntityType.ToString() + " " + GetGrowDirection(move.OrganDirection) + ";");
break;
case MoveType.SPORE:
moveStr.Append("SPORE " + move.OrganId + " " + move.Location.x + " " + move.Location.y + ";");
break;
case MoveType.WAIT:
moveStr.Append("WAIT;");
break;
}
}
return moveStr.ToString().Substring(0, moveStr.Length - 1);
}
public char GetGrowDirection(OrganDirection direction)
{
switch (direction)
{
case OrganDirection.North:
return 'N';
case OrganDirection.South:
return 'S';
case OrganDirection.West:
return 'W';
case OrganDirection.East:
return 'E';
}
throw new Exception("Invalid direction");
}
public void Print()
{
foreach (string action in ToString().Split(';'))
{
Console.WriteLine(action);
}
}
}
}
//*** SourceCombiner -> original file GameBuilder.cs ***
namespace GameSolution.Game
{
public static class GameBuilder
{
public static GameState BuildEmptyGame(bool setNextTurn = true)
{
GameState game = new GameState();
return game;
}
public static GameState BuildWood4Game()
{
GameState game = new GameState();
Board board = new Board(18, 9);
List<Entity> entities = new List<Entity>()
  {
 new Entity(0, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 2, "ROOT", 1, 1, "N", 1, 1),
 new Entity(1, 6, "ROOT", 0, 2, "N", 2, 2),
 new Entity(4, 1, "A", -1, 0, "X", 0, 0),
 new Entity(6, 1, "A", -1, 0, "X", 0, 0),
 new Entity(8, 2, "A", -1, 0, "X", 0, 0),
 new Entity(12, 2, "A", -1, 0, "X", 0, 0),
 new Entity(16, 2, "A", -1, 0, "X", 0, 0),
 new Entity(3, 3, "A", -1, 0, "X", 0, 0),
 new Entity(5, 3, "A", -1, 0, "X", 0, 0),
 new Entity(10, 3, "A", -1, 0, "X", 0, 0),
 new Entity(14, 3, "A", -1, 0, "X", 0, 0),
 new Entity(4, 5, "A", -1, 0, "X", 0, 0),
 new Entity(6, 5, "A", -1, 0, "X", 0, 0),
 new Entity(8, 6, "A", -1, 0, "X", 0, 0),
 new Entity(12, 6, "A", -1, 0, "X", 0, 0),
 new Entity(16, 6, "A", -1, 0, "X", 0, 0),
 new Entity(3, 7, "A", -1, 0, "X", 0, 0),
 new Entity(4, 7, "A", -1, 0, "X", 0, 0),
 new Entity(10, 7, "A", -1, 0, "X", 0, 0),
 new Entity(14, 7, "A", -1, 0, "X", 0, 0)
  };
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 10, 0, 0, 0 }, new int[] { 10, 0, 0, 0 });
return game;
}
public static GameState BuildWood3Game()
{
GameState game = new GameState();
Board board = new Board(18, 9);
List<Entity> entities = new List<Entity>()
  {
 new Entity(0, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 2, "ROOT", 1, 1, "N", 1, 1),
 new Entity(1, 6, "ROOT", 0, 2, "N", 2, 2),
 new Entity(4, 1, "A", -1, 0, "X", 0, 0),
 new Entity(4, 5, "A", -1, 0, "X", 0, 0)
  };
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 10, 0, 1, 1 }, new int[] { 10, 0, 1, 1 });
return game;
}
public static GameState BuildWood2Game()
{
GameState game = new GameState();
Board board = new Board(18, 8);
List<Entity> entities = new List<Entity>()
  {
 new Entity(0, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
  new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 2, "ROOT", 1, 1, "N", 1, 1),
 new Entity(16, 5, "ROOT", 0, 2, "N", 2, 2)
  };
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 50, 05, 05, 0 }, new int[] { 50, 05, 05, 0 });
return game;
}
public static GameState BuildWood1Game()
{
GameState game = new GameState();
Board board = new Board(18, 9);
List<Entity> entities = new List<Entity>()
  {
 new Entity(0, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 0, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(16, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 8, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(2, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(3, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(4, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(5, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(6, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(7, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(8, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(9, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(10, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(11, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(12, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(13, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(14, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(15, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 4, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 2, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 3, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 5, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
 new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
 new Entity(1, 2, "ROOT", 1, 1, "N", 1, 1),
 new Entity(1, 6, "ROOT", 0, 2, "N", 2, 2),
 new Entity(16, 1, "A", -1, 0, "X", 0, 0),
 new Entity(16, 5, "A", -1, 0, "X", 0, 0)
  };
board.SetEntities(entities);
board.Print();
game.SetNextTurn(board, new int[] { 6, 2, 2, 3 }, new int[] { 6, 2, 2, 3 });
return game;
}
}
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Game
{
 public class GameHelper
 {
GameState State { get; set; }
public GameHelper(GameState state)
{
  State = state;
}
public Move GetMove()
{
  Move move = new Move();
  move.AddAction(MoveAction.CreateWait());
  return move;
}
 }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Game
{
public class GameState : IGameState
{
public static int MaxTurns = 100;
public Board Board { get; private set; }
public int Turn { get; set; }
public int[] MyProtein { get; set; }
public int[] OppProtein { get; set; }
public Move? maxMove { get; set; }
public Move? minMove { get; set; }
public GameState()
{
Turn = 0;
maxMove = null;
minMove = null;
}
public GameState(GameState state)
{
Board = state.Board.Clone();
Turn = state.Turn;
MyProtein = state.MyProtein.ToArray();
OppProtein = state.OppProtein.ToArray();
maxMove = state.maxMove;
minMove = state.minMove;
}
public void SetNextTurn(Board board, int[] myProtein, int[] oppProtein)
{
Turn++;
this.Board = board;
MyProtein = myProtein;
OppProtein = oppProtein;
UpdateGameState();
}
public void UpdateGameState()
{
Board.UpdateBoard();
}
public void ApplyMove(object move, bool isMax)
{
Move m = (Move)move;
if (isMax)
{
maxMove = m;
minMove = null;
}
else
{
if (maxMove == null)
throw new Exception("Expected max to play first.");
minMove = m;
}
if (maxMove != null && minMove != null)
{
ApplyMove(maxMove, MyProtein);
ApplyMove(minMove, OppProtein);
Board.ApplyMove(maxMove, minMove);
Board.Harvest(true, MyProtein);
Board.Harvest(false, OppProtein);
Board.Attack();
SetNextTurn(Board, MyProtein, OppProtein);
}
}
public void ApplyMove(Move move, int[] proteins)
{
foreach (MoveAction action in move.Actions)
{
if (action.Type == MoveType.GROW || action.Type == MoveType.SPORE)
{
ApplyCost(proteins, action.GetCost());
if (action.EntityType == EntityType.BASIC)
{
Entity entity = Board.GetEntityByLocation(action.Location);
if (entity != null)
{
proteins[entity.Type - EntityType.A] += 3;
}
}
}
}
}
public void ApplyCost(int[] proteins, int[] cost)
{
for (int i = 0; i < 4; i++)
{
proteins[i] -= cost[i];
}
}
public IGameState Clone()
{
return new GameState(this);
}
public bool Equals(IGameState state)
{
GameState gameState = state as GameState;
if (this.Turn != gameState.Turn)
return false;
if ((maxMove == null && gameState.maxMove != null) || (maxMove != null && gameState.maxMove == null))
return false;
if ((minMove == null && gameState.minMove != null) || (minMove != null && gameState.minMove == null))
return false;
for (int i = 0; i < 4; i++)
{
if (this.MyProtein[i] != gameState.MyProtein[i])
return false;
if (this.OppProtein[i] != gameState.OppProtein[i])
return false;
}
if (!this.Board.Equals(gameState.Board))
return false;
return true;
}
public int GetGlobalOrganId()
{
return Board.GlobalOrganId;
}
public double Evaluate(bool isMax)
{
double value;
var myEntities = Board.GetMyEntityCount();
var oppEntities = Board.GetOppEntityCount();
var myProtein = MyProtein.Sum();
var oppProtein = OppProtein.Sum();
value = (((double)myEntities - oppEntities) / (myEntities + oppEntities + 1)) + (((double)myProtein - oppProtein) / (myProtein + oppProtein + 1) * 0.0001);
return value;
}
public object GetMove(bool isMax)
{
return isMax ? maxMove : minMove;
}
public int[] GetProteins(bool isMine)
{
return isMine ? MyProtein : OppProtein;
}
public IList GetPossibleMoves(bool isMax)
{
int[] proteins = GetProteins(isMax);
return Board.GetMoves(proteins, isMax);
}
public double? GetWinner()
{
double? winner = null;
var myEntities = Board.GetMyEntityCount();
var oppEntities = Board.GetOppEntityCount();
if (Turn < 100)
{
bool hasNoMyProteinsToBuild = MyProtein[0] == 0 && ((MyProtein[1] == 0 && MyProtein[2] == 0) || (MyProtein[1] == 0 && MyProtein[3] == 0) || (MyProtein[2] == 0 && MyProtein[3] == 0));
bool hasNoOppProteinsToBuild = OppProtein[0] == 0 && ((OppProtein[1] == 0 && OppProtein[2] == 0) || (OppProtein[1] == 0 && OppProtein[3] == 0) || (OppProtein[2] == 0 && OppProtein[3] == 0));
if (hasNoMyProteinsToBuild && myEntities < oppEntities)
winner = -1;
if (hasNoOppProteinsToBuild && oppEntities < myEntities)
winner = 1;
if (hasNoMyProteinsToBuild && hasNoOppProteinsToBuild && myEntities == oppEntities)
winner = 0;
}
if (Turn == 100 || Board.IsFull())
{
if (myEntities > oppEntities)
{
winner = 1;
}
else if (myEntities < oppEntities)
{
winner = -1;
}
else
{
if (MyProtein.Sum() > OppProtein.Sum())
{
winner = 1;
}
else if (MyProtein.Sum() < OppProtein.Sum())
{
winner = -1;
}
else winner = 0;
}
}
return winner;
}
public void Print()
{
Console.Error.WriteLine(Turn);
Console.Error.WriteLine(string.Join(',', MyProtein));
Console.Error.WriteLine(string.Join(',', OppProtein));
Board.Print();
}
}
}
