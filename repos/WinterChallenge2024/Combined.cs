/*
 * File generated by SourceCombiner.exe using 8 source files.
 * Created On: 12/20/2024 3:34:20 PM
*/
using Algorithms.GameComponent;
using Algorithms.Graph;
using Algorithms.Space;
using Algorithms.Trees;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
    static void Main(string[] args)
    {
        GameState gameState = new GameState();
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]); // columns in the game grid
        int height = int.Parse(inputs[1]); // rows in the game grid
        Board board = new Board(width, height);
        // game loop
        while (true)
        {
            int entityCount = int.Parse(Console.ReadLine());
            List<Entity> entities = new List<Entity>();
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int x = int.Parse(inputs[0]);
                int y = int.Parse(inputs[1]); // grid coordinate
                string type = inputs[2]; // WALL, ROOT, BASIC, TENTACLE, HARVESTER, SPORER, A, B, C, D
                int owner = int.Parse(inputs[3]); // 1 if your organ, 0 if enemy organ, -1 if neither
                int organId = int.Parse(inputs[4]); // id of this entity if it's an organ, 0 otherwise
                string organDir = inputs[5]; // N,E,S,W or X if not an organ
                int organParentId = int.Parse(inputs[6]);
                int organRootId = int.Parse(inputs[7]);
                Entity entity = new Entity(x, y, type, owner, organId, organDir, organParentId, organRootId);
                entities.Add(entity);
            }
            board.SetEntities(entities);
            inputs = Console.ReadLine().Split(' ');
            int myA = int.Parse(inputs[0]);
            int myB = int.Parse(inputs[1]);
            int myC = int.Parse(inputs[2]);
            int myD = int.Parse(inputs[3]); // your protein stock
            inputs = Console.ReadLine().Split(' ');
            int oppA = int.Parse(inputs[0]);
            int oppB = int.Parse(inputs[1]);
            int oppC = int.Parse(inputs[2]);
            int oppD = int.Parse(inputs[3]); // opponent's protein stock
            int requiredActionsCount = int.Parse(Console.ReadLine()); // your number of organisms, output an action for each one in any order
            Dictionary<EntityType, int> myProtein = new Dictionary<EntityType, int>();
            myProtein[EntityType.A] = myA;
            myProtein[EntityType.B] = myB;
            myProtein[EntityType.C] = myC;
            myProtein[EntityType.D] = myD;
            Dictionary<EntityType, int> oppProtein = new Dictionary<EntityType, int>();
            oppProtein[EntityType.A] = oppA;
            oppProtein[EntityType.B] = oppB;
            oppProtein[EntityType.C] = oppC;
            oppProtein[EntityType.D] = oppD;
            Stopwatch watch = new Stopwatch();
            watch.Start();
            gameState.SetNextTurn(board, myProtein, oppProtein);
            /*
            GameHelper gameHelper = new GameHelper(gameState);
            Move move = gameHelper.GetMove();
            */
            MonteCarloTreeSearch search = new MonteCarloTreeSearch();
            search.SetState(gameState, true, false);
            Move move = (Move)search.GetNextMove(watch, 48, 80, 2);
            Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
            board.Print();
            move.Print();
        }
    }
}
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 5/28/2023 8:05:44 PM
*/
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms.GameComponent
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        IList GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(object move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        object GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        double? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
        /// <summary>
        /// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
        /// </summary>
        /// <param name="isMax">true if it is max's turn else false</param>
        /// <returns>A number between [-1, 1]</returns>
        double Evaluate(bool isMax);
    }
}
//*** SourceCombiner -> original file Graph.cs ***
namespace Algorithms.Graph
{
    public class Graph
    {
        private Dictionary<int, INode> Nodes;
        //Will hold shortest paths from a start node id to an end node id
        private Dictionary<int, Dictionary<int, List<ILink>>> Paths;
        public Graph()
        {
            Nodes = new Dictionary<int, INode>();
        }
        public void AddNode(INode node)
        {
            Nodes[node.Id] = node;
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            foreach (INode vertex in Nodes.Values)
            {
                InternalBuildShortestPathsFromStartNode(vertex);
            }
        }
        public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            InternalBuildShortestPathsFromStartNode(startNode, maxDistance);
        }
        private void InternalBuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            foreach (INode node in Nodes.Values)
            {
                node.IsExplored = false;
            }
            List<ILink> minimumSpanningTree = new List<ILink>();
            Paths[startNode.Id] = new Dictionary<int, List<ILink>>();
            Paths[startNode.Id][startNode.Id] = new List<ILink>();
            minimumSpanningTree.Add(new Link(startNode.Id, startNode.Id, 0));
            startNode.IsExplored = true;
            int vertexCount = Nodes.Count;
            double currentDist;
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                ILink bestLink = null;
                ILink parentLink = null;
                foreach (ILink currentLink in minimumSpanningTree)
                {
                    INode currentNode = Nodes[currentLink.EndNodeId];
                    currentDist = currentLink.GetDistance(Paths[startNode.Id][currentNode.Id]);
                    foreach (ILink adjacent in currentNode.GetLinks())
                    {
                        INode adjacentNode = Nodes[adjacent.EndNodeId];
                        if (adjacentNode.IsExplored)
                        {
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestLink = adjacent;
                            parentLink = currentLink;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode.Id].TryGetValue(currentNode.Id, out List<ILink> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode.Id].TryGetValue(parentLink.EndNodeId, out List<ILink> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestLink = adjacent;
                                parentLink = currentLink;
                            }
                        }
                    }
                }
                if (parentLink == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestLink);
                Nodes[bestLink.EndNodeId].IsExplored = true;
                List<ILink> currentPath = null;
                if (!parentLink.EndNodeId.Equals(startNode.Id))
                {
                    Paths[startNode.Id].TryGetValue(parentLink.EndNodeId, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<ILink>();
                }
                else
                {
                    currentPath = new List<ILink>(currentPath);
                }
                Paths[startNode.Id].Add(bestLink.EndNodeId, currentPath);
                currentPath.Add(bestLink);
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The next node in the path</returns>
        public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startNode.Id);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
                throw new InvalidOperationException();
            }
            INode shortest = Nodes[paths.First().EndNodeId];
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
            return shortest;
        }
        /// <summary>
        /// Retrieves all nodes along the shortest path between two points
        /// </summary>
        /// <param name="startNodeId">Start node id</param>
        /// <param name="endNodeId">End node id</param>
        /// <returns>The full path from start to end</returns>
        /// <exception cref="InvalidOperationException"></exception>
        public IList<ILink> GetShortestPathAll(int startNodeId, int endNodeId)
        {
            Paths.TryGetValue(startNodeId, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startNodeId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endNodeId, out List<ILink> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endNodeId + " start: " + startNodeId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(INode startNode, INode endNode)
        {
            return GetShortestPathDistance(startNode.Id, endNode.Id);
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                return double.MaxValue;
            }
            endPoints.TryGetValue(endId, out List<ILink> paths);
            if (paths == null)
            {
                return double.MaxValue;
            }
            return paths.First().GetDistance(paths);
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(Node startNode, Node endNode)
        {
            return startNode.GetLinks().Where(l => l.EndNodeId.Equals(endNode.Id)).First().Distance;
        }
    }
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        public class Node
        {
            public int Id;
            public double Distance;
            public bool IsExplored;
            public Node(int id, double distance)
            {
                Id = id;
                Distance = distance;
            }
            /// <summary>
            /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
            /// </summary>
            /// <param name="currentDist">The current distance from the starting node</param>
            /// <returns>A clone of the node with the proper distance</returns>
            public Node CreateAtDistance(double currentDist)
            {
                return new Node(Id, currentDist + Distance);
            }
        }
        private Dictionary<int, List<Node>> Links;
        private Dictionary<int, Dictionary<int, List<Node>>> Paths;
        private bool IsByDirectional;
        public GraphLinks(bool isByDirectional = true)
        {
            Links = new Dictionary<int, List<Node>>();
            IsByDirectional = isByDirectional;
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, double distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            if (ContainsLink(id1, id2))
                return;
            AddLinkInternal(id1, id2, distance);
            if (IsByDirectional)
                AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            double currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        /// <summary>
        /// Retrieves the full path from start to end
        /// </summary>
        /// <param name="startId">the start id</param>
        /// <param name="endId">the end id</param>
        /// <returns>The full path</returns>
        public List<Node> GetShortestPathAll(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        //Adds links to the node links
        private void AddLinkInternal(int startNode, int endNode, double distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
    public interface INode
    {
        int Id { get; }
        bool IsExplored { get; set; }
        List<ILink> GetLinks();
    }
    public class Node : INode
    {
        public int Id { get; private set; }
        public bool IsExplored { get; set; }
        private List<ILink> Links;
        public Node(int id)
        {
            Id = id;
            IsExplored = false;
            Links = new List<ILink>();
        }
        public void AddLink(ILink link)
        {
            Links.Add(link);
        }
        public List<ILink> GetLinks()
        {
            return Links;
        }
        public bool Equals(INode node)
        {
            return node.Id == Id;
        }
    }
    public interface ILink
    {
        int StartNodeId { get; }
        int EndNodeId { get; }
        double Distance { get; }
        double GetDistance(List<ILink> currentPath);
    }
    public class Link : ILink
    {
        public int StartNodeId { get; private set; }
        public int EndNodeId { get; private set; }
        public double Distance { get; private set; }
        public Link(int startNodeId, int endNodeId, double distance)
        {
            StartNodeId = startNodeId;
            EndNodeId = endNodeId;
            Distance = distance;
        }
        public Link(INode startNode, INode endNode, double distance)
        {
            StartNodeId = startNode.Id;
            EndNodeId = endNode.Id;
            Distance = distance;
        }
        public double GetDistance(List<ILink> currentPath)
        {
            double distance = 0;
            foreach (ILink link in currentPath)
            {
                distance += link.Distance;
            }
            return distance;
        }
    }
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
    public class GameTreeNode
    {
        public IGameState state;
        public IList moves;
        public List<GameTreeNode> children;
        public double wins = 0;
        public double loses = 0;
        public int totalPlays = 0;
        public GameTreeNode parent;
        public bool isMax;
        public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
        {
            this.state = state;
            moves = new List<object>(50);
            var possibleMoves = state.GetPossibleMoves(isMax);
            for (int i = 0; i < possibleMoves.Count; i++)
            {
                var obj = possibleMoves[i];
                moves.Add(obj);
            }
            children = new List<GameTreeNode>(50);
            this.parent = parent;
            this.isMax = isMax;
        }
        public double GetScore(bool isMax)
        {
            double totalPlays = TotalPlays();
            if (totalPlays == 0)
                return 0;
            if (isMax)
            {
                return (wins - loses) / totalPlays;
            }
            else
            {
                return (loses - wins) / totalPlays;
            }
        }
        public int TotalPlays()
        {
            return totalPlays;
        }
        public double? GetWinner()
        {
            return state.GetWinner();
        }
        public void ApplyWinner(double? winner)
        {
            if (winner.HasValue)
            {
                if (winner > 0)
                {
                    wins += winner.Value;
                }
                else if (winner < 0)
                {
                    loses += Math.Abs(winner.Value);
                }
                totalPlays++;
            }
        }
        public double Evaluate()
        {
            return state.Evaluate(isMax);
        }
    }
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms.Trees
{
    public class Minimax : TreeAlgorithm
    {
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
        {
            double val = 99999999;
            val *= RootNode.isMax ? -1 : 1;
            object bestMove = null;
            foreach (object move in RootNode.moves)
            {
                GameTreeNode child = Expand(RootNode, move);
                double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
                if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
                {
                    bestMove = move;
                    val = currentVal;
                }
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    break;
                }
            }
            return bestMove;
        }
        public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
        {
            if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
            {
                double eval = currentNode.Evaluate();
                return eval;
            }
            double? winner = currentNode.GetWinner();
            if (winner.HasValue)
            {
                return winner.Value;
            }
            if (currentNode.isMax)
            {
                double value = -99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Max(value, minMax);
                    alpha = Math.Max(alpha, value);
                    if (alpha >= beta)
                    {
                        break;
                    }
                }
                return value;
            }
            else
            {
                double value = 99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Min(value, minMax);
                    beta = Math.Min(beta, value);
                    if (beta <= alpha)
                    {
                        break;
                    }
                }
                return value;
            }
        }
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
    public class MonteCarloTreeSearch : TreeAlgorithm
    {
        private Random rand;
        private bool printErrors;
        private SearchStrategy strategy;
        public enum SearchStrategy
        {
            Random = 0,
            Sequential = 1
        }
        public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random)
        {
            rand = new Random();
            printErrors = showErrors;
            strategy = searchStrategy;
        }
        public IGameState GetRootState()
        {
            return RootNode.state;
        }
        /// <summary>
        /// Get the next move
        /// </summary>
        /// <param name="watch">timer</param>
        /// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
        /// <param name="depth">How deep to run the simulations; does not impact how deep it goes in the game tree.</param>
        /// <param name="numRollouts">The number of roll outs to play per expansion</param>
        /// <returns></returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
        {
            if (exploration == null)
            {
                exploration = Math.Sqrt(2);
            }
            int count = 0;
            do
            {
                GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
                if (selectedNode == null)
                {
                    if (printErrors)
                        Console.Error.WriteLine("Found no more moves!");
                    break;
                }
                object move = SelectMove(selectedNode);
                GameTreeNode childNode = Expand(selectedNode, move);
                double? winner = childNode.GetWinner();
                if (winner.HasValue)
                {
                    BackPropagate(childNode, winner);
                }
                else
                {
                    for (int i = 0; i < numRollouts; i++)
                    {
                        var clonedState = childNode.state.Clone();
                        winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
                        if (!winner.HasValue)
                            break;//We simulated a game, but it didn't end so we are out of time...
                        BackPropagate(childNode, winner);
                        count++;
                    }
                }
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            if (printErrors)
                Console.Error.WriteLine($"Played {count} games!");
            GameTreeNode bestChild = null;
            double bestScore = double.MinValue;
            for (int i = 0; i < RootNode.children.Count; i++)
            {
                var child = RootNode.children[i];
                double score = child.GetScore(RootNode.isMax);
                if (bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                if (printErrors)
                    Console.Error.WriteLine($"w: {(RootNode.isMax ? child.wins : child.loses)} l: {(RootNode.isMax ? child.loses : child.wins)} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
            }
            if (printErrors)
                Console.Error.WriteLine($"Best: w: {(RootNode.isMax ? bestChild.wins : bestChild.loses)} l: {(RootNode.isMax ? bestChild.loses : bestChild.wins)} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
            return bestChild.state.GetMove(RootNode.isMax);
        }
        private void BackPropagate(GameTreeNode selectedNode, double? winner)
        {
            selectedNode.ApplyWinner(winner);
            GameTreeNode tempNode = selectedNode.parent;
            while (tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
        {
            double? winner;
            do
            {
                object move = SelectMoveAtRandom(state, isMax);
                state.ApplyMove(move, isMax);
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    return null;
                }
                depth--;
                isMax = !isMax;
                winner = state.GetWinner();
            }
            while (!winner.HasValue && depth != 0);
            if (winner.HasValue)
            {
                return winner;
            }
            if (depth == 0)
            {
                double eval = state.Evaluate(isMax);
                if (eval > 1)
                {
                    return 1;
                }
                else if (eval < -1)
                    return -1;
                else return eval;
            }
            throw new InvalidOperationException("Could not find a winner for simulation!");
        }
        private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
        {
            Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
            queue.Enqueue(node);
            GameTreeNode tempNode;
            GameTreeNode bestNode = null;
            double maxValue = -1;
            while (queue.Count > 0)
            {
                tempNode = queue.Dequeue();
                if (tempNode.moves.Count == 0)
                {
                    for (int i = 0; i < tempNode.children.Count; i++)
                    {
                        var child = tempNode.children[i];
                        queue.Enqueue(child);
                    }
                }
                else if (tempNode.parent != null)
                {
                    double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
                    double nodeTotal = tempNode.TotalPlays();
                    double parentTotal = tempNode.parent.TotalPlays();
                    double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
                    if (value > maxValue)
                    {
                        maxValue = value;
                        bestNode = tempNode;
                    }
                }
                else return tempNode;
            }
            return bestNode;
        }
        private object SelectMoveAtRandom(IGameState state, bool isMax)
        {
            IList moves = state.GetPossibleMoves(isMax);
            if (moves.Count == 0)
            {
                throw new Exception("No moves available!");
            }
            int index = rand.Next(0, moves.Count);
            return moves[index];
        }
        private object SelectMove(GameTreeNode node)
        {
            switch (strategy)
            {
                case SearchStrategy.Random:
                    return SelectMoveAtRandom(node);
                case SearchStrategy.Sequential:
                    return SelectMoveSequentially(node);
            }
            throw new InvalidOperationException("strategy not supported");
        }
        private object SelectMoveSequentially(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                move = node.moves[0];
                node.moves.RemoveAt(0);
            }
            return move;
        }
        private object SelectMoveAtRandom(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
    }
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms.Trees
{
    public class TreeAlgorithm
    {
        protected GameTreeNode RootNode;
        public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
        {
            if (RootNode != null && findState)
            {
                //if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
                //find the child that matches the new node
                bool isFound = false;
                //Expand any moves left in the root node (if any)
                for (int i = 0; i < RootNode.moves.Count; i++)
                {
                    var move = RootNode.moves[i];
                    Expand(RootNode, move);
                }
                //Begin scanning the children
                for (int i = 0; i < RootNode.children.Count; i++)
                {
                    var child = RootNode.children[i];
                    if (child.state.Equals(rootState))
                    {
                        RootNode = child;
                        isFound = true;
                        break;
                    }
                    for (int j = 0; j < child.moves.Count; j++)
                    {
                        var move = child.moves[j];
                        Expand(child, move);
                    }
                    for (int j = 0; j < child.children.Count; j++)
                    {
                        var descendent = child.children[j];
                        if (descendent.state.Equals(rootState))
                        {
                            RootNode = descendent;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
                    RootNode = new GameTreeNode(rootState.Clone(), isMax);
                }
                else
                {
                    RootNode.parent = null;
                }
            }
            else
            {
                RootNode = new GameTreeNode(rootState.Clone(), isMax);
            }
        }
        /// <summary>
        /// Expands the given node by create a clone, applying the move and then adding it to the list of children.
        /// </summary>
        /// <param name="node">The node to expand</param>
        /// <param name="move">The move to play on the expanded node</param>
        /// <returns></returns>
        protected GameTreeNode Expand(GameTreeNode node, object move)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, node.isMax);
            GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
    }
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
    public static class BitFunctions
    {
        public static bool IsBitSet(long value, int location)
        {
            long mask = GetBitMask(location);
            return (value & mask) == mask;
        }
        public static long SetBit(long value, int location)
        {
            return value | (GetBitMask(location));
        }
        public static long ClearBit(long value, int location)
        {
            return value & (~(GetBitMask(location)));
        }
        public static long SetOrClearBit(long value, int location, bool isSet)
        {
            if (isSet)
                return SetBit(value, location);
            return ClearBit(value, location);
        }
        public static int NumberOfSetBits(long i)
        {
            i = i - ((i >> 1) & 0x5555555555555555);
            i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
            return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
        }
        public static long GetBitMask(int index)
        {
            return (long)1 << index;
        }
    }
}
namespace Algorithms.Space
{
    public class Point2d
    {
        public double x;
        public double y;
        public Point2d(double x, double y)
        {
            this.x = x;
            this.y = y;
        }
        public Point2d(Point2d point)
        {
            x = point.x;
            y = point.y;
        }
        public override string ToString()
        {
            return $"({x},{y})";
        }
        public override bool Equals(object objPoint)
        {
            Point2d point = objPoint as Point2d;
            return point.x == this.x && point.y == this.y;
        }
        public override int GetHashCode()
        {
            return Tuple.Create(x, y).GetHashCode();
        }
        public Point2d GetTruncatedPoint()
        {
            return new Point2d(Math.Truncate(this.x), Math.Truncate(this.y));
        }
        public Point2d GetRoundedPoint()
        {
            return new Point2d(Math.Round(this.x), Math.Round(this.y));
        }
        public Point2d GetCeilingPoint()
        {
            return new Point2d(Math.Ceiling(x), Math.Ceiling(y));
        }
        public int GetTruncatedX()
        {
            return (int)x;
        }
        public int GetTruncatedY()
        {
            return (int)y;
        }
        public double GetAngle(Point2d point)
        {
            return Math.Atan2(point.y - y, point.x - x);
        }
        public int GetManhattenDistance(Point2d point)
        {
            return (int)(Math.Abs(point.x - x) + Math.Abs(point.y - y));
        }
        public double GetDistance(Point2d point)
        {
            return GetDistance(point.x, point.y, x, y);
        }
        public Point2d GetMidPoint(Point2d point)
        {
            return GetMidPoint(point.x, point.y, x, y);
        }
        public double LengthSquared()
        {
            return x * x + y * y;
        }
        public double Length()
        {
            return Math.Sqrt(LengthSquared());
        }
        public Point2d Normalize()
        {
            var length = Length();
            if (length == 0)
            {
                x = 0;
                y = 0;
            }
            else
            {
                x /= length;
                y /= length;
            }
            return this;
        }
        public Point2d Multiply(double scalar)
        {
            x *= scalar;
            y *= scalar;
            return this;
        }
        public Point2d Add(Point2d vector)
        {
            x += vector.x;
            y += vector.y;
            return this;
        }
        public Point2d Subtract(Point2d vector)
        {
            x -= vector.x;
            y -= vector.y;
            return this;
        }
        public Point2d Truncate()
        {
            x = GetTruncatedX();
            y = GetTruncatedY();
            return this;
        }
        public Point2d SymmetricTruncate(Point2d origin)
        {
            Subtract(origin).Truncate().Add(origin);
            return this;
        }
        public Point2d GetRoundedAwayFromZeroPoint()
        {
            return new Point2d(Math.Round(x, MidpointRounding.AwayFromZero), Math.Round(y, MidpointRounding.AwayFromZero));
        }
        public Point2d Clone()
        {
            return new Point2d(x, y);
        }
        public void Fill(Point2d point)
        {
            x = point.x;
            y = point.y;
        }
        public static double GetDistance(double x1, double y1, double x2, double y2)
        {
            return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));
        }
        public static Point2d GetMidPoint(double x1, double y1, double x2, double y2)
        {
            return new Point2d((x1 + x2) / 2, (y1 + y2) / 2);
        }
    }
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
    public class Board
    {
        public int Width { get; private set; }
        public int Height { get; private set; }
        private Dictionary<Point2d, Entity> Entities { get; set; }
        public int GlobalOrganId { get; set; } = -1;
        public Board(int width, int height)
        {
            Width = width;
            Height = height;
            Entities = new Dictionary<Point2d, Entity>();
        }
        public Board(Board board)
        {
            Width = board.Width;
            Height = board.Height;
            Entities = board.Entities.ToDictionary(e => e.Key.Clone(), e => e.Value.Clone());
            GlobalOrganId = board.GlobalOrganId;
        }
        public bool Equals(Board board)
        {
            if (Width != board.Width || Height != board.Height)
                return false;
            foreach (Point2d location in Entities.Keys)
            {
                if (!board.Entities.TryGetValue(location, out Entity entity))
                    return false;
                else if (!Entities[location].Equals(entity))
                    return false;
            }
            return true;
        }
        public void ApplyMove(Move move, bool isMine)
        {
            foreach (MoveAction action in move.Actions)
            {
                switch (action.Type)
                {
                    case MoveType.GROW:
                        Entities[action.Location] = new Entity(action.Location, action.EntityType, isMine, GlobalOrganId++, action.OrganId, action.OrganRootId, OrganDirection.North);
                        break;
                }
            }
        }
        public List<Move> GetGrowMoves(bool isMine)
        {
            List<Move> moves = new List<Move>();
            var entities = GetEntities(isMine);
            foreach (Entity entity in entities)
            {
                if (IsOpenSpaceNorth(entity))
                {
                    Move move = new Move();
                    move.AddAction(MoveAction.CreateGrow(entity.OrganId, new Point2d(entity.Location.x, entity.Location.y + 1), EntityType.BASIC, entity.OrganRootId));
                    moves.Add(move);
                }
                if (IsOpenSpaceSouth(entity))
                {
                    Move move = new Move();
                    move.AddAction(MoveAction.CreateGrow(entity.OrganId, new Point2d(entity.Location.x, entity.Location.y - 1), EntityType.BASIC, entity.OrganRootId));
                    moves.Add(move);
                }
                if (IsOpenSpaceEast(entity))
                {
                    Move move = new Move();
                    move.AddAction(MoveAction.CreateGrow(entity.OrganId, new Point2d(entity.Location.x + 1, entity.Location.y), EntityType.BASIC, entity.OrganRootId));
                    moves.Add(move);
                }
                if (IsOpenSpaceWest(entity))
                {
                    Move move = new Move();
                    move.AddAction(MoveAction.CreateGrow(entity.OrganId, new Point2d(entity.Location.x - 1, entity.Location.y), EntityType.BASIC, entity.OrganRootId));
                    moves.Add(move);
                }
            }
            return moves;
        }
        public List<Move> GetHarvestMoves(bool isMine)
        {
            List<Move> moves = new List<Move>();
            List<Move> growMoves = GetGrowMoves(isMine);
            foreach (Move growMove in growMoves)
            {
                foreach (MoveAction growAction in growMove.Actions)
                {
                    if (IsHarvestSpaceNorth(growAction.Location))
                    {
                        Move move = new Move();
                        move.AddAction(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, OrganDirection.North));
                        moves.Add(move);
                    }
                    if (IsHarvestSpaceSouth(growAction.Location))
                    {
                        Move move = new Move();
                        move.AddAction(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, OrganDirection.South));
                        moves.Add(move);
                    }
                    if (IsHarvestSpaceEast(growAction.Location))
                    {
                        Move move = new Move();
                        move.AddAction(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, OrganDirection.East));
                        moves.Add(move);
                    }
                    if (IsHarvestSpaceWest(growAction.Location))
                    {
                        Move move = new Move();
                        move.AddAction(MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, OrganDirection.West));
                        moves.Add(move);
                    }
                }
            }
            return moves;
        }
        public bool IsHarvestSpaceNorth(Point2d location)
        {
            return location.y < Height - 1 && Entities.TryGetValue(new Point2d(location.x, location.y + 1), out Entity entityNorth) && entityNorth.IsOpenSpace();
        }
        public bool IsHarvestSpaceSouth(Point2d location)
        {
            return location.y > 0 && Entities.TryGetValue(new Point2d(location.x, location.y - 1), out Entity entitySouth) && entitySouth.IsOpenSpace();
        }
        public bool IsHarvestSpaceEast(Point2d location)
        {
            return location.x < Width - 1 && Entities.TryGetValue(new Point2d(location.x + 1, location.y), out Entity entityEast) && entityEast.IsOpenSpace();
        }
        public bool IsHarvestSpaceWest(Point2d location)
        {
            return location.x > 0 && Entities.TryGetValue(new Point2d(location.x - 1, location.y), out Entity entityWest) && entityWest.IsOpenSpace();
        }
        public bool IsOpenSpaceNorth(Entity entity)
        {
            return entity.Location.y < Height - 1 && (!Entities.TryGetValue(new Point2d(entity.Location.x, entity.Location.y + 1), out Entity entityNorth) || entityNorth.IsOpenSpace());
        }
        public bool IsOpenSpaceSouth(Entity entity)
        {
            return entity.Location.y > 0 && (!Entities.TryGetValue(new Point2d(entity.Location.x, entity.Location.y - 1), out Entity entitySouth) || entitySouth.IsOpenSpace());
        }
        public bool IsOpenSpaceEast(Entity entity)
        {
            return entity.Location.x < Width - 1 && (!Entities.TryGetValue(new Point2d(entity.Location.x + 1, entity.Location.y), out Entity entityEast) || entityEast.IsOpenSpace());
        }
        public bool IsOpenSpaceWest(Entity entity)
        {
            return entity.Location.x > 0 && (!Entities.TryGetValue(new Point2d(entity.Location.x - 1, entity.Location.y), out Entity entityWest) || entityWest.IsOpenSpace());
        }
        public Entity GetEntityByLocation(Point2d location)
        {
            Entities.TryGetValue(location, out Entity entity);
            return entity;
        }
        public List<Entity> GetEntities(bool isMine)
        {
            return Entities.Values.Where(e => e.IsMine.HasValue && e.IsMine.Value == isMine).ToList();
        }
        public Dictionary<Point2d, Entity> GetEntities()
        {
            return Entities;
        }
        public int GetMyEntityCount()
        {
            return GetEntities(true).Count();
        }
        public int GetOppEntityCount()
        {
            return GetEntities(false).Count();
        }
        public void SetEntities(IList<Entity> entities)
        {
            foreach (Entity entity in entities)
            {
                Entities[entity.Location] = entity;
                if (entity.OrganId > 0 && GlobalOrganId <= entity.OrganId)
                {
                    GlobalOrganId = entity.OrganId + 1;
                }
            }
            /*
            for(int x = 0; x< Width; x++)
            {
                for(int y = 0; y< Height; y++)
                {
                    if(!Entities.TryGetValue(new Point2d(x, y), out Entity entity) || entity.IsOpenSpace())
                    {
                        var node = new Node(x + (y * Width));
                        Graph.AddNode(node);
                        if (x < Width - 1 && (!Entities.TryGetValue(new Point2d(x + 1, y), out Entity entityEast) || entityEast.IsOpenSpace()))
                        {
                            node.AddLink(new Link(node, new Node(x + 1 + (y * Width)), 1));
                        }
                        if (x > 0 && (!Entities.TryGetValue(new Point2d(x - 1, y), out Entity entityWest) || entityWest.IsOpenSpace()))
                        {
                            node.AddLink(new Link(node, new Node(x - 1 + (y * Width)), 1));
                        }
                        if (y < Height - 1 && (!Entities.TryGetValue(new Point2d(x, y + 1), out Entity entityNorth) || entityNorth.IsOpenSpace()))
                        {
                            node.AddLink(new Link(node, new Node(x + ((y + 1) * Width)), 1));
                        }
                        if (y > 0 && (!Entities.TryGetValue(new Point2d(x, y - 1), out Entity entitySouth) || entitySouth.IsOpenSpace()))
                        {
                            node.AddLink(new Link(node, new Node(x + ((y - 1) * Width)), 1));
                        }
                    }
                }
            }
            */
        }
        public Board Clone()
        {
            return new Board(this);
        }
        public double? GetWinner()
        {
            return null;
        }
        public void Print()
        {
            for (int y = 0; y < Height; y++)
            {
                StringBuilder stringBuilder = new StringBuilder();
                for (int x = 0; x < Width; x++)
                {
                    if (!Entities.TryGetValue(new Point2d(x, y), out Entity entity))
                    {
                        stringBuilder.Append(" ");
                    }
                    else
                    {
                        stringBuilder.Append(GetCharacter(entity.Type, entity.IsMine));
                    }
                }
                Console.Error.WriteLine(stringBuilder.ToString());
            }
        }
        public char GetCharacter(EntityType type, bool? isMine)
        {
            bool isMineInt = isMine.HasValue && isMine.Value;
            switch (type)
            {
                case EntityType.WALL:
                    return 'X';
                case EntityType.ROOT:
                    return isMineInt ? 'R' : 'r';
                case EntityType.BASIC:
                    return isMineInt ? 'B' : 'b';
                case EntityType.TENTACLE:
                    return isMineInt ? 'T' : 't';
                case EntityType.HARVESTER:
                    return isMineInt ? 'H' : 'h';
                case EntityType.SPORER:
                    return isMineInt ? 'S' : 's';
                case EntityType.A:
                    return 'A';
                case EntityType.B:
                    return 'B';
                case EntityType.C:
                    return 'C';
                case EntityType.D:
                    return 'D';
            }
            throw new ArgumentException($"Type: {type} not supported");
        }
        public void UpdateBoard()
        {
        }
    }
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
    //WALL, ROOT, BASIC, TENTACLE, HARVESTER, SPORER, A, B, C, D
    public enum EntityType
    {
        WALL = 0,
        ROOT,
        BASIC,
        TENTACLE,
        HARVESTER,
        SPORER,
        A,
        B,
        C,
        D
    }
    public enum OrganDirection
    {
        North = 0,
        South,
        East,
        West,
        None
    }
    public class Entity
    {
        public bool? IsMine { get; set; }
        public Point2d Location { get; set; }
        public EntityType Type { get; set; }
        public int OrganId { get; set; }
        public OrganDirection OrganDirection { get; set; }
        public int OrganParentId { get; set; }
        public int OrganRootId { get; set; }
        public Entity(int x, int y, string type, int owner, int organId, string organDir, int organParentId, int organRootId)
        {
            Location = new Point2d(x, y);
            IsMine = owner == 1 ? true : owner == -1 ? (bool?)null : false;
            Type = GetType(type);
            OrganDirection = GetOrganDirection(organDir);
            OrganId = organId;
            OrganParentId = organParentId;
            OrganRootId = organRootId;
        }
        public Entity(Point2d location, EntityType type, bool isMine, int organId, int organParentId, int organRootId, OrganDirection organDirection)
        {
            Location = location;
            IsMine = isMine;
            Type = type;
            OrganId = organId;
            OrganParentId = organParentId;
            OrganRootId = organRootId;
            OrganDirection = organDirection;
        }
        public Entity(Entity entity)
        {
            this.IsMine = entity.IsMine;
            this.Type = entity.Type;
            this.OrganDirection = entity.OrganDirection;
            this.Location = entity.Location.Clone();
            this.OrganId = entity.OrganId;
            this.OrganParentId = entity.OrganParentId;
            this.OrganRootId = entity.OrganRootId;
        }
        public OrganDirection GetOrganDirection(string organDir)
        {
            switch (organDir)
            {
                case "N":
                    return OrganDirection.North;
                case "E":
                    return OrganDirection.East;
                case "W":
                    return OrganDirection.West;
                case "S":
                    return OrganDirection.South;
                case "X":
                    return OrganDirection.None;
            }
            throw new ArgumentException($"Invalid direction: {organDir}", nameof(organDir));
        }
        public EntityType GetType(string type)
        {
            switch (type)
            {
                case "WALL":
                    return EntityType.WALL;
                case "ROOT":
                    return EntityType.ROOT;
                case "BASIC":
                    return EntityType.BASIC;
                case "TENTACLE":
                    return EntityType.TENTACLE;
                case "HARVESTER":
                    return EntityType.HARVESTER;
                case "SPORER":
                    return EntityType.SPORER;
                case "A":
                    return EntityType.A;
                case "B":
                    return EntityType.B;
                case "C":
                    return EntityType.C;
                case "D":
                    return EntityType.D;
            }
            throw new ArgumentException($"Invalid type: {type}", nameof(type));
        }
        public bool IsOpenSpace()
        {
            return Type == EntityType.A || Type == EntityType.B || Type == EntityType.C || Type == EntityType.D;
        }
        public Entity Clone()
        {
            return new Entity(this);
        }
        public bool Equals(Entity entity)
        {
            return entity.IsMine == IsMine && entity.OrganParentId == OrganParentId && entity.OrganRootId == OrganRootId && entity.Type == Type && entity.Location.Equals(Location) && entity.OrganId == OrganId && entity.OrganDirection == OrganDirection;
        }
        public override string ToString()
        {
            return "";
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
    public enum MoveType
    {
        WAIT = 0,
        GROW,
    };
    public class MoveAction
    {
        public MoveType Type { get; set; }
        public int OrganId { get; set; }
        public Point2d Location { get; set; }
        public EntityType EntityType { get; set; }
        public int OrganRootId { get; set; }
        public OrganDirection OrganDirection { get; set; }
        public MoveAction(MoveType moveType)
        {
            Type = moveType;
        }
        public static MoveAction CreateGrow(int organId, Point2d location, EntityType type, int organRootId, OrganDirection organDirection = OrganDirection.North)
        {
            var action = new MoveAction(MoveType.GROW);
            action.OrganId = organId;
            action.Location = location;
            action.EntityType = type;
            action.OrganRootId = organRootId;
            action.OrganDirection = organDirection;
            return action;
        }
        public static MoveAction CreateWait()
        {
            var action = new MoveAction(MoveType.WAIT);
            return action;
        }
    }
    public class Move
    {
        public List<MoveAction> Actions { get; set; }
        public Move()
        {
            Actions = new List<MoveAction>();
        }
        public Move(Move move)
        {
            Actions = move.Actions.Select(m => m).ToList();
        }
        public void AddAction(MoveAction move)
        {
            Actions.Add(move);
        }
        public Move Clone()
        {
            return new Move(this);
        }
        public override string ToString()
        {
            StringBuilder moveStr = new StringBuilder();
            foreach (MoveAction move in Actions)
            {
                switch (move.Type)
                {
                    case MoveType.GROW:
                        moveStr.Append("GROW " + move.OrganId + " " + move.Location.x + " " + move.Location.y + " " + move.EntityType.ToString() + ";");
                        break;
                    case MoveType.WAIT:
                        moveStr.Append("WAIT;");
                        break;
                }
            }
            return moveStr.ToString().Substring(0, moveStr.Length - 1);
        }
        public void Print()
        {
            foreach (string action in ToString().Split(';'))
            {
                Console.WriteLine(action);
            }
        }
    }
}
//*** SourceCombiner -> original file GameBuilder.cs ***
namespace GameSolution.Game
{
    public static class GameBuilder
    {
        public static GameState BuildEmptyGame(bool setNextTurn = true)
        {
            GameState game = new GameState();
            return game;
        }
        public static GameState BuildBasicGame()
        {
            GameState game = new GameState();
            Board board = new Board(18, 9);
            List<Entity> entities = new List<Entity>()
            {
                new Entity(0, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(2, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(3, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(4, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(5, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(6, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(7, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(8, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(9, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(10, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(11, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(12, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(13, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(14, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(15, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(16, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(2, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(3, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(4, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(5, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(6, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(7, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(8, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(9, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(10, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(11, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(12, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(13, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(14, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(15, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(16, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(2, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(3, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(4, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(5, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(6, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(7, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(8, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(9, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(10, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(11, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(12, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(13, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(14, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(15, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 2, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 3, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 5, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 2, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 3, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 5, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 2, "ROOT", 1, 1, "N", 1, 1),
                new Entity(1, 6, "ROOT", 0, 2, "N", 2, 2),
                new Entity(4, 1, "A", -1, 0, "X", 0, 0),
                new Entity(6, 1, "A", -1, 0, "X", 0, 0),
                new Entity(8, 2, "A", -1, 0, "X", 0, 0),
                new Entity(12, 2, "A", -1, 0, "X", 0, 0),
                new Entity(16, 2, "A", -1, 0, "X", 0, 0),
                new Entity(3, 3, "A", -1, 0, "X", 0, 0),
                new Entity(5, 3, "A", -1, 0, "X", 0, 0),
                new Entity(10, 3, "A", -1, 0, "X", 0, 0),
                new Entity(14, 3, "A", -1, 0, "X", 0, 0),
                new Entity(4, 5, "A", -1, 0, "X", 0, 0),
                new Entity(6, 5, "A", -1, 0, "X", 0, 0),
                new Entity(8, 6, "A", -1, 0, "X", 0, 0),
                new Entity(12, 6, "A", -1, 0, "X", 0, 0),
                new Entity(16, 6, "A", -1, 0, "X", 0, 0),
                new Entity(3, 7, "A", -1, 0, "X", 0, 0),
                new Entity(4, 7, "A", -1, 0, "X", 0, 0),
                new Entity(10, 7, "A", -1, 0, "X", 0, 0),
                new Entity(14, 7, "A", -1, 0, "X", 0, 0)
            };
            board.SetEntities(entities);
            board.Print();
            game.SetNextTurn(board, new Dictionary<EntityType, int>() { { EntityType.A, 10 } }, new Dictionary<EntityType, int>() { { EntityType.A, 10 } });
            return game;
        }
        public static GameState BuildWood3Game()
        {
            GameState game = new GameState();
            Board board = new Board(18, 9);
            List<Entity> entities = new List<Entity>()
            {
                new Entity(0, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(2, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(3, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(4, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(5, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(6, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(7, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(8, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(9, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(10, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(11, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(12, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(13, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(14, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(15, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(16, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 0, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(2, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(3, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(4, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(5, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(6, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(7, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(8, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(9, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(10, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(11, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(12, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(13, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(14, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(15, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(16, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 8, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(2, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(3, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(4, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(5, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(6, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(7, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(8, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(9, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(10, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(11, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(12, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(13, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(14, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(15, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 4, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 1, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 2, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 3, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 5, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 6, "WALL", -1, 0, "X", 0, 0),
                new Entity(0, 7, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 1, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 2, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 3, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 5, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 6, "WALL", -1, 0, "X", 0, 0),
                new Entity(17, 7, "WALL", -1, 0, "X", 0, 0),
                new Entity(1, 2, "ROOT", 1, 1, "N", 1, 1),
                new Entity(1, 6, "ROOT", 0, 2, "N", 2, 2),
                new Entity(4, 1, "A", -1, 0, "X", 0, 0),
                new Entity(4, 5, "A", -1, 0, "X", 0, 0)
            };
            board.SetEntities(entities);
            board.Print();
            game.SetNextTurn(board, new Dictionary<EntityType, int>() { { EntityType.A, 10 }, { EntityType.C, 1 }, { EntityType.D, 1 } }, new Dictionary<EntityType, int>() { { EntityType.A, 10 }, { EntityType.C, 1 }, { EntityType.D, 1 } });
            return game;
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Game
{
    public class GameHelper
    {
        GameState State { get; set; }
        public GameHelper(GameState state)
        {
            State = state;
        }
        public Move GetMove()
        {
            Move move = new Move();
            move.AddAction(MoveAction.CreateWait());
            return move;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Game
{
    public class GameState : IGameState
    {
        public static int MaxTurns = 100;
        public Board Board { get; private set; }
        public int Turn { get; set; }
        public Dictionary<EntityType, int> MyProtein { get; set; }
        public Dictionary<EntityType, int> OppProtein { get; set; }
        public Move? maxMove { get; set; }
        public Move? minMove { get; set; }
        public GameState()
        {
            Turn = 0;
            maxMove = null;
            minMove = null;
        }
        public GameState(GameState state)
        {
            Board = state.Board.Clone();
            Turn = state.Turn;
            MyProtein = state.MyProtein.ToDictionary(e => e.Key, e => e.Value);
            OppProtein = state.OppProtein.ToDictionary(e => e.Key, e => e.Value);
            maxMove = state.maxMove;
            minMove = state.minMove;
        }
        public void SetNextTurn(Board board, Dictionary<EntityType, int> myProtein, Dictionary<EntityType, int> oppProtein)
        {
            Turn++;
            this.Board = board;
            MyProtein = myProtein;
            OppProtein = oppProtein;
            UpdateGameState();
        }
        public void UpdateGameState()
        {
        }
        public void ApplyMove(object move, bool isMax)
        {
            Move m = (Move)move;
            if (isMax)
            {
                maxMove = m;
                minMove = null;
            }
            else
            {
                if (maxMove == null)
                    throw new Exception("Expected max to play first.");
                minMove = m;
            }
            if (maxMove != null && minMove != null)
            {
                ApplyMove(maxMove, MyProtein);
                ApplyMove(minMove, OppProtein);
                Board.ApplyMove(maxMove, true);
                Board.ApplyMove(minMove, false);
                SetNextTurn(Board, MyProtein, OppProtein);
            }
        }
        public void ApplyMove(Move move, Dictionary<EntityType, int> Proteins)
        {
            foreach (MoveAction action in move.Actions)
            {
                if (action.Type == MoveType.GROW)
                {
                    Proteins[EntityType.A]--;
                    Entity entity = Board.GetEntityByLocation(action.Location);
                    if (entity != null)
                    {
                        switch (entity.Type)
                        {
                            case EntityType.A:
                                Proteins[EntityType.A] += 3;
                                break;
                            case EntityType.B:
                                Proteins[EntityType.B] += 3;
                                break;
                            case EntityType.C:
                                Proteins[EntityType.C] += 3;
                                break;
                            case EntityType.D:
                                Proteins[EntityType.D] += 3;
                                break;
                        }
                    }
                }
            }
        }
        public IGameState Clone()
        {
            return new GameState(this);
        }
        public bool Equals(IGameState state)
        {
            GameState gameState = state as GameState;
            if (this.Turn != gameState.Turn)
                return false;
            if ((maxMove == null && gameState.maxMove != null) || (maxMove != null && gameState.maxMove == null))
                return false;
            if ((minMove == null && gameState.minMove != null) || (minMove != null && gameState.minMove == null))
                return false;
            foreach (EntityType type in MyProtein.Keys)
            {
                if (this.MyProtein[type] != gameState.MyProtein[type])
                    return false;
                if (this.OppProtein[type] != gameState.OppProtein[type])
                    return false;
            }
            if (!this.Board.Equals(gameState.Board))
                return false;
            return true;
        }
        public int GetGlobalOrganId()
        {
            return Board.GlobalOrganId;
        }
        public double Evaluate(bool isMax)
        {
            double value;
            var myEntities = Board.GetMyEntityCount();
            var oppEntities = Board.GetOppEntityCount();
            var myProteinA = MyProtein[EntityType.A];
            var oppProteinA = OppProtein[EntityType.A];
            value = (((double)myEntities - oppEntities) / (myEntities + oppEntities)) + (((double)myProteinA - oppProteinA) / (myProteinA + oppProteinA + 1) * 0.001);
            return value;
        }
        public object GetMove(bool isMax)
        {
            return isMax ? maxMove : minMove;
        }
        public Dictionary<EntityType, int> GetProteins(bool isMine)
        {
            return isMine ? MyProtein : OppProtein;
        }
        public IList GetPossibleMoves(bool isMax)
        {
            var moves = new List<Move>();
            var move = new Move();
            move.AddAction(MoveAction.CreateWait());
            moves.Add(move);
            Dictionary<EntityType, int> proteins = GetProteins(isMax);
            if (proteins[EntityType.A] > 0)
            {
                moves.AddRange(Board.GetGrowMoves(isMax));
            }
            return moves;
        }
        public double? GetWinner()
        {
            double? winner = null;
            var myEntities = Board.GetMyEntityCount();
            var oppEntities = Board.GetOppEntityCount();
            if (Turn < 100)
            {
                if (MyProtein[EntityType.A] == 0 && myEntities < oppEntities)
                    winner = -1;
                if (OppProtein[EntityType.A] == 0 && oppEntities < myEntities)
                    winner = 1;
                if (MyProtein[EntityType.A] == 0 && OppProtein[EntityType.A] == 0 && myEntities == oppEntities)
                    winner = 0;
            }
            if (Turn == 100)
            {
                if (myEntities > oppEntities)
                {
                    winner = 1;
                }
                else if (myEntities < oppEntities)
                {
                    winner = -1;
                }
                else
                {
                    if (MyProtein[EntityType.A] > OppProtein[EntityType.A])
                    {
                        winner = 1;
                    }
                    else if (MyProtein[EntityType.A] < OppProtein[EntityType.A])
                    {
                        winner = -1;
                    }
                    else winner = 0;
                }
            }
            return winner;
        }
        public void Print()
        {
            Console.Error.WriteLine(Turn);
            Console.Error.WriteLine(string.Join(',', MyProtein.Values));
            Console.Error.WriteLine(string.Join(',', OppProtein.Values));
            Board.Print();
        }
    }
}
