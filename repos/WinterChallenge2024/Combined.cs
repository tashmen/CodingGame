/*
 * File generated by SourceCombiner.exe using 8 source files.
 * Created On: 12/31/2024 1:56:27 AM
*/
using Algorithms.GameComponent;
using Algorithms.Graph;
using Algorithms.Trees;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
static void Main(string[] args)
{
bool submit = false;
bool showMove = false;
MonteCarloTreeSearch search = new MonteCarloTreeSearch(!submit);
GameState gameState = new GameState();
string[] inputs;
inputs = Console.ReadLine().Split(' ');
int width = int.Parse(inputs[0]); // columns in the game grid
int height = int.Parse(inputs[1]); // rows in the game grid
Stopwatch watch = new Stopwatch();
watch.Start();
Board board = new Board(width, height);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
// game loop
while (true)
{
int entityCount = int.Parse(Console.ReadLine());
List<Entity> entities = new List<Entity>();
for (int i = 0; i < entityCount; i++)
{
inputs = Console.ReadLine().Split(' ');
int x = int.Parse(inputs[0]);
int y = int.Parse(inputs[1]);
string type = inputs[2];
int owner = int.Parse(inputs[3]);
int organId = int.Parse(inputs[4]);
string organDir = inputs[5];
int organParentId = int.Parse(inputs[6]);
int organRootId = int.Parse(inputs[7]);
Entity entity = new Entity(x, y, board.GetNodeIndex(x, y), type, owner, organId, organDir, organParentId, organRootId);
entities.Add(entity);
}
inputs = Console.ReadLine().Split(' ');
int myA = int.Parse(inputs[0]);
int myB = int.Parse(inputs[1]);
int myC = int.Parse(inputs[2]);
int myD = int.Parse(inputs[3]);
inputs = Console.ReadLine().Split(' ');
int oppA = int.Parse(inputs[0]);
int oppB = int.Parse(inputs[1]);
int oppC = int.Parse(inputs[2]);
int oppD = int.Parse(inputs[3]);
int requiredActionsCount = int.Parse(Console.ReadLine());
int[] myProtein = new int[] { myA, myB, myC, myD };
int[] oppProtein = new int[] { oppA, oppB, oppC, oppD };
watch.Start();
GC.Collect();
board.SetEntities(entities, gameState.Turn == 0);
gameState.SetNextTurn(board, myProtein, oppProtein);
search.SetState(gameState, true, false);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
if (showMove)
{
board.GetMoves(gameState.MyProtein, true, true);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
}
Move move = (Move)search.GetNextMove(watch, gameState.Turn > 1 ? 25 : 970, 4, 1);
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
if (!submit)
{
if (watch.ElapsedMilliseconds < 48)
{
gameState.Print();
Console.Error.WriteLine($"ms: {watch.ElapsedMilliseconds}");
}
}
watch.Stop();
watch.Reset();
move.Print();
move.Output();
}
}
}
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 12/27/2024 3:58:05 PM
*/
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms.GameComponent
{
public interface IGameState
{
/// <summary>
/// Retrieve the possible moves
/// </summary>
/// <param name="isMax">Whether or not to retrieve moves for max</param>
/// <returns>list of all possible moves</returns>
IList GetPossibleMoves(bool isMax);
/// <summary>
/// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
/// </summary>
/// <param name="isMax">Whether or not the move is for max</param>
/// <param name="move">the move to apply</param>
void ApplyMove(object move, bool isMax);
/// <summary>
/// Retrieves the move that was played to reach this state.
/// </summary>
/// <param name="isMax">Whether or not the move is for max</param>
/// <returns>The move</returns>
object GetMove(bool isMax);
/// <summary>
/// Clones the game state
/// </summary>
/// <returns>The copy of the state</returns>
IGameState Clone();
/// <summary>
/// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
/// </summary>
/// <returns>Who won the game</returns>
double? GetWinner();
/// <summary>
/// Determines if the game state is the same as this one
/// </summary>
/// <param name="">the state to compare against</param>
/// <returns>true if equal</returns>
bool Equals(IGameState state);
/// <summary>
/// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
/// </summary>
/// <param name="isMax">true if it is max's turn else false</param>
/// <returns>A number between [-1, 1]</returns>
double Evaluate(bool isMax);
}
}
//*** SourceCombiner -> original file Graph.cs ***
namespace Algorithms.Graph
{
public class Graph
{
public class DistancePath
{
public double Distance { get; set; }
public List<ILink> Paths { get; set; }
public DistancePath(double distanc, List<ILink> paths)
{
Distance = distanc;
Paths = paths;
}
}
private readonly Dictionary<int, INode> Nodes;
//Will hold shortest paths from a start node id to an end node id
private Dictionary<int, Dictionary<int, DistancePath>> Paths;
public Graph()
{
Nodes = new Dictionary<int, INode>();
}
public void AddNode(INode node)
{
Nodes[node.Id] = node;
}
/// <summary>
/// Calculates all of the shortest paths in the node links
/// </summary>
public void CalculateShortestPaths()
{
Paths = new Dictionary<int, Dictionary<int, DistancePath>>();
foreach (INode vertex in Nodes.Values)
{
InternalBuildShortestPathsFromStartNode2(vertex);
}
}
public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
{
Paths = new Dictionary<int, Dictionary<int, DistancePath>>();
InternalBuildShortestPathsFromStartNode2(startNode, maxDistance);
}
//With a little help from Chat GPT improved the performance significantly.
private void InternalBuildShortestPathsFromStartNode2(INode startNode, double maxDistance = double.MaxValue)
{
// Initialize exploration state and paths
foreach (INode node in Nodes.Values)
{
node.IsExplored = false;
}
HashSet<ILink> minimumSpanningTree = new HashSet<ILink>();
SortedSet<(double Distance, int StepCount, ILink Link)> priorityQueue = new SortedSet<(double Distance, int StepCount, ILink Link)>(Comparer<(double Distance, int StepCount, ILink Link)>.Create((a, b) =>
{
// Compare first by distance, then by step count (in case of tie)
int result = a.Distance.CompareTo(b.Distance);
if (result != 0) return result;
result = a.StepCount.CompareTo(b.StepCount);
if (result != 0) return result;
return a.Link.EndNodeId.CompareTo(b.Link.EndNodeId);
}));
Paths[startNode.Id] = new Dictionary<int, DistancePath>();
Paths[startNode.Id][startNode.Id] = new DistancePath(0.0, new List<ILink>());
startNode.IsExplored = true;
// Add initial links of the startNode to the priority queue
foreach (ILink link in startNode.GetLinks())
{
priorityQueue.Add((link.Distance, 1, link));  // Distance, StepCount (1), Link
}
while (minimumSpanningTree.Count < Nodes.Count && priorityQueue.Count > 0)
{
// Get the link with the minimum distance and fewest steps
(double currentDist, int stepCount, ILink bestLink) = priorityQueue.Min;
priorityQueue.Remove(priorityQueue.Min);
INode currentNode = Nodes[bestLink.StartNodeId];
INode adjacentNode = Nodes[bestLink.EndNodeId];
if (adjacentNode.IsExplored)
{
continue; // Skip already explored nodes
}
adjacentNode.IsExplored = true;
minimumSpanningTree.Add(bestLink);
// Update paths
if (!Paths[startNode.Id].TryGetValue(currentNode.Id, out DistancePath? currentPath))
{
currentPath = new DistancePath(0.0, new List<ILink>());
}
else
{
currentPath = new DistancePath(currentDist, new List<ILink>(currentPath.Paths)); // Copy the existing path
}
// Add the new link to the current path
currentPath.Paths.Add(bestLink);
// Store the complete path from the start node to the adjacent node
Paths[startNode.Id][bestLink.EndNodeId] = currentPath;
// Exit if the distance exceeds the maximum allowed
if (currentDist >= maxDistance)
return;
// Add adjacent links of the newly explored node to the queue
foreach (ILink adjacentLink in adjacentNode.GetLinks())
{
INode nextNode = Nodes[adjacentLink.EndNodeId];
if (!nextNode.IsExplored)
{
// Calculate the new distance and step count for the adjacent link
double newDist = currentDist + adjacentLink.Distance;
int newStepCount = stepCount + 1;
priorityQueue.Add((newDist, newStepCount, adjacentLink));
}
}
}
}
/// <summary>
/// Retrieves the next node along the path from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The next node in the path</returns>
public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
{
Paths.TryGetValue(startNode.Id, out Dictionary<int, DistancePath> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startNode.Id);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endNode.Id, out DistancePath paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
throw new InvalidOperationException();
}
INode shortest = Nodes[paths.Paths.First().EndNodeId];
Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
return shortest;
}
/// <summary>
/// Retrieves all nodes along the shortest path between two points
/// </summary>
/// <param name="startNodeId">Start node id</param>
/// <param name="endNodeId">End node id</param>
/// <returns>The full path from start to end</returns>
/// <exception cref="InvalidOperationException"></exception>
public IList<ILink> GetShortestPathAll(int startNodeId, int endNodeId)
{
Paths.TryGetValue(startNodeId, out Dictionary<int, DistancePath> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startNodeId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endNodeId, out DistancePath paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endNodeId + " start: " + startNodeId);
throw new InvalidOperationException();
}
return paths.Paths;
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node</param>
/// <param name="endId">The ending node</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(INode startNode, INode endNode)
{
return GetShortestPathDistance(startNode.Id, endNode.Id);
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(int startId, int endId)
{
// Try to get the dictionary of endpoints for the startId
if (!Paths.TryGetValue(startId, out Dictionary<int, DistancePath>? endPoints) || endPoints == null)
{
return double.MaxValue;
}
// Try to get the DistancePath for the endId
if (!endPoints.TryGetValue(endId, out DistancePath? path) || path == null)
{
return double.MaxValue;
}
return path.Distance;
}
/// <summary>
/// Retrieves the straight line distance from start to end
/// </summary>
/// <param name="startId">The starting node</param>
/// <param name="endId">The ending node</param>
/// <returns>The distance from start to end</returns>
public double GetDistance(Node startNode, Node endNode)
{
return startNode.GetLinks().Where(l => l.EndNodeId.Equals(endNode.Id)).First().Distance;
}
}
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
public class GraphLinks
{
public class Node
{
public int Id;
public double Distance;
public bool IsExplored;
public Node(int id, double distance)
{
Id = id;
Distance = distance;
}
/// <summary>
/// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
/// </summary>
/// <param name="currentDist">The current distance from the starting node</param>
/// <returns>A clone of the node with the proper distance</returns>
public Node CreateAtDistance(double currentDist)
{
return new Node(Id, currentDist + Distance);
}
}
private readonly Dictionary<int, List<Node>> Links;
private Dictionary<int, Dictionary<int, List<Node>>> Paths;
private readonly bool IsByDirectional;
public GraphLinks(bool isByDirectional = true)
{
Links = new Dictionary<int, List<Node>>();
IsByDirectional = isByDirectional;
}
public bool ContainsLink(int id1, int id2)
{
return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
}
/// <summary>
/// Adds a link to the list
/// </summary>
/// <param name="id1">First id</param>
/// <param name="id2">Second id</param>
/// <param name="distance">The distance between the two nodes</param>
public void AddLink(int id1, int id2, double distance)
{
//Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
if (ContainsLink(id1, id2))
return;
AddLinkInternal(id1, id2, distance);
if (IsByDirectional)
AddLinkInternal(id2, id1, distance);
}
public void RemoveLink(int id1, int id2)
{
Links[id1].RemoveAll(n => n.Id == id2);
Links[id2].RemoveAll(n => n.Id == id1);
}
/// <summary>
/// Calculates all of the shortest paths in the node links
/// </summary>
public void CalculateShortestPaths()
{
Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
List<int> vertices = Links.Keys.ToList();
int vertexCount = vertices.Count;
foreach (int vertex in vertices)
{
CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
}
}
/// <summary>
/// Calculates the shortest paths from a start node
/// </summary>
/// <param name="startNode">id of the start node</param>
/// <param name="maxDistance">the fartheset distance to travel</param>
public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
{
Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
}
/// <summary>
/// Calculates the shortest paths from the start node to all other nodes
/// </summary>
/// <param name="startNode">The starting id</param>
/// <param name="vertexCount">The number of nodes</param>
/// <param name="maxDistance">the farthest distance to travel</param>
private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
{
List<Node> minimumSpanningTree = new List<Node>();
//Console.Error.WriteLine("Starting with " + startNode);
double currentDist = 0;
Paths[startNode] = new Dictionary<int, List<Node>>();
minimumSpanningTree.Add(new Node(startNode, currentDist));
while (minimumSpanningTree.Count < vertexCount)
{
double minDist = 99999;
Node bestNode = null;
Node parentNode = null;
foreach (Node currentNode in minimumSpanningTree)
{
currentDist = currentNode.Distance;
//Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
foreach (Node adjacent in GetLinks(currentNode.Id))
{
if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
{
adjacent.IsExplored = true;
continue;//skip nodes already in minimum spanning tree
}
double distance = currentDist + adjacent.Distance;
if (distance < minDist)
{
minDist = distance;
bestNode = adjacent.CreateAtDistance(currentDist);
parentNode = currentNode;
}
else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
{
Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
if (lengthCurrent < lengthPrevious)
{
minDist = distance;
bestNode = adjacent.CreateAtDistance(currentDist);
parentNode = currentNode;
}
}
}
}
if (parentNode == null)
{
return;//no possible paths
}
minimumSpanningTree.Add(bestNode);
List<Node> currentPath = null;
if (parentNode.Id != startNode)
{
Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
}
if (currentPath == null)
{
currentPath = new List<Node>();
}
else
{
currentPath = new List<Node>(currentPath);
}
Paths[startNode].Add(bestNode.Id, currentPath);
currentPath.Add(bestNode);
/*
if (startNode == 0)
{
Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
}
*/
if (minDist >= maxDistance)
return;
}
}
/// <summary>
/// Retrieves the links that are adjacent to the given node
/// </summary>
/// <param name="id">The node id</param>
/// <returns></returns>
public List<Node> GetLinks(int id)
{
return Links[id];
}
public Dictionary<int, List<Node>> GetPaths(int startId)
{
return Paths[startId];
}
/// <summary>
/// Retrieves the straight line distance from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance from start to end</returns>
public double GetDistance(int startId, int endId)
{
return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
}
/// <summary>
/// Retrieves the distance following the shortest path from start to end.
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The distance along the shortest path</returns>
public double GetShortestPathDistance(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
return 99999;
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
return 99999;
}
return paths.Last().Distance;
}
/// <summary>
/// Retrieves the next node along the path from start to end
/// </summary>
/// <param name="startId">The starting node id</param>
/// <param name="endId">The ending node id</param>
/// <returns>The factory id that is first in the path</returns>
public int GetShortestPath(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
throw new InvalidOperationException();
}
int shortest = paths.First().Id;
Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
return shortest;
}
/// <summary>
/// Retrieves the full path from start to end
/// </summary>
/// <param name="startId">the start id</param>
/// <param name="endId">the end id</param>
/// <returns>The full path</returns>
public List<Node> GetShortestPathAll(int startId, int endId)
{
Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
if (endPoints == null)
{
Console.Error.WriteLine("|||Start not found: " + startId);
throw new InvalidOperationException();
}
endPoints.TryGetValue(endId, out List<Node> paths);
if (paths == null)
{
Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
throw new InvalidOperationException();
}
return paths;
}
//Adds links to the node links
private void AddLinkInternal(int startNode, int endNode, double distance)
{
List<Node> nodeLinks;
if (Links.ContainsKey(startNode))
{
nodeLinks = Links[startNode];
}
else
{
nodeLinks = new List<Node>();
Links[startNode] = nodeLinks;
}
nodeLinks.Add(new Node(endNode, distance));
}
}
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
public interface INode
{
int Id { get; }
bool IsExplored { get; set; }
List<ILink> GetLinks();
}
public class Node : INode
{
public int Id { get; private set; }
public bool IsExplored { get; set; }
private readonly List<ILink> Links;
public Node(int id)
{
Id = id;
IsExplored = false;
Links = new List<ILink>();
}
public void AddLink(ILink link)
{
Links.Add(link);
}
public List<ILink> GetLinks()
{
return Links;
}
public bool Equals(INode node)
{
return node.Id == Id;
}
}
public interface ILink
{
int StartNodeId { get; }
int EndNodeId { get; }
double Distance { get; }
double GetDistance(List<ILink> currentPath);
}
public class Link : ILink
{
public int StartNodeId { get; private set; }
public int EndNodeId { get; private set; }
public double Distance { get; private set; }
public Link(int startNodeId, int endNodeId, double distance)
{
StartNodeId = startNodeId;
EndNodeId = endNodeId;
Distance = distance;
}
public Link(INode startNode, INode endNode, double distance)
{
StartNodeId = startNode.Id;
EndNodeId = endNode.Id;
Distance = distance;
}
public double GetDistance(List<ILink> currentPath)
{
double distance = 0;
foreach (ILink link in currentPath)
{
distance += link.Distance;
}
return distance;
}
}
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
public class GameTreeNode
{
public IGameState state;
public IList moves;
public List<GameTreeNode> children;
public double wins = 0;
public double loses = 0;
public int totalPlays = 0;
public GameTreeNode parent;
public bool isMax;
public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
{
this.state = state;
moves = state.GetPossibleMoves(isMax);
children = new List<GameTreeNode>(50);
this.parent = parent;
this.isMax = isMax;
}
public double GetScore(bool isMax)
{
if (totalPlays == 0)
return 0;
if (isMax)
{
return (wins - loses) / totalPlays;
}
else
{
return (loses - wins) / totalPlays;
}
}
public double? GetWinner()
{
return state.GetWinner();
}
public void ApplyWinner(double? winner)
{
if (winner.HasValue)
{
if (winner > 0)
{
wins += winner.Value;
}
else if (winner < 0)
{
loses += Math.Abs(winner.Value);
}
totalPlays++;
}
}
public double Evaluate()
{
return state.Evaluate(isMax);
}
}
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms.Trees
{
public class Minimax : TreeAlgorithm
{
public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
{
double val = 99999999;
val *= RootNode.isMax ? -1 : 1;
object bestMove = null;
foreach (object move in RootNode.moves)
{
GameTreeNode child = Expand(RootNode, move);
double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
{
bestMove = move;
val = currentVal;
}
if (watch.ElapsedMilliseconds >= timeLimit)
{
break;
}
}
return bestMove;
}
public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
{
if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
{
double eval = currentNode.Evaluate();
return eval;
}
double? winner = currentNode.GetWinner();
if (winner.HasValue)
{
return winner.Value;
}
if (currentNode.isMax)
{
double value = -99999;
double minMax;
foreach (object move in currentNode.moves)
{
GameTreeNode childNode = Expand(currentNode, move);
minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
value = Math.Max(value, minMax);
alpha = Math.Max(alpha, value);
if (alpha >= beta)
{
break;
}
}
return value;
}
else
{
double value = 99999;
double minMax;
foreach (object move in currentNode.moves)
{
GameTreeNode childNode = Expand(currentNode, move);
minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
value = Math.Min(value, minMax);
beta = Math.Min(beta, value);
if (beta <= alpha)
{
break;
}
}
return value;
}
}
}
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
public class MonteCarloTreeSearch : TreeAlgorithm
{
private readonly Random rand;
private readonly bool printErrors;
private readonly SearchStrategy strategy;
private readonly double[] _mathLogCache;
private static readonly double DefaultExploration = Math.Sqrt(2);
public enum SearchStrategy
{
Random = 0,
Sequential = 1
}
public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random, int mathLogCacheSize = 1000)
{
rand = new Random();
printErrors = showErrors;
strategy = searchStrategy;
_mathLogCache = new double[mathLogCacheSize];
for (int i = 0; i < mathLogCacheSize; i++)
{
_mathLogCache[i] = Math.Log(i);
}
}
public IGameState GetRootState()
{
return RootNode.state;
}
/// <summary>
/// Get the next move
/// </summary>
/// <param name="watch">timer</param>
/// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
/// <param name="depth">How deep to run the simulations; does not impact how deep it goes in the game tree.</param>
/// <param name="numRollouts">The number of roll outs to play per expansion</param>
/// <returns></returns>
public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
{
if (exploration == null)
{
exploration = DefaultExploration;
}
int count = 0;
do
{
GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
if (selectedNode == null)
{
if (printErrors)
Console.Error.WriteLine("Found no more moves!");
break;
}
object move = SelectMove(selectedNode);
GameTreeNode childNode = Expand(selectedNode, move);
if (watch.ElapsedMilliseconds >= timeLimit)
break;
double? winner = childNode.GetWinner();
if (winner.HasValue)
{
BackPropagate(childNode, winner);
count++;
}
else
{
for (int i = 0; i < numRollouts; i++)
{
IGameState clonedState = childNode.state.Clone();
winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
if (!winner.HasValue)
{
if (printErrors)
Console.Error.WriteLine("Did not find a winner in the simulation.");
break;//We simulated a game, but it didn't end so we are out of time...
}
BackPropagate(childNode, winner);
count++;
}
}
}
while (watch.ElapsedMilliseconds < timeLimit);
if (printErrors)
Console.Error.WriteLine($"Played {count} games!");
GameTreeNode bestChild = null;
double bestScore = double.MinValue;
for (int i = 0; i < RootNode.children.Count; i++)
{
GameTreeNode child = RootNode.children[i];
double score = child.GetScore(RootNode.isMax);
if (bestScore < score)
{
bestChild = child;
bestScore = score;
}
if (printErrors)
Console.Error.WriteLine($"w: {(RootNode.isMax ? child.wins : child.loses)} l: {(RootNode.isMax ? child.loses : child.wins)} total: {child.totalPlays} score: {score} isMax: {RootNode.isMax} move: {child.state.GetMove(RootNode.isMax)}");
}
if (printErrors)
Console.Error.WriteLine($"Best: w: {(RootNode.isMax ? bestChild.wins : bestChild.loses)} l: {(RootNode.isMax ? bestChild.loses : bestChild.wins)} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
return bestChild.state.GetMove(RootNode.isMax);
}
private void BackPropagate(GameTreeNode selectedNode, double? winner)
{
selectedNode.ApplyWinner(winner);
GameTreeNode tempNode = selectedNode.parent;
while (tempNode != null)
{
tempNode.ApplyWinner(winner);
tempNode = tempNode.parent;
}
}
private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
{
double? winner;
do
{
if (watch.ElapsedMilliseconds >= timeLimit)
{
return null;
}
object move = SelectMoveAtRandom(state, isMax);
state.ApplyMove(move, isMax);
depth--;
isMax = !isMax;
if (watch.ElapsedMilliseconds >= timeLimit)
{
return null;
}
winner = state.GetWinner();
}
while (!winner.HasValue && depth != 0);
if (winner.HasValue)
{
return winner;
}
if (depth == 0)
{
double eval = state.Evaluate(isMax);
if (eval > 1)
{
return 1;
}
else if (eval < -1)
return -1;
else return eval;
}
Console.Error.WriteLine("Could not find a winner for simulation!");
throw new InvalidOperationException("Could not find a winner for simulation!");
}
private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
{
if (node.moves.Count > 0 && node.parent == null)
return node;
Queue<GameTreeNode> queue = new Queue<GameTreeNode>(100);
queue.Enqueue(node);
GameTreeNode bestNode = null;
double maxValue = -1;
while (queue.Count > 0)
{
GameTreeNode tempNode = queue.Dequeue();
if (tempNode.moves.Count > 0)
{
double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
double nodeTotal = tempNode.totalPlays;
int parentTotal = tempNode.parent.totalPlays;
double parentLog = _mathLogCache[parentTotal];
double value = wins / nodeTotal + exploration * Math.Sqrt(parentLog / nodeTotal);
if (value > maxValue)
{
maxValue = value;
bestNode = tempNode;
}
}
else
{
// Enqueue all children for further processing
for (int i = 0; i < tempNode.children.Count; i++)
{
queue.Enqueue(tempNode.children[i]);
}
}
}
return bestNode;
}
private object SelectMoveAtRandom(IGameState state, bool isMax)
{
IList moves = state.GetPossibleMoves(isMax);
if (moves.Count == 0)
{
Console.Error.WriteLine("No moves available!");
throw new Exception("No moves available!");
}
int index = rand.Next(0, moves.Count);
return moves[index];
}
private object SelectMove(GameTreeNode node)
{
switch (strategy)
{
case SearchStrategy.Random:
return SelectMoveAtRandom(node);
case SearchStrategy.Sequential:
return SelectMoveSequentially(node);
}
Console.Error.WriteLine("strategy not supported");
throw new InvalidOperationException("strategy not supported");
}
private object SelectMoveSequentially(GameTreeNode node)
{
object move;
if (node.moves.Count == 0)//If there are no more moves then that is a problem...
{
Console.Error.WriteLine("No moves found!");
throw new Exception("No moves found!");
}
else
{
move = node.moves[0];
node.moves.RemoveAt(0);
}
return move;
}
private object SelectMoveAtRandom(GameTreeNode node)
{
object move;
if (node.moves.Count == 0)//If there are no more moves then that is a problem...
{
Console.Error.WriteLine("No moves found!");
throw new Exception("No moves found!");
}
else
{
int index = rand.Next(0, node.moves.Count);
move = node.moves[index];
node.moves.RemoveAt(index);
}
return move;
}
}
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms.Trees
{
public class TreeAlgorithm
{
protected GameTreeNode RootNode;
public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
{
if (RootNode != null && findState)
{
//if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
//find the child that matches the new node
bool isFound = false;
//Expand any moves left in the root node (if any)
for (int i = 0; i < RootNode.moves.Count; i++)
{
object? move = RootNode.moves[i];
Expand(RootNode, move);
}
//Begin scanning the children
for (int i = 0; i < RootNode.children.Count; i++)
{
GameTreeNode child = RootNode.children[i];
if (child.state.Equals(rootState))
{
RootNode = child;
isFound = true;
break;
}
for (int j = 0; j < child.moves.Count; j++)
{
object? move = child.moves[j];
Expand(child, move);
}
for (int j = 0; j < child.children.Count; j++)
{
GameTreeNode descendent = child.children[j];
if (descendent.state.Equals(rootState))
{
RootNode = descendent;
isFound = true;
break;
}
}
}
if (!isFound)
{
Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
RootNode = new GameTreeNode(rootState.Clone(), isMax);
}
else
{
RootNode.parent = null;
}
}
else
{
RootNode = new GameTreeNode(rootState.Clone(), isMax);
}
}
/// <summary>
/// Expands the given node by create a clone, applying the move and then adding it to the list of children.
/// </summary>
/// <param name="node">The node to expand</param>
/// <param name="move">The move to play on the expanded node</param>
/// <returns></returns>
protected GameTreeNode Expand(GameTreeNode node, object move)
{
IGameState nextState = node.state.Clone();
nextState.ApplyMove(move, node.isMax);
GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
node.children.Add(childNode);
return childNode;
}
}
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
public static class BitFunctions
{
public static bool IsBitSet(long value, int location)
{
long mask = GetBitMask(location);
return (value & mask) == mask;
}
public static long SetBit(long value, int location)
{
return value | (GetBitMask(location));
}
public static long ClearBit(long value, int location)
{
return value & (~(GetBitMask(location)));
}
public static long SetOrClearBit(long value, int location, bool isSet)
{
if (isSet)
return SetBit(value, location);
return ClearBit(value, location);
}
public static int NumberOfSetBits(long i)
{
i = i - ((i >> 1) & 0x5555555555555555);
i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
}
public static long GetBitMask(int index)
{
return (long)1 << index;
}
}
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
public class Board
{
public int Width { get; private set; }
public int Height { get; private set; }
private Entity[] Entities { get; set; }
public int GlobalOrganId { get; set; } = -1;
public Graph Graph { get; set; }
public static OrganDirection[] PossibleDirections = new OrganDirection[] { OrganDirection.North, OrganDirection.South, OrganDirection.East, OrganDirection.West };
public Board(int width, int height)
{
Width = width;
Height = height;
Entities = new Entity[Width * Height];
Graph = new Graph();
InitializeBoard();
UpdateBoard();
}
public Board(Board board)
{
Width = board.Width;
Height = board.Height;
Entities = board.Entities.ToArray();
GlobalOrganId = board.GlobalOrganId;
Graph = board.Graph;
_entityCache = board._entityCache;
_moveActionCache = board._moveActionCache;
_locationCheckCache = board._locationCheckCache;
_myEntityCount = board._myEntityCount;
_oppEntityCount = board._oppEntityCount;
_locationCache = board._locationCache;
_locationIndexCache = board._locationIndexCache;
_locationNeighbors = board._locationNeighbors;
_intToStringCache = board._intToStringCache;
_isOpenSpaceInitial = board._isOpenSpaceInitial;
}
public bool Equals(Board board)
{
if (Width != board.Width || Height != board.Height)
return false;
for (int x = 0; x < Width; x++)
{
for (int y = 0; y < Height; y++)
{
board.GetEntity(GetNodeIndex(x, y), out Entity entity);
GetEntity(GetNodeIndex(x, y), out Entity currentEntity);
if (entity == null && currentEntity == null)
continue;
if (entity == null && currentEntity != null)
return false;
if (entity != null && currentEntity == null)
return false;
else if (!entity.Equals(currentEntity))
return false;
}
}
return true;
}
public void Attack()
{
List<Entity> tentacles = GetTentacleEntities();
List<Entity> deadEntities = new List<Entity>();
foreach (Entity tentacle in tentacles)
{
if (GetEntityWithDirection(tentacle.Location, tentacle.OrganDirection, out Entity entity) && entity.IsMine.HasValue && entity.IsMine != tentacle.IsMine)
{
deadEntities.Add(entity);
}
}
foreach (Entity deadEntity in deadEntities)
{
if (deadEntity.Type == EntityType.ROOT)
{
IEnumerable<Entity> deathToRoot = GetEntitiesList().Where(e => e.OrganRootId == deadEntity.OrganId);
foreach (Entity kill in deathToRoot)
{
Entities[kill.Location.index] = null;
}
}
else
{
IEnumerable<Entity> deathToChildren = GetEntitiesList().Where(e => e.OrganParentId == deadEntity.OrganId);
foreach (Entity kill in deathToChildren)
{
Entities[kill.Location.index] = null;
}
}
}
}
public void ApplyMove(Move myMove, Move oppMove)
{
foreach (MoveAction action in myMove.Actions)
{
if (action.Type != MoveType.WAIT)
{
IEnumerable<MoveAction> collisionActions = oppMove.Actions.Where(a => (a.Type == MoveType.GROW || a.Type == MoveType.SPORE) && a.Location.Equals(action.Location));
if (collisionActions.Count() > 0)
{
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, EntityType.WALL, null, 0, 0, 0, OrganDirection.None);
}
else
{
ApplyAction(action, true);
}
}
}
foreach (MoveAction action in oppMove.Actions)
{
ApplyAction(action, false);
}
}
public void ApplyAction(MoveAction action, bool isMine)
{
switch (action.Type)
{
case MoveType.GROW:
Entity growEntity = Entities[GetNodeIndex(action.Location)];
if (growEntity == null || growEntity.IsOpenSpace())
{
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, action.EntityType, isMine, GlobalOrganId++, action.OrganId, action.OrganRootId, action.OrganDirection);
}
break;
case MoveType.SPORE:
Entity sporeEntity = Entities[GetNodeIndex(action.Location)];
if (sporeEntity == null || sporeEntity.IsOpenSpace())
{
int organId = GlobalOrganId++;
Entities[GetNodeIndex(action.Location)] = new Entity(action.Location, action.EntityType, isMine, organId, organId, organId, action.OrganDirection);
}
break;
}
}
public class ProteinInfo
{
public int[] Proteins;
public bool[] HasProteins;
public bool HasHarvestProteins;
public bool HasBasicProteins;
public bool HasTentacleProteins;
public bool HasSporerProteins;
public bool HasRootProteins;
public bool[] HasManyProteins;
public bool HasManyRootProteins;
public bool HasManyTentacleProteins;
public bool HasManySporerProteins;
public bool HasAtLeastTwoMany;
public ProteinInfo(int[] proteins)
{
Proteins = proteins;
HasProteins = proteins.Select(p => p > 0).ToArray();
HasHarvestProteins = HasProteins[2] && HasProteins[3];
HasBasicProteins = HasProteins[0];
HasTentacleProteins = HasProteins[1] && HasProteins[2];
HasSporerProteins = HasProteins[1] && HasProteins[3];
HasRootProteins = HasProteins.All(m => m);
HasManyProteins = proteins.Select(p => p > 10).ToArray();
HasManyRootProteins = HasManyProteins.All(m => m);
HasManyTentacleProteins = HasManyProteins[1] && HasManyProteins[2];
HasManySporerProteins = HasManyProteins[1] && HasManyProteins[3];
HasAtLeastTwoMany = HasManyProteins.Count(value => value) > 1;
}
}
//15, 16, 27 actions max
readonly int[] _maxActionsPerOrganism = new int[5] { 10, 3, 2, 1, 1 };
public List<Move> GetMoves(int[] proteins, bool isMine, bool debug = false)
{
List<Move> moves = new List<Move>();
List<Entity> rootEntities = GetRootEntities(isMine);
int organismCount = rootEntities.Count;
bool[] organismHasMoves = new bool[organismCount];
MoveAction[][] organismToMoveActions = new MoveAction[organismCount][];
ProteinInfo proteinInfo = new ProteinInfo(proteins);
int i = 0;
int maxOrgans = 5;//Put a limit on the number of organs we calculate moves for as this is exploding the action space
List<Entity> limitedRootEntities = rootEntities;
if (organismCount > maxOrgans)
{
limitedRootEntities = rootEntities.Take(maxOrgans).ToList();
}
int selectedOrgans = limitedRootEntities.Count;
bool hasSufficientProteins = (proteins[0] >= selectedOrgans || proteins[0] == 0) && (proteins[1] >= selectedOrgans || proteins[1] == 0) && (proteins[2] >= selectedOrgans || proteins[2] == 0) && (proteins[3] >= selectedOrgans || proteins[3] == 0);//Checks for 0 because if we don't have any of that protein then we won't have actions of that type.
HashSet<int> locationsTaken = new HashSet<int>();
foreach (Entity root in limitedRootEntities)
{
List<MoveAction> moveActions = new List<MoveAction>();
bool sporeHasPriority = organismCount < 2 || proteinInfo.HasManyRootProteins;
if (proteinInfo.HasRootProteins && sporeHasPriority)
{
AddSporeMoveActions(moveActions, root.OrganRootId, isMine, locationsTaken);
if (debug)
Console.Error.WriteLine($"Spore: {root.OrganRootId}: " + string.Join('\n', moveActions));
if (moveActions.Count > 0)
{
moveActions = moveActions.OrderBy(m => m.Score).ToList();
if (moveActions[0].Score < 0)
{
moveActions = moveActions.Where(m => m.Score < 0).ToList();
organismHasMoves[i] = true;
}
}
}
if (moveActions.Count <= 0 || !sporeHasPriority)
{
AddGrowMoveActions(moveActions, root.OrganRootId, isMine, proteinInfo, locationsTaken, debug);
if (moveActions.Count > 0)
{
moveActions = moveActions.OrderBy(m => m.Score).Take(_maxActionsPerOrganism[limitedRootEntities.Count - 1]).ToList();
if (moveActions[0].Score < 0)
{
moveActions = moveActions.Where(m => m.Score < 0).ToList();
organismHasMoves[i] = true;
}
}
}
locationsTaken.UnionWith(moveActions.Select(m => m.Location.index));
if (organismCount == 1 && moveActions.Count > 0)
{
}
else
{
if (moveActions.Count > 0 && hasSufficientProteins)
{
}
else
moveActions.Add(MoveAction.CreateWait());
}
organismToMoveActions[i] = moveActions.ToArray();
if (debug)
Console.Error.WriteLine($"{root.OrganId}: " + string.Join('\n', moveActions));
i++;
}
for (; i < organismCount; i++)
{
organismToMoveActions[i] = new MoveAction[]
{
MoveAction.CreateWait()
};
}
if (organismCount > 1)
{
//When some organism has good moves to play then prune the left over moves that aren't as good.
bool hasAtLeastOneMove = organismHasMoves.Any(m => m);
if (hasAtLeastOneMove)
{
for (int a = 0; a < organismCount; a++)
{
if (!organismHasMoves[a])
{
if (debug)
Console.Error.WriteLine($"Pruning moves for {a}");
organismToMoveActions[a] = new MoveAction[]
{
MoveAction.CreateWait()
};
}
}
}
if (debug)
{
foreach (MoveAction[] organMoves in organismToMoveActions)
{
Console.Error.WriteLine($"{organMoves[0].OrganRootId}: " + string.Join('\n', organMoves.AsEnumerable()));
}
Console.Error.WriteLine($"Proteins: " + string.Join(",", proteins));
}
IEnumerable<Move> theMoves = PrunedCartesianProduct(organismToMoveActions, hasSufficientProteins, proteins);
moves = theMoves.ToList();
if (debug)
Console.Error.WriteLine($"Final set: {moves.Count}");
}
else if (organismCount == 1)
{
foreach (MoveAction action in organismToMoveActions[0])
{
Move move = new Move();
move.SetActions(new MoveAction[] { action });
moves.Add(move);
}
}
else
{
//Since we don't check game end conditions until after a move occurs, when there is an attack that kills the last root entity then we can end up in this situation so just give a wait action and do nothing.  The game is over.
Move move = new Move();
move.SetActions(new MoveAction[]
{
MoveAction.CreateWait()
});
moves.Add(move);
}
if (moves.Count == 0)
{
if (!debug)
GetMoves(proteins, isMine, true);
}
return moves;
}
public bool ValidateCost(int[] proteins, Move move)
{
int[] theCosts = move.GetCost();
for (int i = 0; i < 4; i++)
{
if (proteins[i] < theCosts[i])
return false;
}
return true;
}
//should be faster with pruning
public IEnumerable<Move> PrunedCartesianProduct(MoveAction[][] sequences, bool hasSufficientProteins, int[] proteins)
{
if (sequences == null || sequences.Length == 0)
yield break;
MoveAction[][] sequenceArrays = sequences;
int dimensions = sequenceArrays.Length;
// Indexes to keep track of positions in each sequence
int[] indices = new int[dimensions];
// Pre-allocate arrays for partial costs and collisions
int[][] partialCosts = new int[dimensions][];
HashSet<int>[] partialCollision = new HashSet<int>[dimensions];
for (int i = 0; i < dimensions; i++)
{
partialCosts[i] = new int[4]; // Assuming a constant size for protein cost array
partialCollision[i] = new HashSet<int>();
}
int[] initialCost = new int[4] { 0, 0, 0, 0 };
HashSet<int> initialCollision = new HashSet<int>();
MoveAction[] currentCombination = new MoveAction[dimensions];
int position = 0;
while (true)
{
bool hasCollision = false;
bool hasProteins = true;
// Build the current combination
int i;
for (i = position; i < dimensions; i++)
{
// Reuse partial costs and collisions arrays instead of re-allocating them
if (i > 0)
{
Array.Copy(partialCosts[i - 1], partialCosts[i], partialCosts[i - 1].Length);
partialCollision[i] = new HashSet<int>(partialCollision[i - 1]);
}
else
{
Array.Copy(initialCost, partialCosts[i], initialCost.Length);
partialCollision[i] = new HashSet<int>(initialCollision);
}
currentCombination[i] = sequenceArrays[i][indices[i]];
// Update partial costs for each protein based on current combination
if (!hasSufficientProteins)
{
int[] cost = currentCombination[i].GetCost();
for (int j = 0; j < proteins.Length; j++)
{
partialCosts[i][j] += cost[j];
if (partialCosts[i][j] > proteins[j])
{
hasProteins = false;
break;
}
}
if (!hasProteins)
{
break;
}
}
// Update partial collisions
if (ValidateLocation(currentCombination[i].Location))
{
if (!partialCollision[i].Add(currentCombination[i].Location.index))
{
hasCollision = true;
break;
}
}
}
// Validate the combination
if (!hasCollision && (hasSufficientProteins || hasProteins))
{
Move move = new Move();
move.SetActions(currentCombination.ToArray());
yield return move;
position = dimensions - 1;
}
else
{
if (position < i)
position = i;
}
// Increment indices iteratively
while (position >= 0)
{
indices[position]++;
if (indices[position] < sequenceArrays[position].Length)
break;
// Reset this position and move to the next
indices[position] = 0;
position--;
}
// Terminate if we've exhausted all combinations
if (position < 0)
break;
}
}
public List<MoveAction> AddSporeMoveActions(List<MoveAction> moveActions, int organRootId, bool isMine, HashSet<int> locationsTaken)
{
IEnumerable<Entity> sporers = GetSporerEntities(organRootId, isMine);
foreach (Entity sporer in sporers)
{
Point2d location = sporer.Location;
int distance = 0;
while (true)
{
distance++;
location = GetNextLocation(location, sporer.OrganDirection);
if (ValidateLocation(location) && IsOpenSpace(location.index, isMine))
{
if (distance <= 3 || locationsTaken.Contains(location.index))
{
continue;
}
bool? isHarvesting = IsHarvesting(location, isMine);
MoveAction sporeMove = MoveAction.CreateSpore(sporer.OrganId, location);
moveActions.Add(sporeMove);
if (!(isHarvesting.HasValue && isHarvesting.Value) && IsHarvestExactly2spaces(location))
{
sporeMove.Score = -1000;
}
else
{
sporeMove.Score = 1000;
}
}
else
{
break;
}
if (moveActions.Count > 2)
{
break;
}
}
}
return moveActions;
}
public List<MoveAction> AddGrowMoveActions(List<MoveAction> moveActions, int organRootId, bool isMine, ProteinInfo proteinInfo, HashSet<int> locationsTaken, bool debug = false)
{
List<MoveAction> growMoveActions = GetGrowMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
if (debug)
{
Console.Error.WriteLine($"All: {organRootId}: " + string.Join('\n', growMoveActions));
}
bool canHarvest = false;
List<MoveAction> harvestActions = new List<MoveAction>();
if (proteinInfo.HasHarvestProteins)
{
harvestActions = GetHarvestMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
moveActions.AddRange(harvestActions);
canHarvest = harvestActions.Count > 0;
if (debug)
Console.Error.WriteLine($"Harvest: {organRootId}: " + string.Join('\n', harvestActions));
}
List<MoveAction> tentacleActions = new List<MoveAction>();
if (proteinInfo.HasTentacleProteins)
{
tentacleActions = GetTentacleMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
moveActions.AddRange(tentacleActions);
if (debug)
Console.Error.WriteLine($"Tentacle: {organRootId}: " + string.Join('\n', tentacleActions));
}
if (proteinInfo.HasBasicProteins)
{
List<MoveAction> basicActions = GetGrowBasicMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
if (harvestActions.Any(m => m.Score < 0))
basicActions.ForEach(m => m.Score += 100);//Prefer harvest actions over basics
if (tentacleActions.Any(m => m.Score < 0))
basicActions.ForEach(m => m.Score += 100);//Prefer tentacle actions over basics
if (proteinInfo.HasManyTentacleProteins)
basicActions.Join(tentacleActions, m1 => m1.Location, m2 => m2.Location, (m1, m2) => m1).ToList().ForEach(a => a.Score += 100);//Prefer tentacle actions over basics.
moveActions.AddRange(basicActions);
if (debug)
Console.Error.WriteLine($"Basic: {organRootId}: " + string.Join('\n', basicActions));
}
if (proteinInfo.HasSporerProteins)
{
List<MoveAction> sporerActions = GetSporerMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
if (harvestActions.Any(m => m.Score < 0))
sporerActions.ForEach(m => m.Score += 100);//Prefer harvest actions over sporers
if (tentacleActions.Any(m => m.Score < 0))
sporerActions.ForEach(m => m.Score += 100);//Prefer tentacle actions over sporers
if (!proteinInfo.HasRootProteins)
sporerActions.ForEach(m => m.Score += 100);
moveActions.AddRange(sporerActions);
if (debug)
Console.Error.WriteLine($"Sporer: {organRootId}: " + string.Join('\n', sporerActions));
}
return moveActions;
}
public List<MoveAction> GetSporerMoveActions(int organRootId, bool isMine, HashSet<int> locationsTaken, ProteinInfo proteinInfo)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
foreach (MoveAction growAction in growMoveActions)
{
List<MoveAction> sporerMoves = new List<MoveAction>();
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(growAction.Location))
{
MoveAction sporerAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.SPORER, growAction.OrganRootId, locationNeighbor.direction);
sporerAction.Score = growAction.Score;
Point2d location = growAction.Location;
bool isOpen = true;
for (int i = 0; i < 4; i++)
{
location = GetNextLocation(location, locationNeighbor.direction);
if (!ValidateLocation(location) || !IsOpenSpace(location.index, isMine))
{
isOpen = false;
break;
}
}
if (isOpen)
{
sporerAction.Score -= 100;
sporerMoves.Add(sporerAction);
}
}
if (sporerMoves.Count > 0)
{
moveActions.AddRange(sporerMoves);
}
else
{
MoveAction moveAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.SPORER, growAction.OrganRootId);
moveAction.Score = growAction.Score;
moveAction.Score += 1000;
moveActions.Add(moveAction);
}
}
return moveActions;
}
public List<MoveAction> GetTentacleMoveActions(int organRootId, bool isMine, HashSet<int> locationsTaken, ProteinInfo proteinInfo)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
foreach (MoveAction growAction in growMoveActions)
{
List<MoveAction> tentacleMoveActions = new List<MoveAction>();
//Could suggest the direction based on the shortest path.
bool isOppIn3Spaces = IsOpponentWithin3Spaces(growAction.Location, isMine);
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(growAction.Location))
{
MoveAction tentacleAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.TENTACLE, growAction.OrganRootId, locationNeighbor.direction);
tentacleAction.Score = growAction.Score;
if (IsOpponentOrEmptySpace(locationNeighbor.point.index, isMine))
{
tentacleMoveActions.Add(tentacleAction);
if (isOppIn3Spaces)
{
tentacleAction.Score -= 50;
//Check to see if any are facing the enemy and use those as priority
if (GetEntity(locationNeighbor.point.index, out Entity entity) && entity.IsMine.HasValue && entity.IsMine != isMine)
{
tentacleAction.Score -= 50000;
if (entity.Type == EntityType.ROOT && GetEntitiesByRoot(entity.OrganId, !isMine).Count > 1)
{
tentacleAction.Score -= 50000;//hit the root!
return new List<MoveAction> { tentacleAction };//Destroying roots should always be the priority
}
}
}
}
}
if (tentacleMoveActions.Count > 0)
{
double best = tentacleMoveActions.Min(m => m.Score);
moveActions.AddRange(tentacleMoveActions.Where(m => m.Score == best));
}
else
{
MoveAction moveAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.TENTACLE, growAction.OrganRootId, OrganDirection.North);
moveAction.Score = growAction.Score;
moveAction.Score += 10000;
moveActions.Add(moveAction);
}
}
return moveActions;
}
private Dictionary<string, List<MoveAction>> _moveActionCache = new Dictionary<string, List<MoveAction>>();
private const int _maxMoves = 5;
public List<MoveAction> GetGrowMoveActions(int organRootId, bool isMine, HashSet<int> locationsTaken, ProteinInfo proteinInfo)
{
string key = (isMine ? "grow1_" : "grow0_") + organRootId.ToString();
if (!_moveActionCache.TryGetValue(key, out List<MoveAction> moveActions))
{
List<Entity> oppRootEntities = GetRootEntities(!isMine);
List<Entity> harvestableEntities = GetHarvestableEntities();
List<Entity> harvestingEntities = GetHarvestedEntities(isMine);
HashSet<EntityType> harvestedTypes = harvestingEntities.Select(e => e.Type).ToHashSet();
List<Entity> toHarvestEntities = harvestedTypes.Count < 4 ? harvestableEntities.Where(e => !harvestedTypes.Contains(e.Type)).ToList() : new List<Entity>();
bool hasOppRoot = oppRootEntities.Any();
bool hasHarvestable = toHarvestEntities.Any();
moveActions = new List<MoveAction>();
List<Entity> entities = GetEntitiesByRoot(organRootId, isMine);
HashSet<int> locationsChecked = new HashSet<int>(locationsTaken);
foreach (Entity entity in entities)
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(entity.Location))
{
if (locationsChecked.Add(locationNeighbor.point.index) && IsOpenSpace(locationNeighbor.point.index, isMine))
{
MoveAction moveAction = MoveAction.CreateGrow(entity.OrganId, locationNeighbor.point, EntityType.NONE, entity.OrganRootId);
moveAction.Score = 0;
if (hasHarvestable)
{
moveAction.Score += toHarvestEntities.Min(r => Graph.GetShortestPathDistance(r.Location.index, moveAction.Location.index));
}
else if (hasOppRoot)
{
moveAction.Score += oppRootEntities.Min(r => Graph.GetShortestPathDistance(r.Location.index, moveAction.Location.index));
}
bool? isHarvesting = IsHarvesting(locationNeighbor.point.index, isMine);
if (isHarvesting.HasValue)
{
if (GetEntity(locationNeighbor.point.index, out Entity harvestEntity) && !proteinInfo.HasHarvestProteins && (harvestEntity.Type == EntityType.C || harvestEntity.Type == EntityType.D))
{
moveAction.Score -= 1000;//if we have no C/D then eat it.  We need C/D to build harvesters
}
bool isOppIn3Spaces = IsOpponentWithin3Spaces(moveAction.Location, isMine);
if (isHarvesting.Value && !isOppIn3Spaces)
{
moveAction.Score += 1000;
}
if (isOppIn3Spaces)
{
moveAction.Score -= 20;//Give higher priority to spaces where the opponent is near
}
}
moveActions.Add(moveAction);
}
}
}
if (moveActions.Count > _maxMoves)
{
moveActions = moveActions.OrderBy(m => m.Score).Take(_maxMoves).ToList();
}
_moveActionCache[key] = moveActions;
}
return moveActions;
}
public List<MoveAction> GetGrowBasicMoveActions(int organRootId, bool isMine, HashSet<int> locationsTaken, ProteinInfo proteinInfo)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
List<MoveAction> growBasicActions = new List<MoveAction>();
foreach (MoveAction growAction in growMoveActions)
{
MoveAction moveAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.BASIC, growAction.OrganRootId);
moveAction.Score = growAction.Score;
moveAction.Score -= 30;
growBasicActions.Add(moveAction);
}
if (growBasicActions.Count > 0)
{
double best = growBasicActions.Min(m => m.Score);
moveActions.AddRange(growBasicActions.Where(m => m.Score == best));
}
return moveActions;
}
public List<MoveAction> GetHarvestMoveActions(int organRootId, bool isMine, HashSet<int> locationsTaken, ProteinInfo proteinInfo)
{
List<MoveAction> moveActions = new List<MoveAction>();
List<MoveAction> growMoveActions = GetGrowMoveActions(organRootId, isMine, locationsTaken, proteinInfo);
foreach (MoveAction growAction in growMoveActions)
{
bool isOppIn3Spaces = IsOpponentWithin3Spaces(growAction.Location, isMine);
List<MoveAction> harvestActions = new List<MoveAction>();
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(growAction.Location))
{
bool? isHarvesting = IsHarvesting(locationNeighbor.point.index, isMine);
MoveAction harvestAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId, locationNeighbor.direction);
harvestAction.Score = growAction.Score;
if (isOppIn3Spaces)
{
harvestAction.Score += 1000;
}
if (isHarvesting.HasValue && !isHarvesting.Value)
{
harvestAction.Score -= 500;
}
if (harvestAction.Score < 0)
{
harvestActions.Add(harvestAction);
}
}
if (harvestActions.Count > 0)
{
moveActions.AddRange(harvestActions);
}
else
{
MoveAction moveAction = MoveAction.CreateGrow(growAction.OrganId, growAction.Location, EntityType.HARVESTER, growAction.OrganRootId);
moveAction.Score = growAction.Score;
moveAction.Score += 1000;
moveActions.Add(moveAction);
}
}
return moveActions;
}
public bool? IsHarvesting(int location, bool isMine)
{
if (IsHarvestSpace(location))
{
foreach (LocationNeighbor locationNeighbor in GetLocationNeighbors(location))
{
if (GetEntity(locationNeighbor.point.index, out Entity entity) && entity.Type == EntityType.HARVESTER && entity.IsMine.HasValue && entity.IsMine == isMine && entity.OrganDirection == GetOpposingDirection(locationNeighbor.direction))
{
return true;
}
}
return false;
}
return null;
}
public bool? IsHarvesting(Point2d location, bool isMine)
{
if (ValidateLocation(location))
{
return IsHarvesting(location.index, isMine);
}
return null;
}
public bool IsFull()
{
foreach (Entity entity in Entities)
{
if (entity == null)
{
return false;
}
}
return true;
}
public int[] GetHarvestProteins(bool isMine)
{
List<Entity> harvesters = GetHarvesterEntities(isMine);
int[] harvestedProteins = new int[4] { 0, 0, 0, 0 };
foreach (Entity harvester in harvesters)
{
if (GetEntityWithDirection(harvester.Location, harvester.OrganDirection, out Entity entity) && entity.IsOpenSpace())
{
harvestedProteins[entity.Type - EntityType.A]++;
}
}
return harvestedProteins;
}
public OrganDirection GetOpposingDirection(OrganDirection direction)
{
switch (direction)
{
case OrganDirection.North:
return OrganDirection.South;
case OrganDirection.South:
return OrganDirection.North;
case OrganDirection.East:
return OrganDirection.West;
case OrganDirection.West:
return OrganDirection.East;
}
throw new Exception("No direction given");
}
public bool IsHarvestExactly2spaces(Point2d location)
{
List<Entity> harvestEntities = GetHarvestableEntities();
foreach (Entity entity in harvestEntities)
{
if (location.Equals(entity.Location))
continue;
double distance = Graph.GetShortestPathDistance(location.index, entity.Location.index);
if (distance == 2)
{
return true;
}
}
return false;
}
Dictionary<string, bool> _locationCheckCache;
public bool IsOpponentWithin3Spaces(Point2d location, bool isMine)
{
string key = (isMine ? "opponentclose_1" : "opponentclose_2") + location.index.ToString();
if (!_locationCheckCache.TryGetValue(key, out bool result))
{
List<Entity> oppEntities = GetEntities(!isMine);
foreach (Entity oppEntity in oppEntities)
{
double distance = Graph.GetShortestPathDistance(location.index, oppEntity.Location.index);
if (distance <= 3)
{
result = true;
_locationCheckCache[key] = result;
return result;
}
}
result = false;
_locationCheckCache[key] = result;
}
return result;
}
public bool IsOpponentOrEmptySpace(int index, bool isMine)
{
return !GetEntity(index, out Entity entity) || entity.IsOpenSpace() || (entity.IsMine.HasValue && entity.IsMine != isMine);
}
public bool IsOpponentSpace(Point2d location, OrganDirection direction, bool isMine)
{
return GetEntityWithDirection(location, direction, out Entity entity) && entity.IsMine != isMine;
}
public bool IsHarvestSpace(int location)
{
return GetEntity(location, out Entity entity) && entity.IsOpenSpace();
}
public bool IsHarvestSpace(Point2d location, OrganDirection nextDirection)
{
return GetEntityWithDirection(location, nextDirection, out Entity entity) && entity.IsOpenSpace();
}
private bool IsOpenSpace(int location)
{
return !GetEntity(location, out Entity entity) || entity.IsOpenSpace();
}
private string[] _intToStringCache;
private bool[] _isOpenSpaceInitial;
public bool IsOpenSpace(int location, bool isMine)
{
if (!_isOpenSpaceInitial[location] || !IsOpenSpace(location))
{
return false;
}
string key = $"{(isMine ? "openspace_1" : "openspace_2")}{_intToStringCache[location]}";
// Check cache
if (_locationCheckCache.TryGetValue(key, out bool result))
{
return result;
}
result = !HasOpposingTentacle(location, isMine);
// Cache and return the result
_locationCheckCache[key] = result;
return result;
}
// Helper method to check for opposing tentacles
private bool HasOpposingTentacle(int location, bool isMine)
{
foreach (LocationNeighbor neighbor in GetLocationNeighbors(location))
{
if (GetEntity(neighbor.point.index, out Entity entity) &&
entity.Type == EntityType.TENTACLE &&
entity.IsMine != isMine &&
GetOpposingDirection(entity.OrganDirection) == neighbor.direction)
{
return true;
}
}
return false;
}
public bool ValidateLocation(Point2d location, OrganDirection nextDirection)
{
return ValidateLocation(GetNextLocation(location, nextDirection));
}
public bool ValidateLocation(Point2d location)
{
return location != null;
}
public bool GetEntityWithDirection(Point2d currentLocation, OrganDirection nextDirection, out Entity entity)
{
Point2d location = GetNextLocation(currentLocation, nextDirection);
entity = null;
return ValidateLocation(location) && GetEntity(location, out entity);
}
public Point2d GetNextLocation(Point2d currentLocation, OrganDirection nextDirection)
{
return _locationCache[(int)currentLocation.x + 1][(int)currentLocation.y + 1][(int)nextDirection];
}
private Point2d GetNextLocationInternl(int x, int y, OrganDirection nextDirection)
{
switch (nextDirection)
{
case OrganDirection.North:
return new Point2d(x, y - 1, GetNodeIndexInternal(x, y - 1));
case OrganDirection.South:
return new Point2d(x, y + 1, GetNodeIndexInternal(x, y + 1));
case OrganDirection.East:
return new Point2d(x + 1, y, GetNodeIndexInternal(x + 1, y));
case OrganDirection.West:
return new Point2d(x - 1, y, GetNodeIndexInternal(x - 1, y));
default:
return new Point2d(x, y, GetNodeIndexInternal(x, y));
}
}
public void Harvest(bool isMine, int[] proteins)
{
foreach (Entity entity in GetHarvestedEntities(isMine))
{
proteins[entity.Type - EntityType.A]++;
}
}
public List<Entity> GetHarvestedEntities(bool isMine)
{
string key = isMine ? "harvested_1" : "harvested_0";
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = new List<Entity>();
List<Entity> harvesters = GetHarvesterEntities(isMine);
HashSet<int> harvestedLocations = new HashSet<int>();
foreach (Entity harvester in harvesters)
{
if (GetEntityWithDirection(harvester.Location, harvester.OrganDirection, out Entity entity) && entity.IsOpenSpace() && harvestedLocations.Add(entity.Location.index))
{
entities.Add(entity);
}
}
_entityCache[key] = entities;
}
return entities;
}
public bool GetEntity(int entityIndex, out Entity entity)
{
entity = Entities[entityIndex];
return entity != null;
}
public bool GetEntity(Point2d location, out Entity entity)
{
return GetEntity(GetNodeIndex(location), out entity);
}
public List<Entity> GetHarvestableEntities()
{
string key = "harvestable";
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = GetEntitiesList().Where(e => e.IsOpenSpace()).ToList();
_entityCache[key] = entities;
}
return entities;
}
public bool GetEntityByLocation(Point2d location, out Entity entity)
{
return GetEntity(location, out entity);
}
public Entity GetEntityByLocation(Point2d location)
{
Entity entity = null;
GetEntity(location, out entity);
return entity;
}
public List<Entity> GetHarvesterEntities(bool isMine)
{
string key = isMine ? "harvest1" : "harvest0";
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = GetEntities(isMine).Where(e => e.Type == EntityType.HARVESTER).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetRootEntities(bool isMine)
{
string key = isMine ? "root1" : "root0";
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = GetEntities(isMine).Where(e => e.Type == EntityType.ROOT).OrderBy(e => e.OrganId).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetSporerEntities(int organRootId, bool isMine)
{
string key = (isMine ? "sporer1" : "sporer0") + organRootId.ToString();
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = GetEntitiesByRoot(organRootId, isMine).Where(e => e.Type == EntityType.SPORER).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetTentacleEntities(bool isMine)
{
string key = isMine ? "tentacles1" : "tentacles0";
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = GetTentacleEntities().Where(e => e.IsMine == isMine).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetTentacleEntities()
{
string key = "tentacles";
if (!_entityCache.TryGetValue(key, out List<Entity>? entities))
{
entities = GetEntitiesList().Where(e => e.Type == EntityType.TENTACLE).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetEntitiesList()
{
string key = "all";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = Entities.Where(e => e != null).ToList();
_entityCache[key] = entities;
}
return entities;
}
private Dictionary<string, List<Entity>> _entityCache = new Dictionary<string, List<Entity>>();
public List<Entity> GetEntities(bool isMine)
{
string key = isMine ? "e1" : "e0";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = GetEntitiesList().Where(e => e.IsMine.HasValue && e.IsMine == isMine).ToList();
_entityCache[key] = entities;
}
return entities;
}
public List<Entity> GetEntitiesByRoot(int organRootId, bool isMine)
{
string key = $"{organRootId}_{isMine}";
if (!_entityCache.TryGetValue(key, out List<Entity> entities))
{
entities = GetEntities(isMine).Where(e => e.OrganRootId == organRootId).ToList();
_entityCache[key] = entities;
}
return entities;
}
public Entity[] GetEntities()
{
return Entities;
}
private int _myEntityCount = -1;
public int GetMyEntityCount()
{
if (_myEntityCount < 0)
{
_myEntityCount = GetEntities(true).Count;
}
return _myEntityCount;
}
private int _oppEntityCount = -1;
public int GetOppEntityCount()
{
if (_oppEntityCount < 0)
{
_oppEntityCount = GetEntities(false).Count;
}
return _oppEntityCount;
}
public void SetEntities(IList<Entity> entities, bool isFirstTurn = false)
{
Array.Clear(Entities);
foreach (Entity entity in entities)
{
Entities[entity.Location.index] = entity;
if (entity.OrganId > 0 && GlobalOrganId <= entity.OrganId)
{
GlobalOrganId = entity.OrganId + 1;
}
}
UpdateBoard();
if (isFirstTurn)
{
CalculatePathsAndNeighbors();
}
}
public Board Clone()
{
return new Board(this);
}
public double? GetWinner()
{
return null;
}
public void Print()
{
for (int y = 0; y < Height; y++)
{
StringBuilder stringBuilder = new StringBuilder();
for (int x = 0; x < Width; x++)
{
if (!GetEntity(GetNodeIndex(x, y), out Entity entity))
{
stringBuilder.Append(' ');
}
else
{
stringBuilder.Append(GetCharacter(entity.Type, entity.IsMine));
}
}
Console.Error.WriteLine(stringBuilder.ToString());
}
}
public char GetCharacter(EntityType type, bool? isMine)
{
bool isMineInt = isMine.HasValue && isMine.Value;
switch (type)
{
case EntityType.WALL:
return 'X';
case EntityType.ROOT:
return isMineInt ? 'R' : 'r';
case EntityType.BASIC:
return isMineInt ? 'B' : 'b';
case EntityType.TENTACLE:
return isMineInt ? 'T' : 't';
case EntityType.HARVESTER:
return isMineInt ? 'H' : 'h';
case EntityType.SPORER:
return isMineInt ? 'S' : 's';
case EntityType.A:
return 'A';
case EntityType.B:
return 'B';
case EntityType.C:
return 'C';
case EntityType.D:
return 'D';
}
throw new ArgumentException($"Type: {type} not supported");
}
public void UpdateBoard()
{
_myEntityCount = -1;
_oppEntityCount = -1;
_moveActionCache = new Dictionary<string, List<MoveAction>>();
_entityCache = new Dictionary<string, List<Entity>>();
_locationCheckCache = new Dictionary<string, bool>();
}
public readonly struct LocationNeighbor
{
public readonly Point2d point;
public readonly OrganDirection direction;
public LocationNeighbor(int x, int y, int index, OrganDirection direction)
{
this.point = new Point2d(x, y, index);
this.direction = direction;
}
}
private Point2d[][][] _locationCache;
private int[][] _locationIndexCache = null;
private List<LocationNeighbor>[] _locationNeighbors = null;
public void InitializeBoard()
{
_intToStringCache = new string[Width * Height];
_locationIndexCache = new int[Width][];
for (int x = 0; x < Width; x++)
{
_locationIndexCache[x] = new int[Height];
for (int y = 0; y < Height; y++)
{
int index = GetNodeIndexInternal(x, y);
_locationIndexCache[x][y] = index;
_intToStringCache[index] = index.ToString();
}
}
_locationCache = new Point2d[Width + 2][][];
for (int x = 0; x < Width + 2; x++)
{
_locationCache[x] = new Point2d[Height + 2][];
for (int y = 0; y < Height + 2; y++)
{
_locationCache[x][y] = new Point2d[4];
for (int z = 0; z < 4; z++)
{
Point2d nextLocation = GetNextLocationInternl(x - 1, y - 1, PossibleDirections[z]);
if (nextLocation.x > -1 && nextLocation.y > -1 && nextLocation.x < Width && nextLocation.y < Height)
{
_locationCache[x][y][z] = nextLocation;
}
else
{
_locationCache[x][y][z] = null;
}
}
}
}
}
private void CalculatePathsAndNeighbors()
{
_isOpenSpaceInitial = new bool[Width * Height];
Array.Fill(_isOpenSpaceInitial, true);
_locationNeighbors = new List<LocationNeighbor>[Width * Height];
for (int x = 0; x < Width; x++)
{
for (int y = 0; y < Height; y++)
{
int index = GetNodeIndex(x, y);
Node node = new Node(index);
Graph.AddNode(node);
_locationNeighbors[index] = new List<LocationNeighbor>();
for (int z = 0; z < 4; z++)
{
Point2d location = GetNextLocation(new Point2d(x, y, GetNodeIndex(x, y)), PossibleDirections[z]);
if (ValidateLocation(location))
{
if (IsOpenSpace(location.index) || (GetEntity(location.index, out Entity entity) && entity.Type != EntityType.WALL))//The start of the map always includes 2 root entities, but we only want to handle walls
{
int nextIndex = GetNodeIndex(location);
node.AddLink(new Link(node, new Node(nextIndex), 1));
_locationNeighbors[index].Add(new LocationNeighbor(location.x, location.y, nextIndex, PossibleDirections[z]));
}
else _isOpenSpaceInitial[location.index] = false;
}
}
}
}
Graph.CalculateShortestPaths();
}
private int GetNodeIndexInternal(int x, int y)
{
return x * Height + y;
}
public List<LocationNeighbor> GetLocationNeighbors(int nodeIndex)
{
return _locationNeighbors[nodeIndex];
}
public List<LocationNeighbor> GetLocationNeighbors(Point2d location)
{
return _locationNeighbors[location.index];
}
public int GetNodeIndex(int x, int y)
{
return _locationIndexCache[x][y];
}
public int GetNodeIndex(Point2d location)
{
return location.index;
}
}
}
//*** SourceCombiner -> original file Entity.cs ***
namespace GameSolution.Entities
{
//WALL, ROOT, BASIC, TENTACLE, HARVESTER, SPORER, A, B, C, D
public enum EntityType
{
WALL = 0,
NONE,
ROOT,
BASIC,
TENTACLE,
HARVESTER,
SPORER,
A,
B,
C,
D,
}
public enum OrganDirection
{
North = 0,
South,
East,
West,
None
}
public class Entity
{
public bool? IsMine { get; }
public Point2d Location { get; }
public EntityType Type { get; }
public int OrganId { get; }
public OrganDirection OrganDirection { get; }
public int OrganParentId { get; }
public int OrganRootId { get; }
private bool _IsOpenSpace { get; set; }
public Entity(int x, int y, int index, string type, int owner, int organId, string organDir, int organParentId, int organRootId)
{
Location = new Point2d(x, y, index);
IsMine = owner == 1 ? true : owner == -1 ? (bool?)null : false;
Type = GetType(type);
OrganDirection = GetOrganDirection(organDir);
OrganId = organId;
OrganParentId = organParentId;
OrganRootId = organRootId;
_IsOpenSpace = IsOpenSpaceInternal();
}
public Entity(Point2d location, EntityType type, bool? isMine, int organId, int organParentId, int organRootId, OrganDirection organDirection)
{
Location = location;
IsMine = isMine;
Type = type;
OrganId = organId;
OrganParentId = organParentId;
OrganRootId = organRootId;
OrganDirection = organDirection;
_IsOpenSpace = IsOpenSpaceInternal();
}
public Entity(Entity entity)
{
this.IsMine = entity.IsMine;
this.Type = entity.Type;
this.OrganDirection = entity.OrganDirection;
this.Location = entity.Location.Clone();
this.OrganId = entity.OrganId;
this.OrganParentId = entity.OrganParentId;
this.OrganRootId = entity.OrganRootId;
_IsOpenSpace = entity._IsOpenSpace;
}
public OrganDirection GetOrganDirection(string organDir)
{
switch (organDir)
{
case "N":
return OrganDirection.North;
case "E":
return OrganDirection.East;
case "W":
return OrganDirection.West;
case "S":
return OrganDirection.South;
case "X":
return OrganDirection.None;
}
throw new ArgumentException($"Invalid direction: {organDir}", nameof(organDir));
}
public EntityType GetType(string type)
{
switch (type)
{
case "WALL":
return EntityType.WALL;
case "ROOT":
return EntityType.ROOT;
case "BASIC":
return EntityType.BASIC;
case "TENTACLE":
return EntityType.TENTACLE;
case "HARVESTER":
return EntityType.HARVESTER;
case "SPORER":
return EntityType.SPORER;
case "A":
return EntityType.A;
case "B":
return EntityType.B;
case "C":
return EntityType.C;
case "D":
return EntityType.D;
}
throw new ArgumentException($"Invalid type: {type}", nameof(type));
}
public bool IsOpenSpace()
{
return _IsOpenSpace;
}
private bool IsOpenSpaceInternal()
{
return Type == EntityType.A || Type == EntityType.B || Type == EntityType.C || Type == EntityType.D;
}
public Entity Clone()
{
return new Entity(this);
}
public bool Equals(Entity entity)
{
return entity.IsMine == IsMine && entity.OrganParentId == OrganParentId && entity.OrganRootId == OrganRootId && entity.Type == Type && entity.Location.Equals(Location) && entity.OrganId == OrganId && entity.OrganDirection == OrganDirection;
}
public override string ToString()
{
return "";
}
}
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
public enum MoveType
{
WAIT = 0,
GROW,
SPORE
};
public class MoveAction
{
public MoveType Type { get; set; }
public int OrganId { get; set; }
public Point2d Location { get; set; }
public EntityType EntityType { get; set; }
public int OrganRootId { get; set; }
public double Score { get; set; }
public OrganDirection OrganDirection { get; set; }
public MoveAction(MoveType moveType)
{
Type = moveType;
}
public static int[][] EntityCosts = new int[][]
{
  new int[]{0, 0, 0, 0 },
  new int[]{1, 1, 1, 1},
  new int[]{ 1, 0, 0, 0 },
  new int[]{0, 1, 1, 0},
  new int[]{0, 0, 1, 1 },
  new int[]{0, 1, 0, 1 }
};
public int[] GetCost()
{
return EntityCosts[EntityType - EntityType.NONE];
}
public static MoveAction CreateGrow(int organId, Point2d location, EntityType type, int organRootId, OrganDirection organDirection = OrganDirection.North)
{
MoveAction action = new MoveAction(MoveType.GROW);
action.OrganId = organId;
action.Location = location;
action.EntityType = type;
action.OrganRootId = organRootId;
action.OrganDirection = organDirection;
return action;
}
public static MoveAction CreateWait()
{
MoveAction action = new MoveAction(MoveType.WAIT);
action.EntityType = EntityType.NONE;
action.Score = -9999;
return action;
}
public static MoveAction CreateSpore(int sporeOrganId, Point2d location)
{
MoveAction action = new MoveAction(MoveType.SPORE);
action.OrganId = sporeOrganId;
action.Location = location;
action.EntityType = EntityType.ROOT;
return action;
}
public override string ToString()
{
MoveAction move = this;
switch (this.Type)
{
case MoveType.GROW:
return $"GROW {move.OrganId} {move.Location.x} {move.Location.y} {move.EntityType} {GetGrowDirection(move.OrganDirection)} {move.Score}";
case MoveType.SPORE:
return $"SPORE {move.OrganId} {move.Location.x} {move.Location.y} {move.Score}";
case MoveType.WAIT:
return $"WAIT {move.Score}";
}
return "";
}
public char GetGrowDirection(OrganDirection direction)
{
switch (direction)
{
case OrganDirection.North:
return 'N';
case OrganDirection.South:
return 'S';
case OrganDirection.West:
return 'W';
case OrganDirection.East:
return 'E';
}
throw new Exception("Invalid direction");
}
}
public class Move
{
public MoveAction[] Actions { get; set; }
public Move()
{
}
public Move(Move move)
{
Actions = move.Actions.Select(m => m).ToArray();
}
private int[] _costs = null;
public int[] GetCost()
{
if (_costs == null)
{
_costs = new int[] { 0, 0, 0, 0 };
foreach (MoveAction action in Actions)
{
int[] actionCost = action.GetCost();
for (int i = 0; i < 4; i++)
{
_costs[i] += actionCost[i];
}
}
}
return _costs;
}
public void SetActions(MoveAction[] actions)
{
Actions = actions;
}
public Move Clone()
{
return new Move(this);
}
public override bool Equals(object obj)
{
// Check if the object is the same reference or of the same type
if (ReferenceEquals(this, obj))
return true;
// Check if the object is of the same type
if (obj is Move otherMove)
{
// Ensure Actions are compared (null checks included)
if (this.Actions == null && otherMove.Actions == null)
return true;
if (this.Actions == null || otherMove.Actions == null)
return false;
// Compare Actions arrays element-by-element
if (this.Actions.Length != otherMove.Actions.Length)
return false;
for (int i = 0; i < this.Actions.Length; i++)
{
// Compare each MoveAction (assuming MoveAction also overrides Equals and GetHashCode)
if (!this.Actions[i].Equals(otherMove.Actions[i]))
return false;
}
return true;
}
return false;
}
// Override GetHashCode based on Actions
public override int GetHashCode()
{
// Use a base hash code for the class and incorporate each Action into the hash calculation
int hash = 17; // Arbitrary non-zero number
if (Actions != null)
{
foreach (MoveAction action in Actions)
{
hash = hash * 23 + (action?.GetHashCode() ?? 0); // Use 23 as another multiplier (common convention)
}
}
return hash;
}
public override string ToString()
{
StringBuilder moveStr = new StringBuilder();
foreach (MoveAction move in Actions)
{
string actionStr = move.ToString();
moveStr.Append(actionStr).Append(';');
}
return moveStr.ToString();
}
public void Print()
{
Console.Error.WriteLine(ToString());
}
public void Output()
{
foreach (MoveAction action in Actions)
{
Console.WriteLine(action.ToString());
}
}
}
}
//*** SourceCombiner -> original file Point2d.cs ***
namespace GameSolution.Entities
{
public class Point2d
{
public readonly int x, y, index; // Make fields readonly for better performance and clarity
// Constructor that initializes the point
public Point2d(int x, int y, int index)
{
this.x = x;
this.y = y;
this.index = index;
}
// Copy constructor (reuse the existing constructor to avoid redundancy)
public Point2d(Point2d point) : this(point.x, point.y, point.index) { }
// Clone method that uses the copy constructor
public Point2d Clone() => new Point2d(this);
// Override Equals method with a direct type check
public override bool Equals(object obj)
{
return obj is Point2d point && point.x == this.x && point.y == this.y;
}
// Override GetHashCode for better performance
public override int GetHashCode()
{
// Combine x and y in a more efficient way
unchecked // Disable overflow checking
{
return (x * 397) ^ y; // Simple prime multiplication for better hash distribution
}
}
}
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Game
{
public class GameHelper
{
GameState State { get; set; }
public GameHelper(GameState state)
{
State = state;
}
public Move GetMove()
{
Move move = new Move();
move.SetActions(new MoveAction[] { MoveAction.CreateWait() });
return move;
}
}
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Game
{
public class GameState : IGameState
{
public static int MaxTurns = 100;
public Board Board { get; private set; }
public int Turn { get; set; }
public int[] MyProtein { get; set; }
public int[] OppProtein { get; set; }
public Move? maxMove { get; set; }
public Move? minMove { get; set; }
public GameState()
{
Turn = 0;
maxMove = null;
minMove = null;
}
public GameState(GameState state)
{
Board = state.Board.Clone();
Turn = state.Turn;
MyProtein = state.MyProtein.ToArray();
OppProtein = state.OppProtein.ToArray();
maxMove = state.maxMove;
minMove = state.minMove;
_myMoves = state._myMoves?.ToList();
_oppMoves = state._oppMoves?.ToList();
}
public void SetNextTurn(Board board, int[] myProtein, int[] oppProtein)
{
Turn++;
this.Board = board;
MyProtein = myProtein;
OppProtein = oppProtein;
_myMoves = null;
_oppMoves = null;
UpdateGameState();
}
public void UpdateGameState()
{
Board.UpdateBoard();
}
public void ApplyMove(object move, bool isMax)
{
Move m = (Move)move;
if (isMax)
{
maxMove = m;
minMove = null;
}
else
{
if (maxMove == null)
throw new Exception("Expected max to play first.");
minMove = m;
}
if (maxMove != null && minMove != null)
{
ApplyMove(maxMove, MyProtein);
ApplyMove(minMove, OppProtein);
Board.ApplyMove(maxMove, minMove);
Board.Harvest(true, MyProtein);
Board.Harvest(false, OppProtein);
Board.Attack();
SetNextTurn(Board, MyProtein, OppProtein);
}
}
public void ApplyMove(Move move, int[] proteins)
{
foreach (MoveAction action in move.Actions)
{
if (action.Type == MoveType.GROW || action.Type == MoveType.SPORE)
{
ApplyCost(proteins, action.GetCost());
if (action.EntityType == EntityType.BASIC)
{
Entity entity = Board.GetEntityByLocation(action.Location);
if (entity != null)
{
proteins[entity.Type - EntityType.A] += 3;
}
}
}
}
}
public void ApplyCost(int[] proteins, int[] cost)
{
for (int i = 0; i < 4; i++)
{
proteins[i] -= cost[i];
if (proteins[i] < 0)
{
throw new Exception("Invalid move played; proteins can't be negative");
}
}
}
public IGameState Clone()
{
return new GameState(this);
}
public bool Equals(IGameState state)
{
GameState gameState = state as GameState;
if (this.Turn != gameState.Turn)
return false;
if ((maxMove == null && gameState.maxMove != null) || (maxMove != null && gameState.maxMove == null))
return false;
if ((minMove == null && gameState.minMove != null) || (minMove != null && gameState.minMove == null))
return false;
for (int i = 0; i < 4; i++)
{
if (this.MyProtein[i] != gameState.MyProtein[i])
return false;
if (this.OppProtein[i] != gameState.OppProtein[i])
return false;
}
if (!this.Board.Equals(gameState.Board))
return false;
return true;
}
public int GetGlobalOrganId()
{
return Board.GlobalOrganId;
}
public double Evaluate(bool isMax)
{
double value;
int myEntities = Board.GetMyEntityCount();
int oppEntities = Board.GetOppEntityCount();
int[] myHarvestProteins = Board.GetHarvestProteins(true);
double myHarvestProteinsSum = myHarvestProteins.Sum();
int[] oppHarvestProteins = Board.GetHarvestProteins(false);
double oppHarvestProteinsSum = oppHarvestProteins.Sum();
int myNumUniqueProteins = myHarvestProteins.Where(p => p > 1).Count();
int oppNumUniqueProteins = oppHarvestProteins.Where(p => p > 1).Count();
int myProteinBoost = myNumUniqueProteins * 5;
int oppProteinBoost = myNumUniqueProteins * 5;
double proteinValue = (myHarvestProteinsSum + myProteinBoost - oppProteinBoost - oppHarvestProteinsSum) / (myHarvestProteinsSum + oppHarvestProteinsSum + 1 + myProteinBoost + oppProteinBoost) * 0.2;
int myProtein = MyProtein.Sum();
int oppProtein = OppProtein.Sum();
value = (((double)myEntities - oppEntities) / (myEntities + oppEntities + 1) * 0.2) + (((double)myProtein - oppProtein) / (myProtein + oppProtein + 1) * 0.0001) + proteinValue;
if (value >= 1 || value <= -1)
Console.Error.WriteLine("Evaluation too high");
return value;
}
public object GetMove(bool isMax)
{
return isMax ? maxMove : minMove;
}
public int[] GetProteins(bool isMine)
{
return isMine ? MyProtein : OppProtein;
}
private List<Move> _myMoves;
private List<Move> _oppMoves;
private List<Move> GetMoves(bool isMax)
{
return isMax ? _myMoves : _oppMoves;
}
private void SetMoves(List<Move> moves, bool isMax)
{
if (isMax)
{
_myMoves = moves;
}
else
{
_oppMoves = moves;
}
}
public IList GetPossibleMoves(bool isMax)
{
if (Turn <= 100)
{
int[] proteins = GetProteins(isMax);
List<Move> moves = GetMoves(isMax);
if (moves == null)
{
Stopwatch watch = new Stopwatch();
watch.Start();
moves = Board.GetMoves(proteins, isMax);
SetMoves(moves, isMax);
watch.Stop();
if (watch.ElapsedMilliseconds > 20)
{
Console.Error.WriteLine($"Move generation: {watch.ElapsedMilliseconds}ms");
foreach (Move move in moves)
{
Console.Error.WriteLine($"{move}");
}
}
}
return moves;
}
else return new List<Move>();
}
public double? GetWinner()
{
int myEntitiesCount = Board.GetMyEntityCount();
int oppEntitiesCount = Board.GetOppEntityCount();
if (Turn < 100)
{
if (myEntitiesCount == 0)
return CheckGameEnd(myEntitiesCount, oppEntitiesCount);
else if (oppEntitiesCount == 0)
return CheckGameEnd(myEntitiesCount, oppEntitiesCount);
bool hasNoMyProteinsToBuild = MyProtein[0] == 0 && ((MyProtein[1] == 0 && MyProtein[2] == 0) || (MyProtein[1] == 0 && MyProtein[3] == 0) || (MyProtein[2] == 0 && MyProtein[3] == 0));
bool hasNoOppProteinsToBuild = OppProtein[0] == 0 && ((OppProtein[1] == 0 && OppProtein[2] == 0) || (OppProtein[1] == 0 && OppProtein[3] == 0) || (OppProtein[2] == 0 && OppProtein[3] == 0));
if (hasNoMyProteinsToBuild && myEntitiesCount < oppEntitiesCount)
return -1;
if (hasNoOppProteinsToBuild && oppEntitiesCount < myEntitiesCount)
return 1;
if (hasNoMyProteinsToBuild && hasNoOppProteinsToBuild)
return CheckGameEnd(myEntitiesCount, oppEntitiesCount);
double currentWinner = CheckGameEnd(myEntitiesCount, oppEntitiesCount);
bool hasOppMoves = HasMoves(GetPossibleMoves(false));
if (!hasOppMoves && currentWinner == 1)
return 1;
bool hasMyMoves = HasMoves(GetPossibleMoves(true));
if (!hasMyMoves && currentWinner == -1)
return -1;
}
if (Turn >= 100 || Board.IsFull())
{
return CheckGameEnd(myEntitiesCount, oppEntitiesCount);
}
return null;
}
private bool HasMoves(IList moves)
{
if (moves.Count == 1)
{
Move? theMove = moves[0] as Move;
bool isAllWait = true;
foreach (MoveAction action in theMove.Actions)
{
if (action.Type != MoveType.WAIT)
{
isAllWait = false;
break;
}
}
return !isAllWait;
}
return true;
}
private double CheckGameEnd(int myEntitiesCount, int oppEntitiesCount)
{
if (myEntitiesCount > oppEntitiesCount)
{
return 1;
}
else if (myEntitiesCount < oppEntitiesCount)
{
return -1;
}
else
{
int myProteinTotal = MyProtein.Sum();
int oppProteinTotal = OppProtein.Sum();
if (myProteinTotal > oppProteinTotal)
{
return 1;
}
else if (myProteinTotal < oppProteinTotal)
{
return -1;
}
else return 0;
}
}
public void Print()
{
Console.Error.WriteLine(Turn);
Console.Error.WriteLine(string.Join(',', MyProtein));
Console.Error.WriteLine(string.Join(',', OppProtein));
Board.Print();
}
}
}
