/*
 * File generated by SourceCombiner.exe using 2 source files.
 * Created On: 8/8/2021 1:23:26 PM
*/
using Algorithms.Graph;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 2 source files.
 * Created On: 8/8/2021 9:28:50 AM
*/
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        private Dictionary<int, List<Node>> Links { get; set; }
        private Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        private bool IsByDirectional;
        public GraphLinks(bool isByDirectional = true)
        {
            Links = new Dictionary<int, List<Node>>();
            IsByDirectional = isByDirectional;
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, double distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            AddLinkInternal(id1, id2, distance);
            if(IsByDirectional)
                AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            double currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        /// <summary>
        /// Retrieves the full path from start to end
        /// </summary>
        /// <param name="startId">the start id</param>
        /// <param name="endId">the end id</param>
        /// <returns>The full path</returns>
        public List<Node> GetShortestPathAll(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        //Adds links to the node links
        private void AddLinkInternal(int startNode, int endNode, double distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace Algorithms.Graph
{
    public class Node
    {
        public int Id { get; set; }
        public double Distance { get; set; }
        public bool IsExplored { get; set; }
        public Node(int id, double distance)
        {
            Id = id;
            Distance = distance;
        }
        /// <summary>
        /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
        /// </summary>
        /// <param name="currentDist">The current distance from the starting node</param>
        /// <returns>A clone of the node with the proper distance</returns>
        public Node CreateAtDistance(double currentDist)
        {
            return new Node(Id, currentDist + Distance);
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
    public enum ObjectType
    {
        Block = 0,
        Clone,
        Elevator,
        Exit,
        DecisionPoint
    }
    public class GameObject
    {
        public int Id;
        public int Floor;
        public int Location;
        public string Direction;
        public ObjectType Type;
        public GameObject(int id, int floor, int location, ObjectType type, string direction = "NONE")
        {
            Id = id;
            Floor = floor;
            Location = location;
            Direction = direction;
            Type = type;
        }
        public void Print()
        {
            Console.Error.WriteLine("Id: " + Id + " F: " + Floor + " L: " + Location + " T: " + Type.ToString());
        }
    }

    static void Main(string[] args)
    {
        Dictionary<int, GameObject> objects = new Dictionary<int, GameObject>();
        int objectId = 0;
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int nbFloors = int.Parse(inputs[0]); // number of floors
        int width = int.Parse(inputs[1]); // width of the area
        int nbRounds = int.Parse(inputs[2]); // maximum number of rounds
        int exitFloor = int.Parse(inputs[3]); // floor on which the exit is found
        int exitPos = int.Parse(inputs[4]); // position of the exit on its floor
        int nbTotalClones = int.Parse(inputs[5]); // number of generated clones
        int nbAdditionalElevators = int.Parse(inputs[6]); // ignore (always zero)
        int nbElevators = int.Parse(inputs[7]); // number of elevators
        Dictionary<int, List<int>> elevatorFloorToPosition = new Dictionary<int, List<int>>();
        for (int i = 0; i < nbElevators; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int elevatorFloor = int.Parse(inputs[0]); // floor on which this elevator is found
            int elevatorPos = int.Parse(inputs[1]); // position of the elevator on its floor
            AddElevator(elevatorFloorToPosition, elevatorFloor, elevatorPos);
        }
        objects[++objectId] = new GameObject(objectId, exitFloor, exitPos, ObjectType.Exit);
        int exitObjectId = objectId;

        for(int f = 0; f< nbFloors; i++)
        {
            for(int l = 0; l<width; j++)
            {

            }
        }

        foreach (GameObject obj in objects.Values.Where(go => go.Type == ObjectType.DecisionPoint))
        {
            if (objects.Values.Where(go => go.Type == ObjectType.Elevator && go.Floor == obj.Floor && go.Location == obj.Location).Any())
            {
                objects.Remove(obj.Id);
            }
        }
        // game loop
        while (true)
        {
            inputs = Console.ReadLine().Split(' ');
            int cloneFloor = int.Parse(inputs[0]); // floor of the leading clone
            int clonePos = int.Parse(inputs[1]); // position of the leading clone on its floor
            string direction = inputs[2]; // direction of the leading clone: LEFT or RIGHT
            GraphLinks links = new GraphLinks(false);
            if (cloneFloor != -1)
            {
                GameObject clone = new GameObject(++objectId, cloneFloor, clonePos, ObjectType.Clone, direction);
                AddLinks(links, objects, clone, direction, nbAdditionalElevators);
                links.CalculateShortestPathsFromStartNode(clone.Id, 9999999);
                int nextObjectId;
                try
                {
                    nextObjectId = links.GetShortestPath(clone.Id, exitObjectId);
                    GameObject nextObject = objects[nextObjectId];
                    if (nextObject.Location > clone.Location && direction == "LEFT")
                    {
                        Console.WriteLine("BLOCK");
                    }
                    else if (nextObject.Location < clone.Location && direction == "RIGHT")
                    {
                        Console.WriteLine("BLOCK");
                    }
                    else if (nextObject.Location == clone.Location && nextObject.Type == ObjectType.DecisionPoint)
                    {
                        Console.WriteLine("ELEVATOR");
                        nextObject.Type = ObjectType.Elevator;
                    }
                    else
                    {
                        Console.WriteLine("WAIT");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("WAIT");
                }
            }
            else
            {
                Console.WriteLine("WAIT");
            }
        }
    }
    public static void AddLinks(GraphLinks links, Dictionary<int, GameObject> objects, GameObject currentPoint, string direction, int buildableElevators)
    {
        currentPoint.Print();
        foreach (GameObject objOnSameFloor in objects.Values.Where(go => go.Floor == currentPoint.Floor))
        {
            int dist = Math.Abs(objOnSameFloor.Location - currentPoint.Location);
            if (objOnSameFloor.Location < currentPoint.Location && direction == "RIGHT")
            {
                dist += 3;
                direction = "LEFT";
            }
            else if (objOnSameFloor.Location > currentPoint.Location && direction == "LEFT")
            {
                dist += 3;
                direction = "RIGHT";
            }
            links.AddLink(currentPoint.Id, objOnSameFloor.Id, dist);
            GameObject theObj = objOnSameFloor;
            while (theObj.Type == ObjectType.Elevator)
            {
                GameObject nextFloor = objects.Values.Where(go => go.Floor == theObj.Floor + 1 && go.Location == theObj.Location).First();
                links.AddLink(theObj.Id, nextFloor.Id, 1);
                theObj = nextFloor;
            }
            if(theObj.Id != objOnSameFloor.Id)
            {
                AddLinks(links, objects, theObj, direction);
            }
            else//Wasn't an elevator, but it could be a decision point where an elevator is placed
            {
                if(objOnSameFloor.Type == ObjectType.DecisionPoint)
                {
                    GameObject nextFloor = objects.Values.Where(go => go.Floor == objOnSameFloor.Floor + 1 && go.Location == objOnSameFloor.Location).First();
                    links.AddLink(objOnSameFloor.Id, nextFloor.Id, 1);
                    AddLinks(links, objects, nextFloor, direction);
                }
            }
        }
    }
    public static void AddElevator(Dictionary<int, List<int>> elevatorFloorToPosition, int elevatorFloor, int elevatorPos)
    {
        if (elevatorFloorToPosition.ContainsKey(elevatorFloor))
        {
            elevatorFloorToPosition[elevatorFloor].Add(elevatorPos);
        }
        else
        {
            elevatorFloorToPosition[elevatorFloor] = new List<int>() { elevatorPos };
        }
    }
}
