/*
 * File generated by SourceCombiner.exe using 11 source files.
 * Created On: 4/29/2022 7:49:49 PM
*/
using Algorithms.GameComponent;
using Algorithms.Space;
using Algorithms.Trees;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file Player.cs ***
class Player
{
    static void Main(string[] args)
    {
        bool simulate = false;
        bool findStateDiscrepencies = false;
        GameState state = new GameState();
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int baseX = int.Parse(inputs[0]); // The corner of the map representing your base
        int baseY = int.Parse(inputs[1]);
        int heroesPerPlayer = int.Parse(Console.ReadLine()); // Always 3
        int enemyX = baseX == 0 ? 17630 : 0;
        int enemyY = baseY == 0 ? 9000 : 0;
        int turnCounter = 0;
        // game loop
        while (true)
        {
            turnCounter++;
            List<BoardPiece> pieces = new List<BoardPiece>();
            for (int i = 0; i < 2; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int health = int.Parse(inputs[0]); // Your base health
                int mana = int.Parse(inputs[1]); // Ignore in the first league; Spend ten mana to cast a spell
                Base b;
                if(i == 0)
                {
                    b = new Base(BoardPiece.MaxEntityId - 1, baseX, baseY, true, health, mana);
                }
                else
                {
                    b = new Base(BoardPiece.MaxEntityId - 2, enemyX, enemyY, false, health, mana);
                }
                pieces.Add(b);
            }
            int entityCount = int.Parse(Console.ReadLine()); // Amount of heros and monsters you can see
            for (int i = 0; i < entityCount; i++)
            {
                BoardPiece p = null;
                inputs = Console.ReadLine().Split(' ');
                int id = int.Parse(inputs[0]); // Unique identifier
                if (id >= BoardPiece.MaxEntityId - 2)
                    throw new Exception("id larger than expected");
                int type = int.Parse(inputs[1]); // 0=monster, 1=your hero, 2=opponent hero
                int x = int.Parse(inputs[2]); // Position of this entity
                int y = int.Parse(inputs[3]);
                int shieldLife = int.Parse(inputs[4]); // Ignore for this league; Count down until shield spell fades
                int isControlled = int.Parse(inputs[5]); // Ignore for this league; Equals 1 when this entity is under a control spell
                int health = int.Parse(inputs[6]); // Remaining health of this monster
                int vx = int.Parse(inputs[7]); // Trajectory of this monster
                int vy = int.Parse(inputs[8]);
                int nearBase = int.Parse(inputs[9]); // 0=monster with no target yet, 1=monster targeting a base
                int threatFor = int.Parse(inputs[10]); // Given this monster's trajectory, is it a threat to 1=your base, 2=your opponent's base, 0=neither
                switch (type)
                {
                    case 0:
                        bool? isThreatForMax = null;
                        if (threatFor == 1)
                            isThreatForMax = true;
                        else if (threatFor == 2)
                            isThreatForMax = false;
                        p = new Monster(id, x, y, null, health, shieldLife, isControlled == 1, vx, vy, nearBase == 1, isThreatForMax);
                        break;
                    case 1:
                        p = new Hero(id, x, y, true, shieldLife, isControlled == 1, vx, vy, DistanceHash.GetDistance(baseX, baseY, x, y) < 5000);
                        break;
                    case 2:
                        p = new Hero(id, x, y, false, shieldLife, isControlled == 1, vx, vy, DistanceHash.GetDistance(baseX, baseY, x, y) < 5000);
                        break;
                }
                if(p != null)
                    pieces.Add(p);
            }
            Stopwatch watch = new Stopwatch();
            watch.Start();
            GC.Collect();
            if (turnCounter != 1 && findStateDiscrepencies)
            {
                if(turnCounter - 1 != state.turn)
                    Console.Error.WriteLine($"current turn: {turnCounter}, f: {state.turn}");
                Console.Error.WriteLine($"Evaluating pieces for turn: {state.turn}");
                CheckPieces(pieces, state.board.boardPieces);
            }
            var board = new Board(pieces);
            state.SetNextTurn(board, false);
            int limit = turnCounter == 1 ? 995 : 45;
            Move move;
            if (simulate)
            {
                MonteCarloTreeSearch search = new MonteCarloTreeSearch(false);
                search.SetState(state, true, false);
                Console.Error.WriteLine("state ms: " + watch.ElapsedMilliseconds);
                move = (Move)search.GetNextMove(watch, limit, 6, 20);
                if (findStateDiscrepencies)
                {
                    state.enableLogging = true;
                    CheckPieces(pieces, state.board.boardPieces);
                    state.ApplyMove(move, true);
                    var minMove = new Move();
                    minMove.AddWaitMove(0);
                    minMove.AddWaitMove(1);
                    minMove.AddWaitMove(2);
                    state.ApplyMove(minMove, false);
                    state.turn--;
                    state.enableLogging = false;
                }
            }
            else
            {
                GameHelper game = new GameHelper(state);
                move = game.Defense();
            }
            watch.Stop();
            Console.Error.WriteLine("total ms: " + watch.ElapsedMilliseconds);
            Console.Write(move);
        }
    }
    public static void CheckPieces(IList<BoardPiece> pieces, IList<BoardPiece> pieces1)
    {
        foreach (var piece in pieces)
        {
            foreach (var p in pieces1)
            {
                if (piece.id == p.id)
                {
                    if (!piece.Equals(p))
                        Console.Error.WriteLine($"F: {piece} \nE: {p}");
                }
            }
        }
    }
}
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 18 source files.
 * Created On: 4/26/2022 2:08:42 PM
*/
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms.GameComponent
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        IList GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(object move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        object GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        double? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
        /// <summary>
        /// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
        /// </summary>
        /// <param name="isMax">true if it is max's turn else false</param>
        /// <returns>A number between [-1, 1]</returns>
        double Evaluate(bool isMax);
    }
}
namespace Algorithms.Space
{
    public class Circle2d : Point2d
    {
        public double radius { get; set; }
        public Circle2d(double x, double y, double radius) : base(x, y)
        {
            this.radius = radius;
        }
    }
}
//*** SourceCombiner -> original file Point2d.cs ***
public class Point2d
{
    public double x { get; private set; }
    public double y { get; private set; }
    public Point2d(double x, double y)
    {
        this.x = x;
        this.y = y;
    }
    public Point2d(Point2d point)
    {
        x = point.x;
        y = point.y;
    }
    public override string ToString()
    {
        return $"({x},{y})";
    }
    public bool Equals(Point2d point)
    {
        return point.x == this.x && point.y == this.y;
    }
    public Point2d GetTruncatedPoint()
    {
        return new Point2d(Math.Truncate(this.x), Math.Truncate(this.y));
    }
    public Point2d GetRoundedPoint()
    {
        return new Point2d(Math.Round(this.x), Math.Round(this.y));
    }
    public Point2d GetCeilingPoint()
    {
        return new Point2d(Math.Ceiling(x), Math.Ceiling(y));
    }
    public int GetTruncatedX()
    {
        return (int)x;
    }
    public int GetTruncatedY()
    {
        return (int)y;
    }
    public double GetAngle(Point2d point)
    {
        return Math.Atan2(point.y - y, point.x - x);
    }
    public double GetDistance(Point2d point)
    {
        return GetDistance(point.x, point.y, x, y);
    }
    public Point2d GetMidPoint(Point2d point)
    {
        return GetMidPoint(point.x, point.y, x, y);
    }
    public double LengthSquared()
    {
        return x * x + y * y;
    }
    public double Length()
    {
        return Math.Sqrt(LengthSquared());
    }
    public Point2d Normalize()
    {
        var length = Length();
        if (length == 0)
        {
            x = 0;
            y = 0;
        }
        else
        {
            x = x / length;
            y = y / length;
        }
        return this;
    }
    public Point2d Multiply(double scalar)
    {
        x = x * scalar;
        y = y * scalar;
        return this;
    }
    public Point2d Add(Point2d vector)
    {
        x = x + vector.x;
        y = y + vector.y;
        return this;
    }
    public Point2d Subtract(Point2d vector)
    {
        x = x - vector.x;
        y = y - vector.y;
        return this;
    }
    public Point2d Truncate()
    {
        x = GetTruncatedX();
        y = GetTruncatedY();
        return this;
    }
    public Point2d SymmetricTruncate(Point2d origin)
    {
        Subtract(origin).Truncate().Add(origin);
        return this;
    }
    public Point2d Clone()
    {
        return new Point2d(x, y);
    }
    public static double GetDistance(double x1, double y1, double x2, double y2)
    {
        return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));
    }
    public static Point2d GetMidPoint(double x1, double y1, double x2, double y2)
    {
        return new Point2d(Math.Abs(x1 - x2) / 2, Math.Abs(y1 - y2) / 2);
    }
}
//*** SourceCombiner -> original file Space2d.cs ***
namespace Algorithms.Space
{
    public class Space2d
    {
        /// <summary>
        /// Given a list of points and a circle radius, find the circle location that covers the maximum number of points
        /// </summary>
        /// <param name="points">The list of points to consider</param>
        /// <param name="radius">The radius of the circle</param>
        /// <returns>The number of points covered by the circle that is centered at the point.</returns>
        public static Tuple<int, Point2d> FindCircleWithMaximumPoints(Point2d[] points, double radius)
        {
            Tuple<int, Point2d> maxPoint = null;
            if (points == null)
                return null;
            if (radius <= 0)
                return null;
            var numberOfPoints = points.Count();
            double[,] distance = new double[numberOfPoints, numberOfPoints];
            for (int i = 0; i < numberOfPoints - 1; i++)
            {
                for (int j = i + 1; j < numberOfPoints; j++)
                {
                    distance[i, j] = distance[j, i] = points[i].GetDistance(points[j]);
                }
            }
            for (int i = 0; i < numberOfPoints; i++)
            {
                var currentAnswer = GetPointsInside(distance, points, i, radius, numberOfPoints);
                var nextPoint = new Tuple<int, Point2d>(currentAnswer.Item1, new Point2d(points[i].x + (radius * Math.Round(Math.Cos(currentAnswer.Item2), 15)), points[i].y + (radius * Math.Round(Math.Sin(currentAnswer.Item2), 15))));
                if (maxPoint == null || currentAnswer.Item1 > maxPoint.Item1 || (currentAnswer.Item1 == maxPoint.Item1 && IsInteger(nextPoint.Item2.x) && IsInteger(nextPoint.Item2.y)))
                {
                    maxPoint = nextPoint;
                }
            }
            return maxPoint;
        }
        /// <summary>
        /// Given a list of points and a circle radius, find the circle location that covers the maximum number of points, at point i.
        /// </summary>
        /// <param name="points">The list of points to consider</param>
        /// <param name="radius">The radius of the circle</param>
        /// <param name="i">The index of the point to use for the sweeping circle</param>
        /// <returns>The number of points covered by the circle that is centered at the point.</returns>
        public static Tuple<int, Point2d> FindCircleWithMaximumPoints(Point2d[] points, double radius, int i)
        {
            Tuple<int, Point2d> maxPoint = null;
            if (points == null)
                return null;
            if (radius <= 0)
                return null;
            var numberOfPoints = points.Count();
            double[,] distance = new double[numberOfPoints, numberOfPoints];
            for (int j = 0; j < numberOfPoints; j++)
            {
                distance[i, j] = distance[j, i] = points[i].GetDistance(points[j]);
            }
            var currentAnswer = GetPointsInside(distance, points, i, radius, numberOfPoints);
            maxPoint = new Tuple<int, Point2d>(currentAnswer.Item1, new Point2d(points[i].x + (radius * Math.Round(Math.Cos(currentAnswer.Item2), 15)), points[i].y + (radius * Math.Round(Math.Sin(currentAnswer.Item2), 15))));
            return maxPoint;
        }
        public static double CalculateAreaOfCircle(double radius)
        {
            return Math.PI * Math.Pow(radius, 2);
        }
        public static double CalculateOverlappingArea(Circle2d circle, Circle2d circle2)
        {
            var d = circle.GetDistance(circle2);
            if (d < circle.radius + circle2.radius)
            {
                var a = circle.radius * circle.radius;
                var b = circle2.radius * circle2.radius;
                var x = (a - b + d * d) / (2 * d);
                var z = x * x;
                var y = Math.Sqrt(a - z);
                if (d <= Math.Abs(circle2.radius - circle.radius))
                {
                    return Math.PI * Math.Min(a, b);
                }
                return a * Math.Asin(y / circle.radius) + b * Math.Asin(y / circle2.radius) - y * (x + Math.Sqrt(z + b - a));
            }
            return 0;
        }
        /// <summary>
        /// Moves the point towards the targetPoint with maximum distance
        /// </summary>
        /// <param name="startPoint">Start point</param>
        /// <param name="targetPoint">Target point</param>
        /// <param name="maximumDistance">Maximum distance to translate</param>
        /// <returns>The translated point in direction of target point with maximum distance</returns>
        public static Point2d TranslatePoint(Point2d startPoint, Point2d targetPoint, double maximumDistance)
        {
            var vector = CreateVector(startPoint, targetPoint);
            if (vector.LengthSquared() <= (maximumDistance * maximumDistance))
                return targetPoint;
            else
            {
                vector.Normalize();
                vector.Multiply(maximumDistance);
                return new Point2d(startPoint.x + vector.x, startPoint.y + vector.y);
            }
            /*
            if (point.GetDistance(targetPoint) <= maximumDistance)
                return targetPoint;
            else
            {
                var angle = point.GetAngle(targetPoint);
                var vx = Math.Cos(angle) * maximumDistance;
                var vy = Math.Sin(angle) * maximumDistance;
                return new Point2d(point.x + vx, point.y + vy);
            }
            */
        }
        public static Point2d CreateVector(Point2d startPoint, Point2d targetPoint)
        {
            var x = targetPoint.x - startPoint.x;
            var y = targetPoint.y - startPoint.y;
            return new Point2d(x, y);
        }
        private static bool IsInteger(double d)
        {
            return Math.Abs(d % 1) <= (Double.Epsilon * 100);
        }
        private static Tuple<int, double> GetPointsInside(double[,] distance, Point2d[] points, int i, double radius, int numberOfPoints)
        {
            List<Tuple<double, bool>> angles = new List<Tuple<double, bool>>();
            for (int j = 0; j < numberOfPoints; j++)
            {
                if (i != j && distance[i, j] <= 2 * radius)
                {
                    double B = Math.Acos(distance[i, j] / (2 * radius));
                    Complex c1 = new Complex(points[j].x - points[i].x, points[j].y - points[i].y);
                    double A = c1.Phase;
                    double alpha = A - B;
                    double beta = A + B;
                    angles.Add(new Tuple<double, bool>(alpha, true));
                    angles.Add(new Tuple<double, bool>(beta, false));
                }
            }
            angles = angles.OrderBy(angle => angle.Item1).ToList();
            int count = 1, res = 1;
            double maxAngle = 0;
            foreach (var angle in angles)
            {
                if (angle.Item2)
                    count++;
                else
                    count--;
                if (count > res)
                {
                    res = count;
                    maxAngle = angle.Item1;
                }
            }
            return new Tuple<int, double>(res, maxAngle);
        }
    }
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
    public class GameTreeNode
    {
        public IGameState state;
        public IList moves;
        public List<GameTreeNode> children;
        public double wins = 0;
        public double loses = 0;
        public int totalPlays = 0;
        public GameTreeNode parent;
        public bool isMax;
        public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
        {
            this.state = state;
            moves = new List<object>();
            foreach(object obj in state.GetPossibleMoves(isMax))
            {
                moves.Add(obj);
            }
            children = new List<GameTreeNode>();
            this.parent = parent;
            this.isMax = isMax;
        }
        public double GetScore(bool isMax)
        {
            double totalPlays = TotalPlays();
            if (totalPlays == 0)
                return 0;
            if (isMax)
            {
                return (wins - loses) / totalPlays;
            }
            else
            {
                return (loses - wins) / totalPlays;
            }
        }
        public int TotalPlays()
        {
            return totalPlays;
        }
        public double? GetWinner()
        {
            return state.GetWinner();
        }
        public void ApplyWinner(double? winner)
        {
            if (winner.HasValue)
            {
                if(winner > 0)
                {
                    wins += winner.Value;
                }
                else if(winner < 0)
                {
                    loses += Math.Abs(winner.Value);
                }
                totalPlays++;
            }
        }
        public double Evaluate()
        {
            return state.Evaluate(isMax);
        }
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms.Trees
{
    public class MonteCarloTreeSearch : TreeAlgorithm
    {
        private Random rand;
        private bool printErrors;
        private SearchStrategy strategy;
        public enum SearchStrategy
        {
            Random = 0,
            Sequential = 1
        }
        public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random) 
        {
            rand = new Random();
            printErrors = showErrors;
            strategy = searchStrategy;
        }
        /// <summary>
        /// Get the next move
        /// </summary>
        /// <param name="watch">timer</param>
        /// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
        /// <param name="numRollouts">The number of roll outs to play per expansion</param>
        /// <returns></returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
        {
            if(exploration == null)
            {
                exploration = Math.Sqrt(2);
            }
            int count = 0;
            do
            {
                GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
                if(selectedNode == null)
                {
                    if(printErrors)
                        Console.Error.WriteLine("Found no more moves!");
                    break;
                }
                object move = SelectMove(selectedNode);
                GameTreeNode childNode = Expand(selectedNode, move);
                double? winner = childNode.GetWinner();
                if (winner.HasValue)
                {
                    BackPropagate(childNode, winner);
                }
                else
                {
                    for (int i = 0; i<numRollouts; i++)
                    {
                        var clonedState = childNode.state.Clone();
                        winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
                        BackPropagate(childNode, winner);
                        count++;
                    }
                }
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            if(printErrors)
                Console.Error.WriteLine($"Played {count} games!");
            GameTreeNode bestChild = null;
            double bestScore = double.MinValue;
            foreach(GameTreeNode child in RootNode.children)
            {
                double score = child.GetScore(RootNode.isMax);
                if(bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                if(printErrors)
                    Console.Error.WriteLine($"w: {child.wins} l: {child.loses} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
            }
            if(printErrors)
                Console.Error.WriteLine($"Best: w: {bestChild.wins} l: {bestChild.loses} total: {bestChild.totalPlays} score: {bestScore} move: {bestChild.state.GetMove(RootNode.isMax)}");
            return bestChild.state.GetMove(RootNode.isMax);
        }
        private void BackPropagate(GameTreeNode selectedNode, double? winner)
        {
            selectedNode.ApplyWinner(winner);
            GameTreeNode tempNode = selectedNode.parent;
            while(tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
        {
            double? winner;
            do
            {
                object move = SelectMoveAtRandom(state, isMax);
                state.ApplyMove(move, isMax);
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    return null;
                }
                depth--;
                isMax = !isMax;
                winner = state.GetWinner();
            }
            while (!winner.HasValue && depth != 0);
            if (winner.HasValue)
            {
                return winner;
            }
            if (depth == 0)
            {
                double eval = state.Evaluate(isMax);
                if (eval > 1)
                {
                    return 1;
                }
                else if (eval < -1)
                    return -1;
                else return eval;
            }
            throw new InvalidOperationException("Could not find a winner for simulation!");
        }
        private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
        {
            Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
            queue.Enqueue(node);
            GameTreeNode tempNode;
            GameTreeNode bestNode = null;
            double maxValue = -1;
            while (queue.Count > 0)
            {
                tempNode = queue.Dequeue();
                if (tempNode.moves.Count == 0)
                {
                    foreach (GameTreeNode child in tempNode.children)
                    {
                        queue.Enqueue(child);
                    }
                }
                else if(tempNode.parent != null)
                {
                    double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
                    double nodeTotal = tempNode.TotalPlays();
                    double parentTotal = tempNode.parent.TotalPlays();
                    double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
                    if(value > maxValue)
                    {
                        maxValue = value;
                        bestNode = tempNode;
                    }
                }
                else return tempNode;
            }
            return bestNode;
        }
        private object SelectMoveAtRandom(IGameState state, bool isMax)
        {
            IList moves = state.GetPossibleMoves(isMax);
            if (moves.Count == 0)
            {
                throw new Exception("No moves available!");
            }
            int index = rand.Next(0, moves.Count);
            return moves[index];
        }
        private object SelectMove(GameTreeNode node)
        {
            switch (strategy)
            {
                case SearchStrategy.Random:
                    return SelectMoveAtRandom(node);
                case SearchStrategy.Sequential:
                    return SelectMoveSequentially(node);
            }
            throw new InvalidOperationException("strategy not supported");
        }
        private object SelectMoveSequentially(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                move = node.moves[0];
                node.moves.RemoveAt(0);
            }
            return move;
        }
        private object SelectMoveAtRandom(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
    }
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms.Trees
{
    public class TreeAlgorithm
    {
        protected GameTreeNode RootNode { get; private set; }
        public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
        {
            if (RootNode != null && findState)
            {
                //if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
                //find the child that matches the new node
                bool isFound = false;
                //Expand any moves left in the root node (if any)
                foreach (object move in RootNode.moves)
                {
                    Expand(RootNode, move);
                }
                //Begin scanning the children
                foreach (GameTreeNode child in RootNode.children)
                {
                    if (child.state.Equals(rootState))
                    {
                        RootNode = child;
                        isFound = true;
                        break;
                    }
                    foreach (object move in child.moves)
                    {
                        Expand(child, move);
                    }
                    foreach (GameTreeNode descendent in child.children)
                    {
                        if (descendent.state.Equals(rootState))
                        {
                            RootNode = descendent;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
                    RootNode = new GameTreeNode(rootState.Clone(), isMax);
                }
                else
                {
                    RootNode.parent = null;
                }
            }
            else
            {
                RootNode = new GameTreeNode(rootState.Clone(), isMax);
            }
        }
        /// <summary>
        /// Expands the given node by create a clone, applying the move and then adding it to the list of children.
        /// </summary>
        /// <param name="node">The node to expand</param>
        /// <param name="move">The move to play on the expanded node</param>
        /// <returns></returns>
        protected GameTreeNode Expand(GameTreeNode node, object move)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, node.isMax);
            GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
    }
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
    public static class BitFunctions
    {
        public static bool IsBitSet(long value, int location)
        {
            long mask = GetBitMask(location);
            return (value & mask) == mask;
        }
        public static long SetBit(long value, int location)
        {
            return value | (GetBitMask(location));
        }
        public static long ClearBit(long value, int location)
        {
            return value & (~(GetBitMask(location)));
        }
        public static long SetOrClearBit(long value, int location, bool isSet)
        {
            if (isSet)
                return SetBit(value, location);
            return ClearBit(value, location);
        }
        public static int NumberOfSetBits(long i)
        {
            i = i - ((i >> 1) & 0x5555555555555555);
            i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
            return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
        }
        public static long GetBitMask(int index)
        {
            return (long)1 << index;
        }
    }
}
//*** SourceCombiner -> original file Base.cs ***
namespace GameSolution.Entities
{
    public class Base : BoardPiece
    {
        public static int SightRange = 6000;
        public int health
        {
            get
            {
                return (int)((bitboard & healthMask) >> 46);
            }
            set
            {
                bitboard &= ~healthMask;
                bitboard += (long)value << 46;
            }
        }
        public int mana
        {
            get
            {
                return (int)((bitboard & manaMask) >> 48);
            }
            set
            {
                bitboard &= ~manaMask;
                bitboard += (long)value << 48;
            }
        }
        /*
         * health   2 ^ 2
         * mana     2 ^ 12
         * **/
        protected static long healthMask = (long)Math.Pow(2, 48) - 1 - vyMask - vxMask - isControlledMask - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        protected static long manaMask = (long)Math.Pow(2, 60) - 1 - healthMask - vyMask - vxMask - isControlledMask - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        public Base(int id, int x, int y, bool isMax, int health, int mana) : base(id, x, y, isMax, 0, false, 0, 0, false)
        {
            bitboard += (((long)health) << 46) + (((long)mana) << 48);
        }
        public Base(Base piece) : base(piece)
        {
            //handled by base
        }
        public override BoardPiece Clone()
        {
            return new Base(this);
        }
        public override string ToString()
        {
            return base.ToString() + $", {health}, {mana}";
        }
    }
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
    public class Board
    {
        public static int MaxX = 17630;
        public static int MaxY = 9000;
        public static int MinX = 0;
        public static int MinY = 0;
        public static int NearBaseDistance = 5000;
        public static int WindCastDistance = 1280;
        public static int WindPushDistance = 2200;
        public static int ControlCastDistance = 2200;
        public static int ShieldCastDistance = 2200;
        public static Point2d Origin = new Point2d(MaxX / 2, MaxY / 2);
        public IList<BoardPiece> boardPieces { get; set; }
        public Base myBase { get; set; }
        public Base opponentBase { get; set; }
        public IList<Monster> monsters { get; set; }
        public IList<Hero> myHeroes { get; set; }
        public IList<Hero> opponentHeroes { get; set; }
        public Dictionary<int, long> spellsInEffect { get; set; }
        public Board(IList<BoardPiece> boardPieces )
        {
            this.boardPieces = boardPieces;
            spellsInEffect = new Dictionary<int, long>();
            SetupBoard();
        }
        public Board(Board board)
        {
            boardPieces = board.boardPieces.Select(bp => bp.Clone()).ToList();
            spellsInEffect = board.spellsInEffect;
            SetupBoard();
        }
        public void ResetSpells()
        {
            spellsInEffect = new Dictionary<int, long>();
        }
        public void SetupBoard()
        {
            monsters = new List<Monster>();
            myHeroes = new List<Hero>();
            opponentHeroes = new List<Hero>();
            foreach(BoardPiece piece in boardPieces)
            {
                if(piece is Base)
                {
                    Base b = piece as Base;
                    if (b.isMax.Value)
                    {
                        myBase = b;
                    }
                    else
                    {
                        opponentBase = b;
                    }
                }
                if(piece is Monster)
                {
                    monsters.Add(piece as Monster);
                }
                if(piece is Hero)
                {
                    Hero h = piece as Hero;
                    if (h.isMax.Value)
                    {
                        myHeroes.Add(h);
                    }
                    else
                    {
                        opponentHeroes.Add(h);
                    }
                }
            }
        }
        public void ApplyMove(Move move, bool isMax)
        {
            var heroes = isMax ? myHeroes : opponentHeroes;
            var b = isMax ? myBase : opponentBase;
            foreach(Hero hero in heroes)
            {
                long heroMove = move.GetMove(hero.id);
                switch (HeroMove.GetMoveType(heroMove))
                {
                    case MoveType.MOVE:
                        var point = new Point2d(HeroMove.GetX(heroMove), HeroMove.GetY(heroMove));
                        var newPoint = Space2d.TranslatePoint(hero.point, point, Hero.Speed);
                        newPoint.SymmetricTruncate(Origin);
                        hero.point = new Point2d((int)newPoint.x, (int)newPoint.y);
                        if (hero.GetDistance(myBase) <= NearBaseDistance || hero.GetDistance(opponentBase) <= NearBaseDistance)
                            hero.isNearBase = true;
                        else hero.isNearBase = false;
                        break;
                    case MoveType.SPELL:
                        BoardPiece piece;
                        if(b.mana >= 10)
                        {
                            switch (HeroMove.GetSpellType(heroMove))
                            {
                                case SpellType.SHIELD:
                                    piece = boardPieces.First(p => p.id == HeroMove.GetTargetId(heroMove));
                                    if (hero.GetDistance(piece) <= ShieldCastDistance)
                                    {
                                        if (piece.shieldLife == 0)
                                            spellsInEffect[hero.id] = heroMove;
                                        b.mana -= 10;
                                    }
                                    break;
                                case SpellType.CONTROL:
                                    piece = boardPieces.First(p => p.id == HeroMove.GetTargetId(heroMove));
                                    if (hero.GetDistance(piece) <= ControlCastDistance)
                                    {
                                        if(piece.shieldLife == 0)
                                            spellsInEffect[hero.id] = heroMove;
                                        b.mana -= 10;
                                    }
                                    break;
                                case SpellType.WIND:
                                    spellsInEffect[hero.id] = heroMove;
                                    b.mana -= 10;
                                    break;
                            }
                        }
                        break;
                }
            }
        }
        public void ApplyControlAndShieldSpells()
        {
        }
        public void ApplyWindSpells()
        {
            Dictionary<int, Point2d> windApplied = new Dictionary<int, Point2d>();
            foreach(var item in spellsInEffect)
            {
                var spellType = HeroMove.GetSpellType(item.Value);
                var spellPoint = new Point2d(HeroMove.GetX(item.Value), HeroMove.GetY(item.Value));
                if (spellType == SpellType.WIND)
                {
                    ApplyWindSpell(myHeroes, opponentHeroes, item.Key, spellPoint, windApplied);
                    ApplyWindSpell(opponentHeroes, myHeroes, item.Key, spellPoint, windApplied);
                }
            }
            if(windApplied.Count > 0)
            {
                foreach(var piece in boardPieces)
                {
                    Point2d vector;
                    if(windApplied.TryGetValue(piece.id, out vector))
                    {
                        vector.Multiply(WindPushDistance);
                        vector.SymmetricTruncate(Origin);
                        piece.point.Add(vector);
                        piece.isWinded = true;
                    }
                }
            }
        }
        private void ApplyWindSpell(IList<Hero> castingHeroes, IList<Hero> targetedHeroes, int spellCastBy, Point2d spellPoint, Dictionary<int, Point2d> windApplied)
        {
            foreach (Hero hero in castingHeroes)
            {
                if (hero.id == spellCastBy)
                {
                    Point2d directionVector = Space2d.CreateVector(hero.point, spellPoint).Normalize();
                    foreach (Monster monster in monsters)
                    {
                        SetWindCastVector(hero, monster, windApplied, directionVector);
                    }
                    foreach (Hero targetHero in targetedHeroes)
                    {
                        SetWindCastVector(hero, targetHero, windApplied, directionVector);
                    }
                }
            }
        }
        private void SetWindCastVector(Hero hero, BoardPiece targetPiece, Dictionary<int, Point2d> windApplied, Point2d directionVector)
        {
            if (hero.GetDistance(targetPiece) <= WindCastDistance && targetPiece.shieldLife == 0)
            {
                var targetId = targetPiece.id;
                Point2d vector;
                if (windApplied.TryGetValue(targetId, out vector))
                {
                    vector.Add(directionVector);
                }
                else
                {
                    vector = directionVector.Clone();
                }
                windApplied[targetId] = vector;
            }
        }
        public Board Clone()
        {
            return new Board(this);
        }
        public double? GetWinner()
        {
            if(myBase.health == 0)
            {
                return -1;
            }
            else if (opponentBase.health == 0)
            {
                return 1;
            }
            return null;
        }
    }
}
//*** SourceCombiner -> original file BoardPiece.cs ***
namespace GameSolution.Entities
{
    public enum BoardPieceType
    {
        Base = 0,
        Monster = 1,
        Hero = 2
    }
    public class BoardPiece
    {
        public Point2d point { get; set; }
        public bool isWinded { get; set; } = false;
        public int x
        {
            get
            {
                return (int)point.x;
            }
        }
        public int y
        {
            get
            {
                return (int)point.y;
            }
        }
        public int id
        {
            get
            {
                return (int)(bitboard & idMask);
            }
        }
        public bool? isMax
        {
            get
            {
                var val = (bitboard & isMaxMask) >> 10;
                return val == 1 ? true : val == 0 ? false : (bool?)null;
            }
        }
        public int shieldLife
        {
            get
            {
                return (int)((bitboard & shieldLifeMask) >> 12);
            }
            set
            {
                bitboard &= ~shieldLifeMask;
                bitboard += (value << 12);
            }
        }
        public bool isControlled
        {
            get
            {
                return ((bitboard & isControlledMask) >> 17) == 1 ? true : false;
            }
            set
            {
                bitboard &= ~isControlledMask;
                bitboard += ((value ? 1 : 0) << 17);
            }
        }
        public int vx
        {
            get
            {
                int val = (int)((bitboard & vxMask) >> 18);
                var isNegative = val % 2 == 1 ? true : false;
                val = val >> 1;
                return isNegative ? val * -1 : val;
            }
            set
            {
                var isNegative = value < 0;
                bitboard &= ~vxMask;
                bitboard += ((isNegative ? (long)1 : 0) << 18) + (((long)Math.Abs(value)) << 19);
            }
        }
        public int vy
        {
            get
            {
                int val = (int)((bitboard & vyMask) >> 32);
                var isNegative = val % 2 == 1 ? true : false;
                val = val >> 1;
                return isNegative ? val * -1 : val;
            }
            set
            {
                var isNegative = value < 0;
                bitboard &= ~vyMask;
                bitboard += ((isNegative ? (long)1 : 0) << 32) + (((long)Math.Abs(value)) << 33);
            }
        }
        public bool isNearBase
        {
            get
            {
                return ((bitboard & isNearBaseMask) >> 16) == 1 ? true : false;
            }
            set
            {
                bitboard &= ~isNearBaseMask;
                bitboard += (value ? 1 : 0) << 16;
            }
        }
        public static int MaxEntityId = 1000;
        /*
         * id           2^10
         * isMax        2^2
         * shieldLife   2^4
         * isControlled 2^1
         * isNearBase   2^1
         * vx           2^1 + 2^13 = 2^14
         * vy           2^1 + 2^13 = 2^14
         * 
         * x            2^15 -> needed as point
         * y            2^15 -> needed as point
         * */
        protected long bitboard = 0;
        protected static long idMask = (long)Math.Pow(2, 10) - 1;
        protected static long isMaxMask = (long)Math.Pow(2, 12) - 1 - idMask;
        protected static long shieldLifeMask = (long)Math.Pow(2, 16) - 1 - isMaxMask - idMask;
        protected static long isNearBaseMask = (long)Math.Pow(2, 17) - 1 - shieldLifeMask - isMaxMask - idMask;
        protected static long isControlledMask = (long)Math.Pow(2, 18) - 1 - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        protected static long vxMask = (long)Math.Pow(2, 32) - 1 - isControlledMask - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        protected static long vyMask = (long)Math.Pow(2, 46) - 1 - vxMask - isControlledMask - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        public BoardPiece(int id, int x, int y, bool? isMax, int shieldLife, bool isControlled, int vx, int vy, bool isNearBase)
        {
            point = new Point2d(x, y);
            bitboard = id + ((isMax.HasValue ? isMax.Value ? (long)1 : 0 : 2) << 10) + ((long)shieldLife << 12) + ((isNearBase ? 1 : 0) << 16) + ((isControlled ? 1 : 0) << 17) + ((vx < 0 ? (long)1 : 0) << 18) + (((long)Math.Abs(vx)) << 19) + ((vy < 0 ? (long)1 : 0) << 32) + (((long)Math.Abs(vy)) << 33);
        }
        public BoardPiece(BoardPiece piece)
        {
            point = new Point2d(piece.x, piece.y);
            bitboard = piece.bitboard;
        }
        public virtual BoardPiece Clone()
        {
            return new BoardPiece(this);
        }
        public bool Equals(BoardPiece piece)
        {
            return bitboard == piece.bitboard && x == piece.x && y == piece.y;
        }
        public double GetDistance(BoardPiece piece)
        {
            return DistanceHash.GetDistance(x, y, piece.x, piece.y);
        }
        public override string ToString()
        {
            return $"{id}, {x}, {y}, m? {isMax}, s: {shieldLife}, b? {isNearBase}, {vx}, {vy}, c? {isControlled}, bb: {bitboard}";
        }
    }
}
//*** SourceCombiner -> original file DistanceHash.cs ***
namespace GameSolution.Entities
{
    public static class DistanceHash
    {
        private static Dictionary<long, double> Hash { get; set; } = new Dictionary<long, double>(); 
        private static long ConvertToLong(int x, int y, int x1, int y1)
        {
            return x + (y << 16) + (x1 << 32) + (y1 << 48);
        }
        public static double GetDistance(int x, int y, int x1, int y1)
        {
            if(x > x1 || (x == x1 && y > y1))
            {
                var swap = x;
                x = x1;
                x1 = swap;
                swap = y;
                y = y1;
                y1 = swap;
            }
            var key = ConvertToLong(x, y, x1, y1);
            if (x == x1 && y == y1)
                return 0;
            double value;
            if(!Hash.TryGetValue(key, out value))
            {
                var distance = Point2d.GetDistance(x, y, x1, y1);
                Hash[key] = distance;
                value = distance;
            }
            return value;
        }
    }
}
//*** SourceCombiner -> original file Hero.cs ***
namespace GameSolution.Entities
{
    public class Hero : BoardPiece
    {
        public static int Speed = 800;
        public static int Range = 800;
        public static int SightRange = 2200;
        public Hero(int id, int x, int y, bool? isMax, int shieldLife, bool isControlled, int vx, int vy, bool isNearBase) : base(id, x, y, isMax, shieldLife, isControlled, vx, vy, isNearBase)
        {
        }
        public Hero(Hero piece) : base(piece)
        {
        }
        public override BoardPiece Clone()
        {
            return new Hero(this);
        }
    }
}
//*** SourceCombiner -> original file Monster.cs ***
namespace GameSolution.Entities
{
    public class Monster : BoardPiece
    {
        public static int Speed = 400;
        public static int Range = 300;
        public static int TargetingRange = 5000;
        public int health
        {
            get
            {
                return (int)((bitboard & healthMask) >> 46);
            }
            set
            {
                bitboard &= ~healthMask;
                bitboard += (long)value << 46;
            }
        }
        public bool? threatForMax
        {
            get
            {
                var val = (bitboard & threatForMaxMask) >> 52;
                return val == 1 ? true : val == 0 ? false : (bool?)null;
            }
            set
            {
                bitboard &= ~threatForMaxMask;
                bitboard += (value.HasValue ? value.Value ? 1 : 0 : 2) << 52;
            }
        }
        /*
         * health       2 ^ 6
         * threatForMax 2 ^ 2
         * */
        protected static long healthMask = (long)Math.Pow(2, 52) - 1 - vyMask - vxMask - isControlledMask - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        protected static long threatForMaxMask = (long)Math.Pow(2, 56) - 1 - healthMask - vyMask - vxMask - isControlledMask - isNearBaseMask - shieldLifeMask - isMaxMask - idMask;
        public Monster(int id, int x, int y, bool? isMax, int health, int shieldLife, bool isControlled, int vx, int vy, bool isNearBase, bool? threatForMax) : base(id, x, y, isMax, shieldLife, isControlled, vx, vy, isNearBase)
        {
            bitboard += (((long)health) << 46) + ((threatForMax.HasValue ? threatForMax.Value ? (long)1 : 0 : 2) << 52);
        }
        public Monster(Monster piece) : base(piece)
        {
            //Values copied as part of base
        }
        public override BoardPiece Clone()
        {
            return new Monster(this);
        }
        public void Move()
        {
            point = new Point2d(x + vx, y + vy);
        }
        public override string ToString()
        {
            return base.ToString() + $", h: {health}, t? {threatForMax}";
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
    public enum MoveType
    {
        WAIT = 0,
        MOVE = 1,
        SPELL = 2
    };
    public enum SpellType
    {
        NONE = 0,
        WIND = 1,
        SHIELD = 2,
        CONTROL = 3
    };
    public static class HeroMove
    {
        //x => 2^16
        //y => 2^16
        //moveType => 2^2
        //SpellType => 2^2
        //targetId => 2^16
        public static long xMask = (long)Math.Pow(2, 16) - 1;
        public static long yMask = (long)Math.Pow(2, 32) - 1 - xMask;
        public static long moveTypeMask = (long)Math.Pow(2, 34) - 1 - yMask - xMask;
        public static long spellTypeMask = (long)Math.Pow(2, 36) - 1 - moveTypeMask - yMask - xMask;
        public static long targetIdMask = (long)Math.Pow(2, 52) - 1 - spellTypeMask - moveTypeMask - yMask - xMask;
        public static MoveType GetMoveType(long move)
        {
            return (MoveType)((move & moveTypeMask) >> 32);
        }
        public static int GetX(long move)
        {
            return (int)(move & xMask);
        }
        public static int GetY(long move)
        {
            return (int)((move & yMask) >> 16);
        }
        public static SpellType GetSpellType(long move)
        {
            return (SpellType)((move & spellTypeMask) >> 34);
        }
        public static int GetTargetId(long move)
        {
            return (int)((move & targetIdMask) >> 36);
        }
        public static long CreateHeroMove(int x, int y, MoveType moveType, SpellType spellType, int entityId)
        {
            long move = x + ((long)y << 16) + ((long)moveType << 32) + ((long)spellType << 34) + ((long)entityId << 36);
            return move;
        }
        public static long CreateWaitMove()
        {
            return CreateHeroMove(0, 0, MoveType.WAIT, SpellType.NONE, 0);
        }
        public static long CreateHeroMove(int x, int y)
        {
            return CreateHeroMove(x, y, MoveType.MOVE, SpellType.NONE, 0);
        }
        public static long CreateWindSpellMove(int x, int y)
        {
            return CreateSpellMove(x, y, SpellType.WIND, 0);
        }
        public static long CreateControlSpellMove(int x, int y, int targetId)
        {
            return CreateSpellMove(x, y, SpellType.CONTROL, targetId);
        }
        public static long CreateShieldSpellMove(int targetId)
        {
            return CreateSpellMove(0, 0, SpellType.SHIELD, targetId);
        }
        public static long CreateSpellMove(int x, int y, SpellType spell, int targetId)
        {
            return CreateHeroMove(x, y, MoveType.SPELL, spell, targetId);
        }
    }
    public class Move
    {
        public long[] heroMoves { get; set; }
        public Move()
        {
            heroMoves = new long[3];
        }
        public Move(Move move)
        {
            heroMoves = move.heroMoves.Select(m => m).ToArray();
        }
        public int ConvertHeroIdToIndex(int heroId)
        {
            if (heroId < 3)
                return heroId;
            else return heroId - 3;
        }
        public long GetMove(int heroId)
        {
            return heroMoves[ConvertHeroIdToIndex(heroId)];
        }
        public void AddMove(long heroMove, int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = heroMove;
        }
        public void AddHeroMove(double x, double y, int heroId)
        {
            AddHeroMove((int)x, (int)y, heroId);
        }
        public void AddHeroMove(int x, int y, int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = HeroMove.CreateHeroMove(x, y);
        }
        public void AddWaitMove(int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = HeroMove.CreateWaitMove();
        }
        public void AddSpellMove(int x, int y, SpellType spell, int targetId, int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = HeroMove.CreateSpellMove(x, y, spell, targetId);
        }
        public void AddWindSpellMove(int x, int y, int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = HeroMove.CreateWindSpellMove(x, y);
        }
        public void AddControlSpellMove(int x, int y, int targetId, int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = HeroMove.CreateControlSpellMove(x, y, targetId);
        }
        public void AddShieldSpellMove(int targetId, int heroId)
        {
            heroMoves[ConvertHeroIdToIndex(heroId)] = HeroMove.CreateShieldSpellMove(targetId);
        }
        public bool Equals(Move move)
        {
            for(int i = 0; i < heroMoves.Length; i++)
            {
                if (!heroMoves.Equals(move))
                {
                    return false;
                }
            }
            return true;
        }
        public Move Clone()
        {
            return new Move(this);
        }
        public override string ToString()
        {
            StringBuilder moveStr = new StringBuilder();
            foreach(long move in heroMoves)
            {
                switch (HeroMove.GetMoveType(move))
                {
                    case MoveType.MOVE:
                        moveStr.Append("MOVE " + HeroMove.GetX(move) + " " + HeroMove.GetY(move) + Environment.NewLine);
                        break;
                    case MoveType.WAIT:
                        moveStr.Append("WAIT" + Environment.NewLine);
                        break;
                    case MoveType.SPELL:
                        var spellType = HeroMove.GetSpellType(move);
                        switch (spellType)
                        {
                            case SpellType.WIND:
                                moveStr.Append("SPELL " + spellType.ToString() + " " + HeroMove.GetX(move) + " " + HeroMove.GetY(move) + Environment.NewLine);
                                break;
                            case SpellType.SHIELD:
                                moveStr.Append("SPELL " + spellType.ToString() + " " + HeroMove.GetTargetId(move) + Environment.NewLine);
                                break;
                            case SpellType.CONTROL:
                                moveStr.Append("SPELL " + spellType.ToString() + " " + HeroMove.GetTargetId(move) + " " + HeroMove.GetX(move) + " " + HeroMove.GetY(move) + Environment.NewLine);
                                break;
                        }
                        break;
                }
            }
            return moveStr.ToString();
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Game
{
    public class GameHelper
    {
        public enum Strategy
        {
            Defense = 0,
            Guard = 1,
            Scout = 2,
            Farm = 3,
            Attack = 4
        }
        public Board board { get; set; }
        public List<Tuple<double, Monster>> distToAllMonsters { get; set; }
        public List<Tuple<double, Hero>> distToOpponentHeroes { get; set; }
        public List<Tuple<double, Hero>> distToMyHeroes { get; set; }
        public int turn;
        public GameHelper(GameState state)
        {
            board = state.board.Clone();
            turn = state.turn;
            CalculateHelper();
        }
        public Move Defense()
        {
            var move = new Move();
            var myHeroes = board.myHeroes;
            var hero1 = myHeroes[0];
            var hero2 = myHeroes[1];
            var hero3 = myHeroes[2];
            var myBase = board.myBase;
            if(distToAllMonsters.Count == 0)
            {
                var target = GetOutterMidPointOfBase(myBase);
                move.AddHeroMove(target.Item1, target.Item2, hero1.id);
                var vector = new Point2d(3, 1).Normalize().Multiply(GetBaseDirectionality(myBase)).Multiply(Base.SightRange).Add(myBase.point);
                move.AddHeroMove(vector.GetTruncatedX(), vector.GetTruncatedY(), hero2.id);
                vector = new Point2d(1, 3).Normalize().Multiply(GetBaseDirectionality(myBase)).Multiply(Base.SightRange).Add(myBase.point);
                move.AddHeroMove(vector.GetTruncatedX(), vector.GetTruncatedY(), hero3.id);
            }
            else if(distToAllMonsters.Count == 1)
            {
                var monster = distToAllMonsters[0].Item2;
                var vector = Space2d.CreateVector(monster.point, myBase.point).Normalize().Multiply(Hero.Range - Monster.Speed).Add(monster.point);
                move.AddHeroMove(vector.x, vector.y, hero1.id);
                move.AddHeroMove(vector.x, vector.y, hero2.id);
                move.AddHeroMove(vector.x, vector.y, hero3.id);
            }
            else
            {
                var monster = distToAllMonsters[1].Item2;
                var closestHero = GetClosestHero(myHeroes, monster);
                var vector = Space2d.CreateVector(monster.point, myBase.point).Normalize().Multiply(Hero.Range - Monster.Speed).Add(monster.point);
                move.AddHeroMove(vector.x, vector.y, closestHero.id);
                monster = distToAllMonsters[0].Item2;
                vector = Space2d.CreateVector(monster.point, myBase.point).Normalize().Multiply(Hero.Range - Monster.Speed).Add(monster.point);
                foreach(Hero hero in myHeroes)
                {
                    if (hero.id == closestHero.id)
                        continue;
                    move.AddHeroMove(vector.x, vector.y, hero.id);
                    move.AddHeroMove(vector.x, vector.y, hero.id);
                }
            }
            return move;
        }
        public Hero GetClosestHero(IList<Hero> heroes, BoardPiece piece)
        {
            double minDist = 999999;
            Hero minHero = null;
            foreach (Hero hero in heroes)
            {
                var distance = hero.GetDistance(piece);
                if(distance < minDist)
                {
                    minHero = hero;
                    minDist = distance;
                }
            }
            return minHero;
        }
        public Move GetBestMove()
        {
            return AllInOneStrategy();
        }
        public void CalculateHelper()
        {
            distToAllMonsters = new List<Tuple<double, Monster>>();
            foreach (Monster m in board.monsters)
            {
                if (turn < 80)
                {
                    if (m.threatForMax.HasValue && !m.threatForMax.Value)
                        continue;
                }
                double dist = board.myBase.GetDistance(m);
                foreach(Hero hero in board.opponentHeroes)
                {
                    if(CanCastWind(m, hero))
                    {
                        dist -= 2200;
                    }
                }
                distToAllMonsters.Add(new Tuple<double, Monster>(dist, m));
            }
            distToAllMonsters = distToAllMonsters.OrderBy(t => t.Item1).ToList();
            /*
            foreach (var distToMonster in distToAllMonsters)
            {
                Console.Error.WriteLine("Found monster at distance: " + distToMonster.Item1);
            }
            */
            distToOpponentHeroes = new List<Tuple<double, Hero>>();
            foreach (Hero h in board.opponentHeroes)
            {
                double dist = board.myBase.GetDistance(h);
                distToOpponentHeroes.Add(new Tuple<double, Hero>(dist, h));
            }
            distToOpponentHeroes = distToOpponentHeroes.OrderBy(t => t.Item1).ToList();
            distToMyHeroes = new List<Tuple<double, Hero>>();
            foreach (Hero h in board.myHeroes)
            {
                double dist = board.myBase.GetDistance(h);
                distToMyHeroes.Add(new Tuple<double, Hero>(dist, h));
            }
            distToMyHeroes = distToMyHeroes.OrderBy(t => t.Item1).ToList();
        }
        public Strategy DetermineStrategy()
        {
            return Strategy.Defense;
        }
        public static bool bottomLeftScanner = false;
        static bool attackMode = false;
        public Move AllInOneStrategy()
        {
            Move move = new Move();
            var myHeroes = board.myHeroes;
            var opponentHeroes = board.opponentHeroes;
            var goalie = board.myHeroes[0];
            var topRight = board.myHeroes[1];
            var bottomLeft = board.myHeroes[2];
            var myBase = board.myBase;
            var opponentBase = board.opponentBase;
            var myBaseDirection = GetBaseDirectionality(myBase);
            var opponentBaseDirection = GetBaseDirectionality(opponentBase);
            var topRightPoint = new Point2d(myBase.x + (myBaseDirection) * (Hero.SightRange + Base.SightRange), myBase.y + (myBaseDirection) * Hero.SightRange);
            var bottomLeftPoint = new Point2d(myBase.x + (myBaseDirection) * Hero.SightRange, opponentBase.y + (opponentBaseDirection) * Hero.SightRange);
            var topRightCorner = new Point2d(Board.MaxX - 500, 0);
            var bottomLeftCorner = new Point2d(0, Board.MaxY - 500);
            var windCorner = topRightCorner;
            if(myBaseDirection < 0)
            {
                var swap = bottomLeftPoint;
                bottomLeftPoint = topRightPoint;
                topRightPoint = swap;
                swap = bottomLeftCorner;
                bottomLeftCorner = topRightCorner;
                topRightCorner = swap;
                windCorner = bottomLeftCorner;
            }
            /*
            var heroes = myHeroes.Select(h => h).ToList();
            goalie = GetHeroClosestToPoint(heroes, myBase.point);
            heroes.Remove(goalie);
            topRight = GetHeroClosestToPoint(heroes, topRightPoint);
            heroes.Remove(topRight);
            bottomLeft = heroes[0];
            */
            if (bottomLeftPoint.Equals(bottomLeft.point))
                bottomLeftScanner = true;
            //Console.Error.WriteLine($"goalie: {goalie.id}, topRight: {topRight.id}, bottomLeft: {bottomLeft.id}");
            //When no monsters; spread out to the corners of the map; with one player as "goalie"
            if (distToAllMonsters.Count == 0)
            {
                var target = GetOutterMidPointOfBase(board.myBase);
                move.AddHeroMove(target.Item1, target.Item2, goalie.id);
                move.AddHeroMove(topRightPoint.GetTruncatedX(), topRightPoint.GetTruncatedY(), topRight.id);
                move.AddHeroMove(bottomLeftPoint.GetTruncatedX(), bottomLeftPoint.GetTruncatedY() , bottomLeft.id);
            }
            else
            {
                if (distToAllMonsters.Count == 1)
                {
                    bool hero1CastWind = false;
                    var m = distToAllMonsters[0].Item2;
                    if (CanCastWindOnNearBaseMonster(distToAllMonsters[0].Item2, goalie, 2))
                    {
                        hero1CastWind = true;
                        var windTarget = FindWindTarget(goalie, windCorner, new Point2d(opponentBase.x, opponentBase.y));
                        move.AddWindSpellMove((int)windTarget.x, (int)windTarget.y, goalie.id);
                    }
                    else
                    {
                        if (m.GetDistance(myBase) < 7000)
                        {
                            move.AddHeroMove(m.x, m.y, goalie.id);
                        }
                        else
                        {
                            var target = GetOutterMidPointOfBase(myBase);
                            move.AddHeroMove(target.Item1, target.Item2, goalie.id);
                        }
                    }
                    if (!hero1CastWind && CanCastWindOnNearBaseMonster(m, topRight))
                    {
                        move.AddWindSpellMove(opponentBase.x, opponentBase.y, topRight.id);
                    }
                    else move.AddHeroMove(m.x, m.y, topRight.id);
                    if (!bottomLeftScanner)
                        move.AddHeroMove(bottomLeftPoint.GetTruncatedX(), bottomLeftPoint.GetTruncatedY(), bottomLeft.id);
                    else move.AddHeroMove(opponentBase.x, opponentBase.y, bottomLeft.id);
                }
                else
                {
                    bottomLeftScanner = false;
                    var monstersInBase = distToAllMonsters.Sum(m => m.Item1 < 3000 && m.Item2.health > 4 ? 1 : 0);
                    var monstersHeroCanWind = distToAllMonsters.Sum(m => m.Item1 < 3000 && CanCastWind(m.Item2, goalie) ? 1 : 0 );
                    var m = distToAllMonsters[0].Item2;
                    bool goalieCastWind = false;
                    if(monstersInBase > monstersHeroCanWind && goalie.GetDistance(myBase) > distToAllMonsters[0].Item1 && distToAllMonsters[0].Item1 > 400)
                    {
                        move.AddHeroMove(myBase.x, myBase.y, goalie.id);
                    }
                    else if (CanCastWindOnNearBaseMonster(m, goalie, 2))
                    {
                        goalieCastWind = true;
                        var windTarget = FindWindTarget(goalie, windCorner, new Point2d(opponentBase.x, opponentBase.y));
                        move.AddWindSpellMove((int)windTarget.x, (int)windTarget.y, goalie.id);
                    }
                    else if (CanCastControlOnNearBaseMonster(m, goalie))
                    {
                        var target = GetControlTargetingPointForMonster(m);
                        move.AddControlSpellMove(target.GetTruncatedX(), target.GetTruncatedY(), m.id, goalie.id);
                    } 
                    else
                    {
                        if (distToOpponentHeroes.Count > 0 && distToOpponentHeroes[0].Item1 < 6500 && distToOpponentHeroes[0].Item2.GetDistance(goalie) > Hero.Speed && m.GetDistance(myBase) > 5000)
                        {
                            var h = distToOpponentHeroes[0].Item2;
                            move.AddHeroMove(h.x, h.y, goalie.id);
                        }
                        else if (m.GetDistance(myBase) < 7600)
                        {
                            move.AddHeroMove(m.x, m.y, goalie.id);
                        }
                        else
                        {
                            var target = GetOutterMidPointOfBase(myBase);
                            move.AddHeroMove(target.Item1, target.Item2, goalie.id);
                        }
                    }
                    var closestMonster = distToAllMonsters[0].Item2;
                    var secondClosestMonster = distToAllMonsters[1].Item2;
                    if (distToAllMonsters.Count >= 3)
                    {
                        closestMonster = secondClosestMonster;
                        secondClosestMonster = distToAllMonsters[2].Item2;
                    }
                    var targetForTopRight = closestMonster;
                    var targetForBottomLeft = secondClosestMonster;
                    if(topRight.GetDistance(closestMonster) > bottomLeft.GetDistance(closestMonster))
                    {
                        targetForTopRight = secondClosestMonster;
                        targetForBottomLeft = closestMonster;
                    }
                    if ((!goalieCastWind || myBase.mana >= 20) && CanCastWindOnNearBaseMonster(m, topRight))
                    {
                        move.AddWindSpellMove(opponentBase.x, board.opponentBase.y, topRight.id);
                    }
                    else if (distToOpponentHeroes.Count > 0 && CanCastControlOnNearBaseHero(distToOpponentHeroes[0].Item2, topRight))
                    {
                        move.AddControlSpellMove(opponentBase.x, board.opponentBase.y, distToOpponentHeroes[0].Item2.id, topRight.id);
                    }
                    else
                    {
                        var maximumTarget2 = MaximizeTargetsOnAllMonstersInRange(topRight);
                        if (maximumTarget2 != null && distToAllMonsters.Count < 3)
                        {
                            move.AddHeroMove(maximumTarget2.GetTruncatedX(), maximumTarget2.GetTruncatedY(), topRight.id);
                        }
                        else
                            move.AddHeroMove(targetForTopRight.x, targetForTopRight.y, topRight.id);
                    }
                    if (myBase.mana < 30)
                        attackMode = false;
                    if(attackMode)
                    {
                        var farthestMonster = distToAllMonsters[distToAllMonsters.Count - 1].Item2;
                        var windableMonsters = GetWindableMonstersInRange(bottomLeft);
                        if (bottomLeft.GetDistance(opponentBase) > 5000 && windableMonsters.Count == 0)
                        {
                            var controllableMonsters = GetControllableMonstersInRange(bottomLeft);
                            if (controllableMonsters.Count > 0)
                            {
                                var monster = controllableMonsters[0];
                                var target = GetControlTargetingPointForMonster(monster);
                                move.AddControlSpellMove(target.GetTruncatedX(), target.GetTruncatedY(), monster.id, bottomLeft.id);
                            }
                            else
                            {
                                var vector = Space2d.CreateVector(farthestMonster.point, myBase.point);
                                vector.Normalize().Multiply(Hero.Range + 100).Add(farthestMonster.point);
                                move.AddHeroMove(vector.GetTruncatedX(), vector.GetTruncatedY(), bottomLeft.id);
                            }
                        }
                        else
                        {
                            var monsterVector = Space2d.CreateVector(farthestMonster.point, opponentBase.point);
                            monsterVector.Normalize().Multiply(Board.WindPushDistance).Add(bottomLeft.point);
                            move.AddWindSpellMove(monsterVector.GetTruncatedX(), monsterVector.GetTruncatedY(), bottomLeft.id);
                        }
                    }
                    else
                    {
                        var windableMonsters = GetWindableMonstersInRange(bottomLeft);
                        var controllableMonsters = GetControllableMonstersInRange(bottomLeft);
                        for (int i = 0; i < controllableMonsters.Count; i++)
                        {
                            if (controllableMonsters[i].GetDistance(myBase) < 5000)
                            {
                                controllableMonsters.RemoveAt(i);
                            }
                        }
                        if (windableMonsters.Count > 3 && myBase.mana > 60)
                        {
                            move.AddWindSpellMove(opponentBase.x, opponentBase.y, bottomLeft.id);
                        }
                        else if (myBase.mana > 60 && controllableMonsters.Count > 0)
                        {
                            //attackMode = true;
                            var monster = controllableMonsters[0];
                            var target = GetControlTargetingPointForMonster(monster);
                            move.AddControlSpellMove(target.GetTruncatedX(), target.GetTruncatedY(), monster.id, bottomLeft.id);
                        }
                        else
                        {
                            var maximumTarget3 = MaximizeTargetsOnAllMonstersInRange(bottomLeft);
                            if (maximumTarget3 != null)
                            {
                                move.AddHeroMove(maximumTarget3.GetTruncatedX(), maximumTarget3.GetTruncatedY(), bottomLeft.id);
                            }
                            else
                            {
                                move.AddHeroMove(targetForBottomLeft.x, targetForBottomLeft.y, bottomLeft.id);
                            }
                        }
                    }
                }
            }
            return move;
        }
        public Point2d FindWindTarget(Hero hero, Point2d farthestSideCorner, Point2d opponentBase)
        {
            List<Monster> monstersInRange = board.monsters.Where(m => CanCastWind(m, hero)).ToList();
            if(monstersInRange.Count == 1)
            {
                var m = monstersInRange[0];
                var vector = Space2d.CreateVector(m.point, board.myBase.point);
                vector.Normalize().Multiply(-1 * Board.WindPushDistance);
                return vector.Add(hero.point);
            }
            else
            {
                foreach(Monster monster in monstersInRange)
                {
                    foreach(Hero opponent in board.opponentHeroes)
                    {
                        if(CanCastWind(monster, opponent))
                        {
                            return opponentBase;
                        }
                    }
                }
            }
            return farthestSideCorner;
        }
        public Hero GetHeroClosestToPoint(IList<Hero> heroes, Point2d point)
        {
            double minDist = 99999;
            Hero closeHero = heroes[0];
            foreach(Hero hero in heroes)
            {
                double dist = hero.point.GetDistance(point);
                if(dist < minDist)
                {
                    minDist = dist;
                    closeHero = hero;
                }
            }
            return closeHero;
        }
        public bool CanCastControlOnNearBaseMonster(Monster monster, Hero hero)
        {
            return CanCastControlOrShield(monster, hero) && board.myBase.mana >= 30 && board.myBase.GetDistance(monster) > 6000 && monster.health > 15 && (!monster.threatForMax.HasValue || monster.threatForMax.Value);
        }
        public bool CanCastControlOnNearBaseHero(BoardPiece piece, Hero hero)
        {
            var countCloseMonsters = 0;
            foreach(var distToMonster in distToAllMonsters)
            {
                if(distToMonster.Item1 < 5000)
                {
                    countCloseMonsters++;
                }
            }
            return hero.isNearBase && board.myBase.mana >= 20 && countCloseMonsters > 1 && CanCastControlOrShield(piece, hero);
        }
        public bool CanCastWindOnNearBaseMonster(Monster monster, Hero hero, int maxHealth = 4)
        {
            var distance = 3000;
            foreach(var opponentHero in board.opponentHeroes)
            {
                if (opponentHero.GetDistance(monster) <= Board.WindCastDistance)
                {
                    distance = 6500;
                    break;
                }
            }
            return monster.GetDistance(board.myBase) < distance && CanCastWind(monster, hero) && monster.health > maxHealth;
        }
        public Point2d? MaximizeTargetsOnAllMonstersInRange(Hero hero)
        {
            var monstersInRange = GetMonstersInRange(hero);
            if (!monstersInRange.Any())
                return null;
            if(monstersInRange.Count == 1)
            {
                return null;
            }
            List<Point2d> points = new List<Point2d>();
            foreach (var monster in monstersInRange)
            {
                points.Add(hero.point);
                points.Add(monster.point);
                //Console.Error.WriteLine("Found point: (" + monster.point.x + ", " + monster.point.y + ")");
            }
            points.Add(hero.point);
            //Console.Error.WriteLine("Hero point: " + hero.point);
            var result = Space2d.FindCircleWithMaximumPoints(points.ToArray(), Hero.Speed-1);
            var roundedResult = result.Item2.GetRoundedPoint();
            if(hero.point.GetDistance(roundedResult) > Hero.Speed)
            {
                Console.Error.WriteLine($"Circle too far! hero: {hero.point} point: {result}");
                Console.Error.WriteLine(string.Join(',', points));
            }
            //Console.Error.WriteLine("Max circle: " + result.Item1 + result.Item2.GetRoundedPoint());
            return roundedResult;
        }
        public List<Monster> GetMonstersInRange(Hero hero)
        {
            List<Monster> monsters = new List<Monster>();
            foreach(var monster in board.monsters)
            {
                if(IsMonsterInRangeOfHero(monster, hero))
                {
                    monsters.Add(monster);
                }
            }
            return monsters;
        }
        public bool IsMonsterInRangeOfHero(Monster monster, Hero hero)
        {
            var dist = hero.GetDistance(monster);
            if (dist < Hero.Speed + Hero.Range)
                return true;
            return false;
        }
        public Tuple<int, int> GetOutterMidPointOfBase(Base b)
        {
            int direction = GetBaseDirectionality(b);
            int distance = 3535;
            int x = b.x + direction * distance;
            int y = b.y + direction * distance;
            return new Tuple<int, int>(x, y);
        }
        public int GetBaseDirectionality(Base b)
        {
            int direction = 1;
            if (b.x != 0)
            {
                direction = -1;
            }
            return direction;
        }
        static bool alternate = true;
        public Point2d GetControlTargetingPointForMonster(Monster monster)
        {
            Console.Error.WriteLine(alternate);
            int x, x1, x2;
            int y, y1, y2;
            Base b = board.opponentBase;
            int targetingDifference = 4700;
            int direction = GetBaseDirectionality(b);
            x1 = b.x + direction * targetingDifference;
            y1 = b.y;
            x2 = b.x;
            y2 = b.y + direction * targetingDifference;
            /*
            double dist1, dist2;
            dist1 = DistanceHash.GetDistance(x1, y1, monster.x, monster.y);
            dist2 = DistanceHash.GetDistance(x2, y2, monster.x, monster.y);
            */
            //Console.Error.WriteLine($"Targeting distances dist1, dist2: {dist1}, {dist2}");
            if (alternate) 
            {
                alternate = false;
                x = x1;
                y = y1;
            }
            else
            {
                alternate = true;
                x = x2;
                y = y2;
            }
            Console.Error.WriteLine(alternate);
            return new Point2d(x, y);
        }
        public List<Monster> GetWindableMonstersInRange(Hero hero)
        {
            List<Monster> monsters = new List<Monster>();
            foreach (var monster in board.monsters)
            {
                if (monster.health > 5 && CanCastWind(monster, hero) && hero.GetDistance(board.opponentBase) < 7000)
                {
                    monsters.Add(monster);
                }
            }
            return monsters;
        }
        public List<Monster> GetControllableMonstersInRange(Hero hero)
        {
            List<Monster> monsters = new List<Monster>();
            foreach (var monster in board.monsters)
            {
                if (monster.threatForMax.HasValue && !monster.threatForMax.Value)
                    continue;
                if (monster.health > 15 && CanCastControlOrShield(monster, hero))
                {
                    monsters.Add(monster);
                }
            }
            return monsters;
        }
        public bool CanCastControlOrShield(BoardPiece piece, Hero hero)
        {
            return hero.GetDistance(piece) <= 2200 && piece.shieldLife == 0 && board.myBase.mana >= 10;
        }
        public bool CanCastWind(BoardPiece piece, Hero hero)
        {
            return hero.GetDistance(piece) <= 1280 && piece.shieldLife == 0 && board.myBase.mana >= 10;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Game
{
    public class GameState : IGameState
    {
        public bool enableLogging = false;
        public Board board { get; set; }
        public int turn { get; set; }
        public int myManaGained = 0;
        public int opponentManaGained = 0;
        public Move? maxMove { get; set; }
        public Move? minMove { get; set; }
        public IList<Move> possibleMaxMoves { get; set; }
        public IList<Move> possibleMinMoves { get; set; }
        public GameState()
        {
            turn = 0;
            maxMove = null;
            minMove = null;
        }
        public GameState(GameState state)
        {
            board = state.board.Clone();
            turn = state.turn;
            maxMove = state.maxMove;
            minMove = state.minMove;
            myManaGained = state.myManaGained;
            opponentManaGained = state.opponentManaGained;
            possibleMaxMoves = state.possibleMaxMoves;
            possibleMinMoves = state.possibleMinMoves;
        }
        public void SetNextTurn(Board board, bool simulate = false)
        {
            turn++;
            this.board = board;
            if (simulate)
            {
                bool boardPiecesChanged = false;
                boardPiecesChanged |= DamageMonsters();
                ApplyWindSpells();
                boardPiecesChanged |= MoveMonsters();
                ApplyControlAndShieldSpells();
                if (boardPiecesChanged)
                {
                    board.SetupBoard();
                }
                board.ResetSpells();
            }
            //possibleMaxMoves = CalculateMoves(true);
            //possibleMinMoves = CalculateMoves(false);
        }
        public void ApplyWindSpells()
        {
            board.ApplyWindSpells();
        }
        public void ApplyControlAndShieldSpells()
        {
            board.ApplyControlAndShieldSpells();
        }
        public bool DamageMonsters()
        {
            bool boardPiecesChanged = false;
            foreach(Hero hero in board.myHeroes)
            {
                foreach(Monster monster in board.monsters)
                {
                    if(hero.GetDistance(monster) <= Hero.Range)
                    {
                        if(enableLogging)
                            Console.Error.WriteLine($"Hit: {monster.id}");
                        monster.health -= 2;
                        board.myBase.mana+=2;
                        myManaGained+=2;
                    }
                }
            }
            foreach(Hero hero in board.opponentHeroes)
            {
                foreach (Monster monster in board.monsters)
                {
                    if (hero.GetDistance(monster) <= Hero.Range)
                    {
                        monster.health -= 2;
                        board.opponentBase.mana++;
                        opponentManaGained++;
                    }
                }
            }
            for(int i = 0; i<board.monsters.Count; i++)
            {
                var monster = board.monsters[i];
                if(monster.health <= 0)
                {
                    board.boardPieces.Remove(monster);
                    boardPiecesChanged = true;
                }
            }
            return boardPiecesChanged;
        }
        public bool MoveMonsters()
        {
            bool boardPiecesChanged = false;
            foreach (Monster monster in board.monsters)
            {
                if(!monster.isWinded)
                    monster.Move();
                if (!monster.isNearBase)
                {
                    if (monster.x > Board.MaxX || monster.x < Board.MinX || monster.y > Board.MaxY || monster.y < Board.MinY)
                    {
                        board.boardPieces.Remove(monster);
                    }
                }
                boardPiecesChanged = CheckBaseDistance(board.myBase, monster);
                boardPiecesChanged = CheckBaseDistance(board.opponentBase, monster);
            }
            return boardPiecesChanged;
        }
        public bool CheckBaseDistance(Base b, Monster monster)
        {
            bool boardPiecesChanged = false;
            var distance = b.GetDistance(monster);
            if (distance <= Monster.Range)
            {
                b.health--;
                board.boardPieces.Remove(monster);
                boardPiecesChanged = true;
                if (enableLogging)
                {
                    Console.Error.WriteLine($"Monster ran into base: {b.id}, {monster}");
                }
            }
            if (distance <= Monster.TargetingRange)
            {
                /*
                if (enableLogging)
                {
                    Console.Error.WriteLine($"Monster targeting base was moving: {monster}");
                }
                */
                monster.isNearBase = true;
                Point2d vector = Space2d.CreateVector(monster.point, b.point);
                vector.Normalize().Multiply(Monster.Speed).SymmetricTruncate(Board.Origin);
                monster.vx = (int)vector.x;
                monster.vy = (int)vector.y;
                /*
                if (enableLogging)
                {
                    Console.Error.WriteLine($"Monster targeting base: {b.id}, {monster}");
                }
                */
            }            
            return boardPiecesChanged;
        }
        public void ApplyMove(object move, bool isMax)
        {
            Move m = (Move)move;
            if (isMax)
            {
                maxMove = m;
                minMove = null;
            }
            else
            {
                if (maxMove == null)
                    throw new Exception("Expected max to play first.");
                minMove = m;
            }
            if(maxMove != null && minMove != null)
            {
                board.ApplyMove(maxMove, true);
                board.ApplyMove(minMove, false);
                SetNextTurn(board, true);
            }
        }
        public IGameState Clone()
        {
            return new GameState(this);
        }
        public bool Equals(IGameState state)
        {
            throw new NotImplementedException();
        }
        public static double totalSightArea = 3 * Math.PI* Hero.SightRange * Hero.SightRange;
        public double Evaluate(bool isMax)
        {
            double value = 0;
            var myBase = board.myBase;
            var opponentBase = board.opponentBase;
            var myHeroes = board.myHeroes;
            var healthBonus = ((myBase.health - opponentBase.health) / 3) * 0.9;
            var sightBonus = (CalculateSightArea() / totalSightArea) *  0.02 ;
            var manaGainBonus = ((myManaGained - opponentManaGained) / 200) * 0.08;
            value += healthBonus + sightBonus + manaGainBonus;
            if(value < 0 || value > 1)
            {
                Console.Error.WriteLine($"health: {healthBonus}, sight: {sightBonus}, mana gain: {manaGainBonus}");
            }
            return value;
        }
        public double CalculateSightArea()
        {
            var sightArea = totalSightArea;
            foreach(Hero hero in board.myHeroes)
            {
                foreach(Hero hero1 in board.myHeroes)
                {
                    if(hero.id == hero1.id)
                        continue;
                    sightArea -= Space2d.CalculateOverlappingArea(new Circle2d(hero.x, hero.y, Hero.SightRange), new Circle2d(hero1.x, hero1.y, Hero.SightRange));
                }
                sightArea -= Space2d.CalculateOverlappingArea(new Circle2d(hero.x, hero.y, Hero.SightRange), new Circle2d(board.myBase.x, board.myBase.y, Base.SightRange));
            }
            return sightArea < 0 ? 0 : sightArea;
        }
        public object GetMove(bool isMax)
        {
            return isMax ? maxMove : minMove;
        }
        private IList<Move> CalculateMoves(bool isMax)
        {
            IList<Move> finalPossibleMoves = new List<Move>();
            GameHelper gameHelper = new GameHelper(this);
            var myHeroes = isMax ? board.myHeroes : board.opponentHeroes;
            var myBase = isMax ? board.myBase : board.opponentBase;
            var opponentBase = isMax ? board.opponentBase : board.myBase;
            IList<long>[] heroMoves = new List<long>[3];
            long heroMove;
            //Initialize 
            for (int i = 0; i < 3; i++)
            {
                heroMoves[i] = new List<long>();
            }
            if (isMax)
            {
                var move = gameHelper.GetBestMove();
                for (int i = 0; i < 3; i++)
                {
                    heroMoves[i].Add(move.GetMove(i));
                }
            }
            /*
            for (int i = 0; i < myHeroes.Count; i++)
            {
                var hero = myHeroes[i];
                var target = gameHelper.MaximizeTargetsOnAllMonstersInRange(hero);
                if (target != null)
                {
                    heroMove = HeroMove.CreateHeroMove(target.GetTruncatedX(), target.GetTruncatedY());
                    heroMoves[i].Add(heroMove);
                }
            }
            */
            //Build movement moves
            foreach (BoardPiece piece in board.boardPieces)
            {
                //Do not move towards monsters that are targeting the enemy
                if (piece is Monster && ((Monster)piece).threatForMax.HasValue && ((Monster)piece).threatForMax.Value != isMax)
                    continue;
                for (int i = 0; i < myHeroes.Count; i++)
                {
                    if (!myHeroes[i].isControlled)
                    {
                        if (heroMoves[i].Count > 1)
                            continue;
                        heroMove = HeroMove.CreateHeroMove(piece.x, piece.y);
                        heroMoves[i].Add(heroMove);
                    }
                }
            }
            //Build spell moves
            for (int i = 0; i < myHeroes.Count; i++)
            {
                Hero h = myHeroes[i];
                foreach (BoardPiece piece in board.boardPieces)
                {
                    if (piece is Base)
                    {
                        //do nothing
                    }
                    else
                    {
                        if (myBase.mana >= 10 && piece.shieldLife == 0)
                        {
                            //do not wind friendly heroes
                            if (!(piece is Hero && piece.isMax.Value == isMax))
                            {//Wind spell
                                //Check range 
                                if (h.GetDistance(piece) <= Board.WindCastDistance)
                                {
                                    //heroMove = HeroMove.CreateWindSpellMove(myBase.x, myBase.y);
                                    //heroMoves[i].Add(heroMove);
                                    heroMove = HeroMove.CreateWindSpellMove(opponentBase.x, opponentBase.y);
                                    heroMoves[i].Add(heroMove);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            /*
            foreach (BoardPiece piece in board.boardPieces)
            {
                if (piece is Base)
                {
                    //do nothing
                }
                else
                {
                    if (myBase.mana >= 10 && piece.shieldLife == 0)
                    {
                        //do not shield opponent heroes
                        if (!(piece is Hero && piece.isMax.Value != isMax))
                        {//Shield spell
                            for (int i = 0; i < 3; i++)
                            {
                                Hero h = myHeroes[i];
                                //Check range and shield; 
                                if (h.GetDistance(piece) < 2200)
                                {
                                    heroMove = HeroMove.CreateShieldSpellMove(piece.id);
                                    heroMoves[i].Add(heroMove);
                                }
                            }
                        }
                        //do not control friendly heroes
                        if (!(piece is Hero && piece.isMax.Value == isMax))
                        {//Control spell
                            for (int i = 0; i < 3; i++)
                            {
                                Hero h = myHeroes[i];
                                //Check range and shield; 
                                if (h.GetDistance(piece) < 2200)
                                {
                                    heroMove = HeroMove.CreateControlSpellMove(myBase.x, myBase.y, piece.id);
                                    heroMoves[i].Add(heroMove);
                                    heroMove = HeroMove.CreateControlSpellMove(opponentBase.x, opponentBase.y, piece.id);
                                    heroMoves[i].Add(heroMove);
                                }
                            }
                        }
                    }
                }
            }
            */
            for (int i = 0; i < 3; i++)
            {
                heroMove = HeroMove.CreateWaitMove();
                if(heroMoves[i].Count == 0)
                    heroMoves[i].Add(heroMove);
            }
            //Take each single hero move and combine them into a set of 3 hero moves using all permutations
            foreach (long heroMove1 in heroMoves[0])
            {
                foreach (long heroMove2 in heroMoves[1])
                {
                    foreach (long heroMove3 in heroMoves[2])
                    {
                        var move = new Move();
                        move.AddMove(heroMove1, 0);
                        move.AddMove(heroMove2, 1);
                        move.AddMove(heroMove3, 2);
                        finalPossibleMoves.Add(move);
                    }
                }
            }
            //Console.Error.WriteLine("Total Move Count: " + finalPossibleMoves.Count);
            return finalPossibleMoves;
        }
        public IList GetPossibleMoves(bool isMax)
        {
            return isMax ? (IList)possibleMaxMoves : (IList)possibleMinMoves;
        }
        public double? GetWinner()
        {
            double? winner = board.GetWinner();
            if (this.turn == 220 & !winner.HasValue)
            {
                return 0;
            }
            return winner;
        }
    }
}
