/*
 * File generated by SourceCombiner.exe using 11 source files.
 * Created On: 4/22/2022 8:40:15 PM
*/
using Algorithms;
using Algorithms.Trees;
using Algorithms.Utility;
using GameSolution.Algorithms.Genetic;
using GameSolution.Algorithms.NeuralNetwork;
using GameSolution.Entities;
using GameSolution.Game;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//*** SourceCombiner -> original file Combined.cs ***
/*
 * File generated by SourceCombiner.exe using 15 source files.
 * Created On: 4/22/2022 8:29:24 PM
*/
//*** SourceCombiner -> original file GeneticAlgorithm.cs ***
namespace GameSolution.Algorithms.Genetic
{
    public class GeneticAlgorithm
    {
        /**The population for the genetic algorithm to choose from*/
        private Population population;
        /**The rate at which mutations occur*/
        private double mutationRate;
        /**The percent of the original population that will be in the new population*/
        private double elitePercent;
        /**The percent of the chromosome to use from the first parent*/
        private double crossOver;
        public int generationCounter {get; set;}
        Random rand;
        /**Sets the initial population and the mutation rate*/
        public GeneticAlgorithm(Population initialPopulation, double mRate, double eP, double cO)
        {
            population = initialPopulation;
            mutationRate = mRate;
            elitePercent = eP;
            crossOver = cO;
            rand = new Random();
            generationCounter = 0;
        }
        /** Method to run the genetic algorithm once so that it does the following:
         * 1) Sorts the population based on the fitness of each individual 
         * 2) Kills off all of the population except for those that were in the top 5%
         * 3) Select two parents from the population
         * 4) Create a baby and add him to the new population
         * 5) Set the old population to the new one
         * @returns the new population
         */
        public Population runOnce()
        {
            generationCounter++;
            Population newPopulation = new Population(population.size);
            Individual individual1;
            Individual individual2;
            Individual child;
            //1) Sorts the population based on the fitness of each individual
            population.sortPopulation();
            //2) keep the top elite percent that are performing well
            for (int x = 0; x < (int)(population.size * elitePercent); x++)
            {
                population.getIndividual(x).SetFitness(0);
                newPopulation.addIndividual(population.getIndividual(x));
            }
            for (int x = (int)(population.size * elitePercent); x < population.size; x++)
            {
                //3) Select two parents from the population
                individual1 = population.selectRandomFromPopulation();
                individual2 = population.selectRandomFromPopulation();
                //4)Create a baby and add him to the new population
                child = individual1.CreateBaby(individual2, crossOver);
                if (rand.NextDouble() < mutationRate)
                    child.Mutate();
                newPopulation.addIndividual(child);
                x++;
                if (x < population.size)
                {
                    child = individual2.CreateBaby(individual1, crossOver);
                    if (rand.NextDouble() < mutationRate)
                        child.Mutate();
                    newPopulation.addIndividual(child);
                }
            }
            //5) Set the old population to the new one
            population = newPopulation;
            return newPopulation;
        }
    }
}
//*** SourceCombiner -> original file Individual.cs ***
namespace GameSolution.Algorithms.Genetic
{
    /* Interface for the individuals within the population for a genetic algorithm */
    public interface Individual
    {
        /** Creates an individual from two parents*/
        Individual CreateBaby(Individual parent2, double crossOver);
        /** Mutates the individual */
        void Mutate();
        /** Returns the fitness of the individual */
        double GetFitness();
        /** Sets the fitness of the individual */
        void SetFitness(double fit);
        /** Determines if two individuals are the same */
        bool Equals(Individual i);
    }
}
//*** SourceCombiner -> original file Population.cs ***
namespace GameSolution.Algorithms.Genetic
{
    public class Population
    {
        //The individuals within this population
        private Individual[] individuals;
        //The size of the population
        public int size { get; private set; }
        Random rand;
        /**Creates an empty population
          * @param size- The size of the population
          * */
        public Population(int size)
        {
            individuals = new Individual[size];
            size = 0;
            rand = new Random();
        }
        /**Sorts the population based on the individuals Fitness
          * Sorts using a simple insertion sort.  Could probably exchange this
          * sort for another one at a later point in time.
          * */
        public void sortPopulation()
        {
            Individual temp;
            for (int x = 1; x < size; x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (individuals[x].GetFitness() > individuals[y].GetFitness())
                    {
                        temp = individuals[x];
                        for (int z = x; z > y; z--)
                        {
                            individuals[z] = individuals[z - 1];
                        }
                        individuals[y] = temp;
                        y = x;
                    }
                }
            }
        }
        /**Selects a random Individual from the population in a roulette wheel fashion with individuals
          * who have a higher fitness having a higher chance of being selected.
          * @return The selected Individual
          * */
        public Individual selectRandomFromPopulation()
        {
            double totalFit = 0;
            for (int x = 0; x < this.size; x++)
            {
                totalFit = totalFit + Math.Abs(individuals[x].GetFitness());
            }
            double randNum = (rand.NextDouble() * totalFit);
            int y = 0;
            double totalFitSoFar = Math.Abs(individuals[y].GetFitness());
            while (totalFitSoFar < randNum)
            {
                y++;
                totalFitSoFar = totalFitSoFar + Math.Abs(individuals[y].GetFitness());
            }
            return individuals[y];
        }
        /**Calculates the maximum fitness of the population
          * @return the highest fitness value of the population
          * */
        public double maxFitness()
        {
            double maxFit = individuals[0].GetFitness();
            for (int x = 1; x < size; x++)
            {
                if (maxFit < individuals[x].GetFitness())
                    maxFit = individuals[x].GetFitness();
            }
            return maxFit;
        }
        /**Calculates the minimum fitness value of the population
          * @return The lowest fitness value of the population
          * */
        public double minFitness()
        {
            double minFit = individuals[0].GetFitness();
            for (int x = 1; x < size; x++)
            {
                if (minFit > individuals[x].GetFitness())
                    minFit = individuals[x].GetFitness();
            }
            return minFit;
        }
        /**Calculates the average fitness of the population
          * @return The average fitness of the population
          * */
        public double avgFitness()
        {
            double avgFit = 0;
            for (int x = 0; x < size; x++)
            {
                avgFit = avgFit + individuals[x].GetFitness();
            }
            return avgFit / size;
        }
        /**Gets an individual at index location
          * @param location- The location of the desired Individual
          * @return The desired individual from index location
          * */
        public Individual getIndividual(int location)
        {
            return individuals[location];
        }
        /**Adds an individual to the population
          * @param i- The individual to add
          * */
        public void addIndividual(Individual i)
        {
            individuals[size] = i;
            size++;
        }
    }
}
//*** SourceCombiner -> original file NeuralNetwork.cs ***
namespace GameSolution.Algorithms.NeuralNetwork
{
    /**The NeuralNetwork Class is used as the 'brain'*/
    public class NeuralNetwork : Individual
    {
        //The array of NeuronLayers keeps track of the neurons within the network
        private NeuronLayer[] neuronLayers;
        //The number of layers of neurons in the network
        private int numLayers;
        //The number of neurons within each layer of the network
        private int[] numNeurons;
        //The number of inputs that go into the first layer of the network
        private int[] numInputs;
        private int nFirstInputs;
        //The total number of weights within the network
        private int totalNumWeightsInNetwork;
        //The fitness of the neural network
        private double fitness;
        Random rand;
        /**Generates all of the layers of the network 
          * @param nLayers- The number of layers of neurons within the network
          * @param nNeurons- The number of neurons within each layer of the network
          * @param nInputs- The number of inputs going into the first layer of the network
          * */
        public NeuralNetwork(int nLayers, int[] nNeurons, int nInputs)
        {
            rand = new Random();
            numLayers = nLayers;
            numNeurons = nNeurons;
            nFirstInputs = nInputs;
            numInputs = new int[nLayers];
            numInputs[0] = nInputs;
            for (int x = 1; x < nLayers; x++)
            {
                numInputs[x] = numNeurons[x - 1];
            }
            neuronLayers = new NeuronLayer[nLayers];
            for (int x = 0; x < nLayers; x++)
            {
                neuronLayers[x] = new NeuronLayer(numNeurons[x], numInputs[x]);
                totalNumWeightsInNetwork += numNeurons[x] * numInputs[x];
            }
            fitness = 0;
        }
        public NeuralNetwork(BinaryReader reader)
        {
            numLayers = reader.ReadInt32();
            numNeurons = new int[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                numNeurons[x] = reader.ReadInt32();
            }
            numInputs = new int[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                numInputs[x] = reader.ReadInt32();
            }
            nFirstInputs = numInputs[0];
            neuronLayers=new NeuronLayer[numLayers];
            for (int x = 0; x < numLayers; x++)
            {
                neuronLayers[x]=new NeuronLayer(numNeurons[x], numInputs[x]);
                totalNumWeightsInNetwork += numNeurons[x] * numInputs[x];
            }
            double[] weights = new double[getNumWeights()];
            for(int i = 0; i<weights.Length; i++)
            {
                weights[i] = reader.ReadDouble();
            }
            setWeights(weights);
            fitness = reader.ReadDouble();
        }
        public void Save(BinaryWriter writer)
        {
            writer.Write(numLayers);
            for (int x = 0; x < numNeurons.Count(); x++)
            {
                writer.Write(numNeurons[x]);
            }
            for (int x = 0; x < numInputs.Count(); x++)
            {
                writer.Write(numInputs[x]);
            }
            double[] weights = getWeights();
            foreach(double weight in weights)
            {
                writer.Write(weight);
            }
            writer.Write(fitness);
        }
        /**Gets the NeuronLayer at a specified location
          * @param location- The specified layer that is to be retrieved
          * @return The NeuronLayer at location
          * */
        public NeuronLayer getNeuronLayer(int location)
        {
            return neuronLayers[location];
        }
        /**Gets the number of layers within the network
          * @return The number of layers
          * */
        public int getNumLayers()
        {
            return numLayers;
        }
        /**Gets the number of neurons within the network
          * @return an array that describes how many neurons there are in each layer
          * */
        public int[] getNumNeurons()
        {
            return numNeurons;
        }
        /**Gets the number of inputs going into each layer within the network
          * @return an array that describes the number of inputs going into each layer
          * */
        public int[] getNumInputs()
        {
            return numInputs;
        }
        /**Gets the total number of weights within the network
          * @return the total number of weights
          * */
        public int getNumWeights()
        {
            return totalNumWeightsInNetwork;
        }
        /**Gets all of the current weights being used within the network.  This function goes layer by layer
          * to pull out all of the weights and puts them into a single array.
          * @return an array that contains the value of all of the weights
          * */
        public double[] getWeights()
        {
            double[] weights = new double[totalNumWeightsInNetwork];
            double[] layerWeights;
            int count = 0;
            for (int x = 0; x < getNumLayers(); x++)
            {
                layerWeights = getNeuronLayer(x).getWeights();
                for (int y = 0; y < layerWeights.Count(); y++)
                {
                    weights[count] = layerWeights[y];
                    count++;
                }
            }
            return weights;
        }
        /**Displays all of the current weights in the network
          * */
        public void displayWeights()
        {
            double[] weights = getWeights();
            for (int x = 0; x < weights.Count(); x++)
            {
                Console.Error.Write(weights[x] + ", ");
            }
            Console.Error.WriteLine();
        }
        /**Sets all of the weights within the network going layer by layer
          * @param weights- The weights to be used for the neural network
          * */
        public void setWeights(double[] weights)
        {
            int count = 0;
            for (int x = 0; x < getNumLayers(); x++)
            {
                for (int y = 0; y < neuronLayers[x].getNumNeurons(); y++)
                {
                    for (int z = 0; z < neuronLayers[x].getNeuron(y).getNumWeights(); z++)
                    {
                        neuronLayers[x].getNeuron(y).setWeight(z, weights[count]);
                        count++;
                    }
                }
            }
        }
        /**Determines the output of the network given all of the inputs
          * @param inputs- The inputs to the neural network
          * @return The output of the neural network
          * */
        public double[] output(double[] inputs)
        {
            double[] output = inputs;
            //lets each layer handle its own output and the output of the 
            //previous becomes the input of the next layer
            for (int x = 0; x < getNumLayers(); x++)
            {
                output = getNeuronLayer(x).output(output);
            }
            return output;
        }
        //Individual Methods for the genetic algorithm
        //creates an individual from two parents 
        public Individual CreateBaby(Individual parent2, double crossOver)
        {
            double[] weights = new double[getNumWeights()];
            double[] p1weights = getWeights();
            double[] p2weights = ((NeuralNetwork)parent2).getWeights();
            for (int x = 0; x < getNumWeights(); x++)
            {
                if (getNumWeights() * crossOver < x)
                    weights[x] = p1weights[x];
                else weights[x] = p2weights[x];
            }
            NeuralNetwork net = new NeuralNetwork(getNumLayers(), getNumNeurons(), nFirstInputs);
            net.setWeights(weights);
            return net;
        }
        //mutates the individual 
        public void Mutate()
        {
            double[] weights = getWeights();
            int num = (int)(rand.NextDouble() * getNumWeights());
            weights[num] = (rand.NextDouble() * 2 - 1);
            setWeights(weights);
        }
        //checks if two individuals are equal
        public bool Equals(Individual i)
        {
            double[] weights1 = getWeights();
            double[] weights2 = ((NeuralNetwork)i).getWeights();
            for (int x = 0; x < weights1.Count(); x++)
            {
                if (weights1[x] != weights2[x])
                    return false;
            }
            return true;
        }
        public double GetFitness()
        {
            return fitness;
        }
        public void SetFitness(double fit)
        {
            fitness = fit;
        }
    }
}
//*** SourceCombiner -> original file Neuron.cs ***
namespace GameSolution.Algorithms.NeuralNetwork
{
    public class Neuron
    {
        //The weights for this neuron
        private double[] weights;
        //The number of weights 
        private int numWeights;
        Random rand;
        /**Creates a neuron with starting weights between -1 and 1
          * @param numInputs- The number of weights needed and the number of inputs
          * */
        public Neuron(int numInputs)
        {
            rand = new Random();
            numWeights = numInputs;
            weights = new double[numInputs];
            for (int x = 0; x < numInputs; x++)
            {
                weights[x] = rand.NextDouble() * 2 - 1;
            }
        }
        /**Gets a weight at a particular location
          * @param location- The location of the weight within the array
          * @return the value of the weight at index location
          */
        public double getWeight(int location)
        {
            return weights[location];
        }
        /**Gets the number of weights
          * @return the number of weights
          * */
        public int getNumWeights()
        {
            return numWeights;
        }
        /**Sets the weight at a particular location to the value in weight
          * @param location- The location to put the weight
          * @param weight- The value to put at index location
          * */
        public void setWeight(int location, double weight)
        {
            weights[location] = weight;
        }
    }
}
//*** SourceCombiner -> original file NeuronLayer.cs ***
namespace GameSolution.Algorithms.NeuralNetwork
{
    public class NeuronLayer
    {
        //The neurons within this layer
        private Neuron[] neurons;
        //The number of neurons
        private int numNeurons;
        /**Generates a NeuronLayer from the number of neurons and number of inputs
          * @param nNeurons- The number of neurons in this layer
          * @param numInputs- The number of inputs going into this layer
          * */
        public NeuronLayer(int nNeurons, int numInputs)
        {
            numNeurons = nNeurons;
            neurons = new Neuron[numNeurons];
            for (int x = 0; x < numNeurons; x++)
            {
                neurons[x] = new Neuron(numInputs);
            }
        }
        /**Gets a neuron at index location
          * @param location- The location of the neuron
          * @return the neuron at index location
          * */
        public Neuron getNeuron(int location)
        {
            return neurons[location];
        }
        /**Gets the number of neurons
          * @return the number of neurons
          * */
        public int getNumNeurons()
        {
            return numNeurons;
        }
        /**Gets all of the weights for this layer
          * @return the values of the weights in this layer
          * */
        public double[] getWeights()
        {
            double[] weights = new double[neurons[0].getNumWeights() * numNeurons];
            int count = 0;
            for (int x = 0; x < getNumNeurons(); x++)
            {
                for (int y = 0; y < neurons[x].getNumWeights(); y++)
                {
                    weights[count] = neurons[x].getWeight(y);
                    count++;
                }
            }
            return weights;
        }
        /**Gets the number of weights; calculated by the Number of Neurons times the Number of Inputs going into
          * this layer.
          * @returns The number of weights
          * */
        public int getNumWeights()
        {
            return getNumNeurons() * getNeuron(0).getNumWeights();
        }
        /**Calculates the output of this layer based on the given inputs
          * @param inputs- The values of the inputs
          * @return The responses of each neuron within this layer
          * */
        public double[] output(double[] inputs)
        {
            double[] output = new double[getNumNeurons()];
            double sum = 0;
            int temp = 0;
            for (int x = 0; x < getNumNeurons(); x++)
            {
                for (int y = 0; y < getNeuron(x).getNumWeights() - temp; y++)
                {
                    sum = sum + inputs[y] * getNeuron(x).getWeight(y);
                }
                //System.out.println(sum);
                output[x] = sigmoid(sum);
                sum = 0;
            }
            return output;
        }
        /**Calculates the value of the sigmoid function for a particular x value.  The sigmoid function
          * is an S-shaped graph with f(x)=1/(1+e^(-x)).
          * value- The x value used to calculate the y value
          * */
        public double sigmoid(double value)
        {
            return (1.0 / (1.0 + Math.Exp(-value)));
        }
    }
}
//*** SourceCombiner -> original file TreeAlgorithm.cs ***
namespace Algorithms
{
    public class TreeAlgorithm
    {
        protected GameTreeNode RootNode { get; private set; }
        public void SetState(IGameState rootState, bool isMax = true, bool findState = true)
        {
            if (RootNode != null && findState)
            {
                //if we have already started searching then continue to search as we go if possible; the search will scan two layers to see if only one move was played or if 2 moves were played to get back to the original players turn.
                //find the child that matches the new node
                bool isFound = false;
                //Expand any moves left in the root node (if any)
                foreach (object move in RootNode.moves)
                {
                    Expand(RootNode, move);
                }
                //Begin scanning the children
                foreach (GameTreeNode child in RootNode.children)
                {
                    if (child.state.Equals(rootState))
                    {
                        RootNode = child;
                        isFound = true;
                        break;
                    }
                    foreach (object move in child.moves)
                    {
                        Expand(child, move);
                    }
                    foreach (GameTreeNode descendent in child.children)
                    {
                        if (descendent.state.Equals(rootState))
                        {
                            RootNode = descendent;
                            isFound = true;
                            break;
                        }
                    }
                }
                if (!isFound)
                {
                    Console.Error.WriteLine("Could not find the next state in tree!  Starting over...");
                    RootNode = new GameTreeNode(rootState.Clone(), isMax);
                }
                else
                {
                    RootNode.parent = null;
                }
            }
            else
            {
                RootNode = new GameTreeNode(rootState.Clone(), isMax);
            }
        }
        /// <summary>
        /// Expands the given node by create a clone, applying the move and then adding it to the list of children.
        /// </summary>
        /// <param name="node">The node to expand</param>
        /// <param name="move">The move to play on the expanded node</param>
        /// <returns></returns>
        protected GameTreeNode Expand(GameTreeNode node, object move)
        {
            IGameState nextState = node.state.Clone();
            nextState.ApplyMove(move, node.isMax);
            GameTreeNode childNode = new GameTreeNode(nextState, !node.isMax, node);
            node.children.Add(childNode);
            return childNode;
        }
    }
}
//*** SourceCombiner -> original file GameTreeNode.cs ***
namespace Algorithms.Trees
{
    public class GameTreeNode
    {
        public IGameState state;
        public IList moves;
        public List<GameTreeNode> children;
        public double wins = 0;
        public double loses = 0;
        public int totalPlays = 0;
        public GameTreeNode parent;
        public bool isMax;
        public GameTreeNode(IGameState state, bool isMax, GameTreeNode parent = null)
        {
            this.state = state;
            moves = new List<object>();
            foreach(object obj in state.GetPossibleMoves(isMax))
            {
                moves.Add(obj);
            }
            children = new List<GameTreeNode>();
            this.parent = parent;
            this.isMax = isMax;
        }
        public double GetScore(bool isMax)
        {
            double totalPlays = TotalPlays();
            if (totalPlays == 0)
                return 0;
            if (isMax)
            {
                return (wins - loses) / totalPlays;
            }
            else
            {
                return (loses - wins) / totalPlays;
            }
        }
        public int TotalPlays()
        {
            return totalPlays;
        }
        public double? GetWinner()
        {
            return state.GetWinner();
        }
        public void ApplyWinner(double? winner)
        {
            if (winner.HasValue)
            {
                if(winner > 0)
                {
                    wins += winner.Value;
                }
                else if(winner < 0)
                {
                    loses += Math.Abs(winner.Value);
                }
                totalPlays++;
            }
        }
        public double Evaluate()
        {
            return state.Evaluate(isMax);
        }
    }
}
//*** SourceCombiner -> original file Graph.cs ***
namespace Algorithms.Graph
{
    public class Graph
    {
        private List<INode> Nodes;
        //Will hold shortest paths from a start node id to an end node id
        private Dictionary<int, Dictionary<int, List<ILink>>> Paths { get; set; }
        public Graph()
        {
            Nodes = new List<INode>();
        }
        public void AddNode(INode node)
        {
            Nodes.Add(node);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            foreach (INode vertex in Nodes)
            {
                InternalBuildShortestPathsFromStartNode(vertex);
            }
        }
        public void BuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            Paths = new Dictionary<int, Dictionary<int, List<ILink>>>();
            InternalBuildShortestPathsFromStartNode(startNode, maxDistance);
        }
        private void InternalBuildShortestPathsFromStartNode(INode startNode, double maxDistance = double.MaxValue)
        {
            foreach (INode node in Nodes)
            {
                node.IsExplored = false;
            }
            List<ILink> minimumSpanningTree = new List<ILink>();
            Paths[startNode.Id] = new Dictionary<int, List<ILink>>();
            Paths[startNode.Id][startNode.Id] = new List<ILink>();
            minimumSpanningTree.Add(new Link(startNode, startNode, 0));
            int vertexCount = Nodes.Count;
            double currentDist;
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                ILink bestLink = null;
                ILink parentLink = null;
                foreach (ILink currentLink in minimumSpanningTree)
                {
                    INode currentNode = currentLink.EndNode;
                    currentDist = currentLink.GetDistance(Paths[startNode.Id][currentNode.Id]);
                    foreach (ILink adjacent in currentNode.GetLinks())
                    {
                        INode adjacentNode = adjacent.EndNode;
                        if (adjacentNode.IsExplored)
                        {
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestLink = adjacent;
                            parentLink = currentLink;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode.Id].TryGetValue(currentNode.Id, out List<ILink> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode.Id].TryGetValue(parentLink.EndNode.Id, out List<ILink> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestLink = adjacent;
                                parentLink = currentLink;
                            }
                        }
                    }
                }
                if (parentLink == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestLink);
                bestLink.EndNode.IsExplored = true;
                List<ILink> currentPath = null;
                if (!parentLink.EndNode.Equals(startNode))
                {
                    Paths[startNode.Id].TryGetValue(parentLink.EndNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<ILink>();
                }
                else
                {
                    currentPath = new List<ILink>(currentPath);
                }
                Paths[startNode.Id].Add(bestLink.EndNode.Id, currentPath);
                currentPath.Add(bestLink);
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The next node in the path</returns>
        public INode GetNextNodeInShortestPath(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startNode.Id);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endNode.Id + " start: " + startNode.Id);
                throw new InvalidOperationException();
            }
            INode shortest = paths.First().EndNode;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startNode.Id + " to: " + endNode.Id);
            return shortest;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(INode startNode, INode endNode)
        {
            Paths.TryGetValue(startNode.Id, out Dictionary<int, List<ILink>> endPoints);
            if (endPoints == null)
            {
                return double.MaxValue;
            }
            endPoints.TryGetValue(endNode.Id, out List<ILink> paths);
            if (paths == null)
            {
                return double.MaxValue;
            }
            return paths.First().GetDistance(paths);
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node</param>
        /// <param name="endId">The ending node</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(Node startNode, Node endNode)
        {
            return startNode.GetLinks().Where(l => l.EndNode.Equals(endNode)).First().Distance;
        }
    }
}
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace Algorithms.Graph
{
    public class GraphLinks
    {
        public class Node
        {
            public int Id { get; set; }
            public double Distance { get; set; }
            public bool IsExplored { get; set; }
            public Node(int id, double distance)
            {
                Id = id;
                Distance = distance;
            }
            /// <summary>
            /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
            /// </summary>
            /// <param name="currentDist">The current distance from the starting node</param>
            /// <returns>A clone of the node with the proper distance</returns>
            public Node CreateAtDistance(double currentDist)
            {
                return new Node(Id, currentDist + Distance);
            }
        }
        private Dictionary<int, List<Node>> Links { get; set; }
        private Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        private bool IsByDirectional;
        public GraphLinks(bool isByDirectional = true)
        {
            Links = new Dictionary<int, List<Node>>();
            IsByDirectional = isByDirectional;
        }
        public bool ContainsLink(int id1, int id2)
        {
            return Links.ContainsKey(id1) && Links[id1].Where(n => n.Id == id2).Any();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="id1">First id</param>
        /// <param name="id2">Second id</param>
        /// <param name="distance">The distance between the two nodes</param>
        public void AddLink(int id1, int id2, double distance)
        {
            //Console.Error.WriteLine(id1 + " " + id2 + " " + distance);
            AddLinkInternal(id1, id2, distance);
            if(IsByDirectional)
                AddLinkInternal(id2, id1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the node links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount, 9999999);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from a start node
        /// </summary>
        /// <param name="startNode">id of the start node</param>
        /// <param name="maxDistance">the fartheset distance to travel</param>
        public void CalculateShortestPathsFromStartNode(int startNode, int maxDistance)
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            CalculateShortestPathFromStartNode(startNode, Links.Keys.Count, maxDistance);
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting id</param>
        /// <param name="vertexCount">The number of nodes</param>
        /// <param name="maxDistance">the farthest distance to travel</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount, int maxDistance)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            double currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                double minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (adjacent.IsExplored || minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            adjacent.IsExplored = true;
                            continue;//skip nodes already in minimum spanning tree
                        }
                        double distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent < lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
                if (minDist >= maxDistance)
                    return;
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given node
        /// </summary>
        /// <param name="id">The node id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int id)
        {
            return Links[id];
        }
        public Dictionary<int, List<Node>> GetPaths(int startId)
        {
            return Paths[startId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance from start to end</returns>
        public double GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The distance along the shortest path</returns>
        public double GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next node along the path from start to end
        /// </summary>
        /// <param name="startId">The starting node id</param>
        /// <param name="endId">The ending node id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        /// <summary>
        /// Retrieves the full path from start to end
        /// </summary>
        /// <param name="startId">the start id</param>
        /// <param name="endId">the end id</param>
        /// <returns>The full path</returns>
        public List<Node> GetShortestPathAll(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                throw new InvalidOperationException();
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                throw new InvalidOperationException();
            }
            return paths;
        }
        //Adds links to the node links
        private void AddLinkInternal(int startNode, int endNode, double distance)
        {
            List<Node> nodeLinks;
            if (Links.ContainsKey(startNode))
            {
                nodeLinks = Links[startNode];
            }
            else
            {
                nodeLinks = new List<Node>();
                Links[startNode] = nodeLinks;
            }
            nodeLinks.Add(new Node(endNode, distance));
        }
    }
}
//*** SourceCombiner -> original file INode.cs ***
namespace Algorithms.Graph
{
    public interface INode
    {
        int Id { get; }
        bool IsExplored { get; set; }
        List<ILink> GetLinks();
    }
    public class Node : INode
    {
        public int Id { get; private set; }
        public bool IsExplored { get; set; }
        private List<ILink> Links;
        public Node(int id)
        {
            Id = id;
            IsExplored = false;
            Links = new List<ILink>();
        }
        public void AddLink(ILink link)
        {
            Links.Add(link);
        }
        public List<ILink> GetLinks()
        {
            return Links;
        }
        public bool Equals(INode node)
        {
            return node.Id == Id;
        }
    }
    public interface ILink
    {
        INode StartNode { get; }
        INode EndNode { get; }
        long Distance { get; }
        long GetDistance(List<ILink> currentPath);
    }
    public class Link : ILink
    {
        public INode StartNode { get; private set; }
        public INode EndNode { get; private set; }
        public long Distance { get; private set; }
        public Link(INode startNode, INode endNode, long distance)
        {
            StartNode = startNode;
            EndNode = endNode;
            Distance = distance;
        }
        public long GetDistance(List<ILink> currentPath)
        {
            long distance = 0;
            foreach(ILink link in currentPath)
            {
                distance += link.Distance;
            }
            return distance;
        }
    }
}
//*** SourceCombiner -> original file Minimax.cs ***
namespace Algorithms
{
    public class Minimax : TreeAlgorithm
    {
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = int.MaxValue)
        {
            double val = 99999999;
            val *= RootNode.isMax ? -1 : 1;
            object bestMove = null;
            foreach (object move in RootNode.moves)
            {
                GameTreeNode child = Expand(RootNode, move);
                double currentVal = RunMinimax(child, depth, -999999, 999999, watch, timeLimit);
                if ((RootNode.isMax && currentVal > val) || (!RootNode.isMax && currentVal < val))
                {
                    bestMove = move;
                    val = currentVal;
                }
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    break;
                }
            }
            return bestMove;
        }
        public double RunMinimax(GameTreeNode currentNode, int depth, double alpha, double beta, Stopwatch watch, int timeLimit)
        {
            if (depth == 0 || watch.ElapsedMilliseconds >= timeLimit)
            {
                double eval = currentNode.Evaluate();
                return eval;
            }
            double? winner = currentNode.GetWinner();
            if (winner.HasValue)
            {
                return winner.Value;
            }
            if (currentNode.isMax)
            {
                double value = -99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Max(value, minMax);
                    alpha = Math.Max(alpha, value);
                    if (alpha >= beta)
                    {
                        break;
                    }
                }
                return value;
            }
            else
            {
                double value = 99999;
                double minMax;
                foreach (object move in currentNode.moves)
                {
                    GameTreeNode childNode = Expand(currentNode, move);
                    minMax = RunMinimax(childNode, depth - 1, alpha, beta, watch, timeLimit);
                    value = Math.Min(value, minMax);
                    beta = Math.Min(beta, value);
                    if (beta <= alpha)
                    {
                        break;
                    }
                }
                return value;
            }
        }
    }
}
//*** SourceCombiner -> original file IGameState.cs ***
namespace Algorithms
{
    public interface IGameState
    {
        /// <summary>
        /// Retrieve the possible moves
        /// </summary>
        /// <param name="isMax">Whether or not to retrieve moves for max</param>
        /// <returns>list of all possible moves</returns>
        IList GetPossibleMoves(bool isMax);
        /// <summary>
        /// Applies a move to the game state.  The game state must remember this move so that it can be retrieves with GetMove.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <param name="move">the move to apply</param>
        void ApplyMove(object move, bool isMax);
        /// <summary>
        /// Retrieves the move that was played to reach this state.
        /// </summary>
        /// <param name="isMax">Whether or not the move is for max</param>
        /// <returns>The move</returns>
        object GetMove(bool isMax);
        /// <summary>
        /// Clones the game state
        /// </summary>
        /// <returns>The copy of the state</returns>
        IGameState Clone();
        /// <summary>
        /// Returns whether or not the game is over and who won (1 - max wins, 0 - draw, -1 - min wins, null - game is not over)
        /// </summary>
        /// <returns>Who won the game</returns>
        double? GetWinner();
        /// <summary>
        /// Determines if the game state is the same as this one
        /// </summary>
        /// <param name="">the state to compare against</param>
        /// <returns>true if equal</returns>
        bool Equals(IGameState state);
        /// <summary>
        /// Evaluates the current game board closer to 1 is max wins closer to -1 is min wins
        /// </summary>
        /// <param name="isMax">true if it is max's turn else false</param>
        /// <returns>A number between [-1, 1]</returns>
        double Evaluate(bool isMax);
    }
}
//*** SourceCombiner -> original file MonteCarloTreeSearch.cs ***
namespace Algorithms
{
    public class MonteCarloTreeSearch : TreeAlgorithm
    {
        private Random rand;
        private bool printErrors;
        private SearchStrategy strategy;
        public enum SearchStrategy
        {
            Random = 0,
            Sequential = 1
        }
        public MonteCarloTreeSearch(bool showErrors = true, SearchStrategy searchStrategy = SearchStrategy.Random) 
        {
            rand = new Random();
            printErrors = showErrors;
            strategy = searchStrategy;
        }
        /// <summary>
        /// Get the next move
        /// </summary>
        /// <param name="watch">timer</param>
        /// <param name="timeLimit">The amount of time to give to the search in milliseconds</param>
        /// <param name="numRollouts">The number of roll outs to play per expansion</param>
        /// <returns></returns>
        public object GetNextMove(Stopwatch watch, int timeLimit, int depth = -1, int numRollouts = 1, double? exploration = null)
        {
            if(exploration == null)
            {
                exploration = Math.Sqrt(2);
            }
            int count = 0;
            do
            {
                GameTreeNode selectedNode = SelectNodeWithUnplayedMoves(RootNode, exploration.Value);
                if(selectedNode == null)
                {
                    if(printErrors)
                        Console.Error.WriteLine("Found no more moves!");
                    break;
                }
                object move = SelectMove(selectedNode);
                GameTreeNode childNode = Expand(selectedNode, move);
                double? winner = childNode.GetWinner();
                if (winner.HasValue)
                {
                    BackPropagate(childNode, winner);
                }
                else
                {
                    for (int i = 0; i<numRollouts; i++)
                    {
                        var clonedState = childNode.state.Clone();
                        winner = SimulateGame(clonedState, watch, timeLimit, depth, childNode.isMax);
                        BackPropagate(childNode, winner);
                        count++;
                    }
                }
            }
            while (watch.ElapsedMilliseconds < timeLimit);
            if(printErrors)
                Console.Error.WriteLine($"Played {count} games!");
            GameTreeNode bestChild = null;
            double bestScore = double.MinValue;
            foreach(GameTreeNode child in RootNode.children)
            {
                double score = child.GetScore(RootNode.isMax);
                if(bestScore < score)
                {
                    bestChild = child;
                    bestScore = score;
                }
                if(printErrors)
                    Console.Error.WriteLine($"w: {child.wins} l: {child.loses} total: {child.totalPlays} move: {child.state.GetMove(RootNode.isMax)} score: {score} isMax: {RootNode.isMax}");
            }
            if(printErrors)
                Console.Error.WriteLine($"Best: w: {bestChild.wins} l: {bestChild.loses} total: {bestChild.totalPlays}");
            return bestChild.state.GetMove(RootNode.isMax);
        }
        private void BackPropagate(GameTreeNode selectedNode, double? winner)
        {
            selectedNode.ApplyWinner(winner);
            GameTreeNode tempNode = selectedNode.parent;
            while(tempNode != null)
            {
                tempNode.ApplyWinner(winner);
                tempNode = tempNode.parent;
            }
        }
        private double? SimulateGame(IGameState state, Stopwatch watch, int timeLimit, int depth, bool isMax)
        {
            double? winner;
            do
            {
                object move = SelectMoveAtRandom(state, isMax);
                state.ApplyMove(move, isMax);
                if (watch.ElapsedMilliseconds >= timeLimit)
                {
                    return null;
                }
                depth--;
                isMax = !isMax;
                winner = state.GetWinner();
            }
            while (!winner.HasValue && depth != 0);
            if (winner.HasValue)
            {
                return winner;
            }
            if (depth == 0)
            {
                double eval = state.Evaluate(isMax);
                if (eval > 0)
                {
                    return 1;
                }
                else if (eval == 0)
                {
                    return 0;
                }
                else return -1;
            }
            throw new InvalidOperationException("Could not find a winner for simulation!");
        }
        private GameTreeNode SelectNodeWithUnplayedMoves(GameTreeNode node, double exploration)
        {
            Queue<GameTreeNode> queue = new Queue<GameTreeNode>();
            queue.Enqueue(node);
            GameTreeNode tempNode;
            GameTreeNode bestNode = null;
            double maxValue = -1;
            while (queue.Count > 0)
            {
                tempNode = queue.Dequeue();
                if (tempNode.moves.Count == 0)
                {
                    foreach (GameTreeNode child in tempNode.children)
                    {
                        queue.Enqueue(child);
                    }
                }
                else if(tempNode.parent != null)
                {
                    double wins = RootNode.isMax ? tempNode.wins : tempNode.loses;
                    double nodeTotal = tempNode.TotalPlays();
                    double parentTotal = tempNode.parent.TotalPlays();
                    double value = wins / nodeTotal + exploration * Math.Sqrt(Math.Log(parentTotal) / nodeTotal);
                    if(value > maxValue)
                    {
                        maxValue = value;
                        bestNode = tempNode;
                    }
                }
                else return tempNode;
            }
            return bestNode;
        }
        private object SelectMoveAtRandom(IGameState state, bool isMax)
        {
            IList moves = state.GetPossibleMoves(isMax);
            if (moves.Count == 0)
            {
                throw new Exception("No moves available!");
            }
            int index = rand.Next(0, moves.Count);
            return moves[index];
        }
        private object SelectMove(GameTreeNode node)
        {
            switch (strategy)
            {
                case SearchStrategy.Random:
                    return SelectMoveAtRandom(node);
                case SearchStrategy.Sequential:
                    return SelectMoveSequentially(node);
            }
            throw new InvalidOperationException("strategy not supported");
        }
        private object SelectMoveSequentially(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                move = node.moves[0];
                node.moves.RemoveAt(0);
            }
            return move;
        }
        private object SelectMoveAtRandom(GameTreeNode node)
        {
            object move;
            if (node.moves.Count == 0)//If there are no more moves then that is a problem...
            {
                throw new Exception("No moves found!");
            }
            else
            {
                int index = rand.Next(0, node.moves.Count);
                move = node.moves[index];
                node.moves.RemoveAt(index);
            }
            return move;
        }
    }
}
//*** SourceCombiner -> original file BitFunctions.cs ***
namespace Algorithms.Utility
{
    public static class BitFunctions
    {
        public static bool IsBitSet(long value, int location)
        {
            long mask = GetBitMask(location);
            return (value & mask) == mask;
        }
        public static long SetBit(long value, int location)
        {
            return value | (GetBitMask(location));
        }
        public static long ClearBit(long value, int location)
        {
            return value & (~(GetBitMask(location)));
        }
        public static long SetOrClearBit(long value, int location, bool isSet)
        {
            if (isSet)
                return SetBit(value, location);
            return ClearBit(value, location);
        }
        public static int NumberOfSetBits(long i)
        {
            i = i - ((i >> 1) & 0x5555555555555555);
            i = (i & 0x3333333333333333) + ((i >> 2) & 0x3333333333333333);
            return (int)((((i + (i >> 4)) & 0xF0F0F0F0F0F0F0F) * 0x101010101010101) >> 56);
        }
        public static long GetBitMask(int index)
        {
            return (long)1 << index;
        }
    }
}
//*** SourceCombiner -> original file Hero.cs ***
namespace GameSolution.Entities
{
    public class Hero : BoardPiece
    {
        public Hero(int id, int x, int y, bool? isMax, int shieldLife, bool isControlled, int vx, int vy, bool isNearBase) : base(id, x, y, isMax, 800, 800, 2200, shieldLife, isControlled, vx, vy, isNearBase)
        {
        }
        public Hero(Hero piece) : base(piece)
        {
        }
        public Hero Clone(Hero piece)
        {
            return new Hero(piece);
        }
    }
}
//*** SourceCombiner -> original file Monster.cs ***
namespace GameSolution.Entities
{
    public class Monster : BoardPiece
    {
        public int health { get; set; }
        public bool? threatForMax { get; set; }
        public Monster(int id, int x, int y, bool? isMax, int health, int shieldLife, bool isControlled, int vx, int vy, bool isNearBase, bool? threatForMax) : base(id, x, y, isMax, 400, 300, 0, shieldLife, isControlled, vx, vy, isNearBase)
        {
            this.health = health;
            this.threatForMax = threatForMax;
        }
        public Monster(Monster piece) : base(piece)
        {
            this.health = piece.health;
            this.threatForMax = piece.threatForMax;
        }
        public Monster Clone(Monster piece)
        {
            return new Monster(piece);
        }
    }
}
//*** SourceCombiner -> original file Base.cs ***
namespace GameSolution.Entities
{
    public class Base : BoardPiece
    {
        public int health { get; set; }
        public int mana { get; set; }
        public Base(int id, int x, int y, bool isMax, int health, int mana) : base(id, x, y, isMax, 0, 0, 6000, 0, false, 0, 0, false)
        {
            this.health = health;
            this.mana = mana;
        }
        public Base(Base piece) : base(piece)
        {
            this.health = piece.health;
            this.mana = piece.mana;
        }
        public Base Clone(Base piece)
        {
            return new Base(piece);
        }
    }
}
//*** SourceCombiner -> original file Board.cs ***
namespace GameSolution.Entities
{
    public class Board
    {
        public IList<BoardPiece> boardPieces { get; set; }
        public Base myBase { get; set; }
        public Base opponentBase { get; set; }
        public IList<Monster> monsters { get; set; }
        public IList<Hero> myHeroes { get; set; }
        public IList<Hero> opponentHeroes { get; set; }
        public Board(IList<BoardPiece> boardPieces )
        {
            this.boardPieces = boardPieces;
            SetupBoard();
        }
        public Board(Board board)
        {
            boardPieces = board.boardPieces.Select(bp => bp.Clone()).ToList();
            SetupBoard();
        }
        public void SetupBoard()
        {
            monsters = new List<Monster>();
            myHeroes = new List<Hero>();
            opponentHeroes = new List<Hero>();
            foreach(BoardPiece piece in boardPieces)
            {
                if(piece is Base)
                {
                    Base b = piece as Base;
                    if (b.isMax.Value)
                    {
                        myBase = b;
                    }
                    else
                    {
                        opponentBase = b;
                    }
                }
                if(piece is Monster)
                {
                    monsters.Add(piece as Monster);
                }
                if(piece is Hero)
                {
                    Hero h = piece as Hero;
                    if (h.isMax.Value)
                    {
                        myHeroes.Add(h);
                    }
                    else
                    {
                        opponentHeroes.Add(h);
                    }
                }
            }
        }
        public void ApplyMove(Move move, bool isMax)
        {
        }
        public Board Clone()
        {
            return new Board(this);
        }
        public double? GetWinner()
        {
            if(myBase.health == 0)
            {
                return -1;
            }
            else if (opponentBase.health == 0)
            {
                return 1;
            }
            return null;
        }
    }
}
//*** SourceCombiner -> original file BoardPiece.cs ***
namespace GameSolution.Entities
{
    public enum BoardPieceType
    {
        Base = 0,
        Monster = 1,
        Hero = 2
    }
    public class BoardPiece
    {
        public int speed { get; set; }
        public int range { get; set; }
        public int sightRange { get; set; }
        public int id { get; set; }
        public int x {get; set;}
        public int y { get; set; }
        public bool? isMax { get; set; }
        public int shieldLife { get; set; }
        public bool isControlled { get; set; }
        public int vx { get; set; }
        public int vy { get; set; }
        public bool isNearBase { get; set; }
        public BoardPiece(int id, int x, int y, bool? isMax, int speed, int range, int sightRange, int shieldLife, bool isControlled, int vx, int vy, bool isNearBase)
        {
            this.id = id;
            this.x = x;
            this.y = y;
            this.isMax = isMax;
            this.speed = speed;
            this.range = range;
            this.sightRange = sightRange;
            this.shieldLife = shieldLife;
            this.isControlled = isControlled;
            this.vx = vx;
            this.vy = vy;
            this.isNearBase = isNearBase;
            distanceHash = new Dictionary<int, double>();
        }
        public BoardPiece(BoardPiece piece)
        {
            this.id = piece.id;
            this.x = piece.x;
            this.y = piece.y;
            this.isMax = piece.isMax;
            this.speed = piece.speed;
            this.range = piece.range;
            this.sightRange = piece.sightRange;
            this.shieldLife = piece.shieldLife;
            this.isControlled = piece.isControlled;
            this.vx = piece.vx;
            this.vy = piece.vy;
            this.isNearBase = piece.isNearBase;
            distanceHash = new Dictionary<int, double>();
        }
        public BoardPiece Clone()
        {
            return new BoardPiece(this);
        }
        public Dictionary<int, double> distanceHash;
        public double GetDistance(BoardPiece piece)
        {
            if (!distanceHash.ContainsKey(piece.id))
            {
                distanceHash[piece.id] = GetDistance(piece.x, x, piece.y, y);
            }
            return distanceHash[piece.id];
        } 
        public static double GetDistance(int x1, int x2, int y1, int y2)
        {
            return Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));
        }
        public string ToString()
        {
            return $"{id}, {x}, {y}, {isMax}, {GetType()}";
        }
    }
}
//*** SourceCombiner -> original file Move.cs ***
namespace GameSolution.Entities
{
    public enum MoveType
    {
        WAIT = 0,
        MOVE = 1,
        SPELL = 2
    };
    public enum SpellType
    {
        NONE = -1,
        WIND = 0,
        SHIELD = 1,
        CONTROL = 2
    };
    public class HeroMove
    {
        public int x { get; set; }
        public int y { get; set; }
        public MoveType moveType { get; set; }
        public SpellType spellType {get; set;}
        public int targetId { get; set; }
        public HeroMove(int x, int y, MoveType moveType, SpellType spellType, int entityId)
        {
            this.x = x;
            this.y = y;
            this.moveType = moveType;
            this.spellType = spellType;
            this.targetId = entityId;
        }
        public HeroMove(HeroMove heroMove)
        {
            this.x = heroMove.x;
            this.y = heroMove.y;
            this.moveType = heroMove.moveType;
            this.spellType = heroMove.spellType;
        }
        public bool Equals(HeroMove heroMove)
        {
            return this.x == heroMove.x && this.y == heroMove.y && this.moveType == heroMove.moveType && this.spellType == heroMove.spellType && this.targetId == heroMove.targetId;
        }
    }
    public class Move
    {
        List<HeroMove> heroMoves;
        public Move()
        {
            heroMoves = new List<HeroMove>();
        }
        public Move(Move move)
        {
            heroMoves = move.heroMoves.Select(m => new HeroMove(m)).ToList();
        }
        public void AddMove(Move move)
        {
            heroMoves.Add(move.heroMoves[0]);
        }
        public void AddHeroMove(int x, int y)
        {
            heroMoves.Add(new HeroMove(x, y, MoveType.MOVE, SpellType.NONE, -99));
        }
        public void AddWaitMove()
        {
            heroMoves.Add(new HeroMove(-1, -1, MoveType.WAIT, SpellType.NONE, -99));
        }
        public void AddSpellMove(int x, int y, SpellType spell, int targetId)
        {
            heroMoves.Add(new HeroMove(x, y, MoveType.SPELL, spell, targetId));
        }
        public bool Equals(Move move)
        {
            for(int i = 0; i < heroMoves.Count; i++)
            {
                if (!heroMoves.Equals(move))
                {
                    return false;
                }
            }
            return true;
        }
        public Move Clone()
        {
            return new Move(this);
        }
        public override string ToString()
        {
            StringBuilder moveStr = new StringBuilder();
            foreach(HeroMove move in heroMoves)
            {
                switch (move.moveType)
                {
                    case MoveType.MOVE:
                        moveStr.Append("MOVE " + move.x + " " + move.y + Environment.NewLine);
                        break;
                    case MoveType.WAIT:
                        moveStr.Append("WAIT " + Environment.NewLine);
                        break;
                    case MoveType.SPELL:
                        switch (move.spellType)
                        {
                            case SpellType.WIND:
                                moveStr.Append("SPELL " + move.spellType.ToString() + " " + move.x + " " + move.y + Environment.NewLine);
                                break;
                            case SpellType.SHIELD:
                                moveStr.Append("SPELL " + move.spellType.ToString() + " " + move.targetId + Environment.NewLine);
                                break;
                            case SpellType.CONTROL:
                                moveStr.Append("SPELL " + move.spellType.ToString() + " " + move.targetId + " " + move.x + " " + move.y + Environment.NewLine);
                                break;
                        }
                        break;
                }
            }
            return moveStr.ToString();
        }
    }
}
//*** SourceCombiner -> original file GameHelper.cs ***
namespace GameSolution.Game
{
    public class GameHelper
    {
        public enum Strategy
        {
            Defense = 0,
            Scout = 1,
            Attack =  2
        }
        public Board board { get; set; }
        public List<Tuple<double, Monster>> distToAllMonsters { get; set; }
        public List<Tuple<double, Hero>> distToOpponentHeroes { get; set; }
        public List<Tuple<double, Hero>> distToMyHeroes { get; set; }
        public Move GetBestMove(GameState state)
        {
            board = state.board;
            CalculateHelper();
            var strategy = DetermineStrategy();
            Move move = null;
            switch (strategy)
            {
                case Strategy.Defense:
                    move = DefenseStrategy();
                    break;
                case Strategy.Attack:
                    break;
                case Strategy.Scout:
                    break;
            }
            return move;
        }
        public void CalculateHelper()
        {
            distToAllMonsters = new List<Tuple<double, Monster>>();
            foreach (Monster m in board.monsters)
            {
                if (m.threatForMax.HasValue && !m.threatForMax.Value)
                    continue;
                double dist = board.myBase.GetDistance(m);
                distToAllMonsters.Add(new Tuple<double, Monster>(dist, m));
            }
            distToAllMonsters = distToAllMonsters.OrderBy(t => t.Item1).ToList();
            foreach (var distToMonster in distToAllMonsters)
            {
                Console.Error.WriteLine("Found monster at distance: " + distToMonster.Item1);
            }
            distToOpponentHeroes = new List<Tuple<double, Hero>>();
            foreach (Hero h in board.opponentHeroes)
            {
                double dist = board.myBase.GetDistance(h);
                distToOpponentHeroes.Add(new Tuple<double, Hero>(dist, h));
            }
            distToOpponentHeroes = distToOpponentHeroes.OrderBy(t => t.Item1).ToList();
            distToMyHeroes = new List<Tuple<double, Hero>>();
            foreach (Hero h in board.myHeroes)
            {
                double dist = board.myBase.GetDistance(h);
                distToMyHeroes.Add(new Tuple<double, Hero>(dist, h));
            }
            distToMyHeroes = distToMyHeroes.OrderBy(t => t.Item1).ToList();
        }
        public Strategy DetermineStrategy()
        {
            return Strategy.Defense;
        }
        public Move DefenseStrategy()
        {
            Move move = new Move();
            if (distToAllMonsters.Count == 0)
            {
                if (board.myHeroes[0].isNearBase)
                {
                    move.AddHeroMove(board.opponentBase.x, board.opponentBase.y);
                }
                else move.AddWaitMove();
                move.AddHeroMove(board.opponentBase.x, board.myBase.y);
                move.AddHeroMove(board.myBase.x, board.opponentBase.y);
            }
            else
            {
                if (distToAllMonsters.Count == 1)
                {
                    var m = distToAllMonsters[0].Item2;
                    if (CanCastWindOnNearBaseMonster(distToAllMonsters[0].Item2, board.myHeroes[0]))
                    {
                        move.AddSpellMove(board.opponentBase.x, board.opponentBase.y, SpellType.WIND, -99);
                    }
                    else
                    {
                        if (m.GetDistance(board.myBase) < 6000)
                        {
                            move.AddHeroMove(m.x, m.y);
                        }
                        else move.AddWaitMove();
                    }
                    move.AddHeroMove(m.x, m.y);
                    move.AddHeroMove(m.x, m.y);
                }
                else
                {
                    var m = distToAllMonsters[0].Item2;
                    if(CanCastControlOnNearBaseMonster(m, board.myHeroes[0]))
                    {
                        move.AddSpellMove(board.opponentBase.x, board.opponentBase.y, SpellType.CONTROL, m.id);
                    }
                    else if (CanCastWindOnNearBaseMonster(m, board.myHeroes[0]))
                    {
                        move.AddSpellMove(board.opponentBase.x, board.opponentBase.y, SpellType.WIND, -99);
                    }
                    else
                    {
                        if (m.GetDistance(board.myBase) < 6000)
                        {
                            move.AddHeroMove(m.x, m.y);
                        }
                        else move.AddWaitMove();
                    }
                    if(distToOpponentHeroes.Count > 0 && CanCastControlOnNearBaseHero(distToOpponentHeroes[0].Item2, board.myHeroes[1]))
                    {
                        move.AddSpellMove(board.opponentBase.x, board.opponentBase.y, SpellType.CONTROL, distToOpponentHeroes[0].Item2.id);
                    }
                    else move.AddHeroMove(m.x, m.y);
                    m = distToAllMonsters[1].Item2;
                    move.AddHeroMove(m.x, m.y);
                }
            }
            return move;
        }
        public bool CanCastControlOnNearBaseMonster(Monster monster, Hero hero)
        {
            return hero.GetDistance(monster) <= 2200 && monster.shieldLife == 0 && board.myBase.mana >= 30 && board.myBase.GetDistance(monster) > 5200 && monster.health > 10 && (!monster.threatForMax.HasValue || monster.threatForMax.Value);
        }
        public bool CanCastControlOnNearBaseHero(BoardPiece piece, Hero hero)
        {
            var countCloseMonsters = 0;
            foreach(var distToMonster in distToAllMonsters)
            {
                if(distToMonster.Item1 < 5000)
                {
                    countCloseMonsters++;
                }
            }
            return hero.isNearBase && hero.GetDistance(piece) <= 2200 && piece.shieldLife == 0 && board.myBase.mana >= 20 && countCloseMonsters > 1;
        }
        public bool CanCastWindOnNearBaseMonster(BoardPiece piece, Hero hero)
        {
            return piece.isNearBase && hero.GetDistance(piece) <= 1280 && piece.shieldLife == 0 && board.myBase.mana >= 10;
        }
    }
}
//*** SourceCombiner -> original file GameState.cs ***
namespace GameSolution.Game
{
    public class GameState : IGameState
    {
        public Board board { get; set; }
        public int turn { get; set; }
        public GameState()
        {
            turn = 0;
        }
        public void SetNextTurn(Board board)
        {
            turn++;
            this.board = board;
        }
        public GameState(GameState state)
        {
            board = state.board.Clone();
        }
        public void ApplyMove(object move, bool isMax)
        {
        }
        public IGameState Clone()
        {
            return new GameState(this);
        }
        public bool Equals(IGameState state)
        {
            throw new NotImplementedException();
        }
        public double Evaluate(bool isMax)
        {
            throw new NotImplementedException();
        }
        public object GetMove(bool isMax)
        {
            return null;
        }
        public IList GetPossibleMoves(bool isMax)
        {
            IList<Move> finalPossibleMoves = new List<Move>();
            var myHeroes = isMax ? board.myHeroes : board.opponentHeroes;
            var myBase = isMax ? board.myBase : board.opponentBase;
            var opponentBase = isMax ? board.opponentBase : board.myBase;
            if(myHeroes.Count != 3)
            {
                throw new Exception("must have 3 heroes on the map!");
            }
            IList<Move>[] heroMoves = new List<Move>[3];
            Move move;
            //Initialize with wait move
            for (int i = 0; i < 3; i++)
            {
                move = new Move();
                move.AddWaitMove();
                heroMoves[i] = new List<Move>();
                heroMoves[i].Add(move);
            }
            //Build movement moves
            foreach (BoardPiece piece in board.boardPieces)
            {
                //Do not move towards enemy heroes
                if (piece is Hero && piece.isMax.Value != isMax)
                    continue;
                //Do not move towards monsters that are targeting the enemy
                if(piece is Monster && ((Monster)piece).threatForMax.HasValue && ((Monster)piece).threatForMax.Value != isMax)
                    continue;
                for (int i = 0; i < 3; i++)
                {
                    if (!myHeroes[i].isControlled)
                    {
                        move = new Move();
                        move.AddHeroMove(piece.x, piece.y);
                        heroMoves[i].Add(move);
                    }
                }
            }
            //Build spell moves
            foreach (BoardPiece piece in board.boardPieces)
            {
                if(piece is Base)
                {
                    //do nothing
                }
                else
                {
                    if(myBase.mana >= 10 && piece.shieldLife == 0)
                    {
                        //do not wind friendly heroes
                        if (!(piece is Hero && piece.isMax.Value == isMax))
                        {//Wind spell
                            for (int i = 0; i < 3; i++)
                            {
                                Hero h = myHeroes[i];
                                //Console.Error.WriteLine("Piece: " + piece.ToString());
                                //Check range and shield, 
                                if (h.GetDistance(piece) < 1280)
                                {
                                    move = new Move();
                                    move.AddSpellMove(myBase.x, myBase.y, SpellType.WIND, -99);
                                    heroMoves[i].Add(move);
                                    move = new Move();
                                    move.AddSpellMove(opponentBase.x, opponentBase.y, SpellType.WIND, -99);
                                    heroMoves[i].Add(move);
                                }
                            }
                        }
                        //do not shield opponent heroes
                        if (!(piece is Hero && piece.isMax.Value != isMax))
                        {//Shield spell
                            for (int i = 0; i < 3; i++)
                            {
                                Hero h = myHeroes[i];
                                //Check range and shield; 
                                if (h.GetDistance(piece) < 2200)
                                {
                                    move = new Move();
                                    move.AddSpellMove(-1, -1, SpellType.SHIELD, piece.id);
                                    heroMoves[i].Add(move);
                                }
                            }
                        }
                        //do not control friendly heroes
                        if (!(piece is Hero && piece.isMax.Value == isMax))
                        {//Control spell
                            for (int i = 0; i < 3; i++)
                            {
                                Hero h = myHeroes[i];
                                //Check range and shield; 
                                if (h.GetDistance(piece) < 2200)
                                {
                                    move = new Move();
                                    move.AddSpellMove(myBase.x, myBase.y, SpellType.CONTROL, piece.id);
                                    heroMoves[i].Add(move);
                                    move = new Move();
                                    move.AddSpellMove(opponentBase.x, opponentBase.y, SpellType.CONTROL, piece.id);
                                    heroMoves[i].Add(move);
                                }
                            }
                        }
                    }
                }
            }
            //Take each single hero move and combine them into a set of 3 hero moves using all permutations
            foreach(Move heroMove1 in heroMoves[0])
            {
                foreach (Move heroMove2 in heroMoves[1])
                {
                    foreach (Move heroMove3 in heroMoves[2])
                    {
                        move = new Move();
                        move.AddMove(heroMove1);
                        move.AddMove(heroMove2);
                        move.AddMove(heroMove3);
                        finalPossibleMoves.Add(move);
                    }
                }
            }
            return (IList)finalPossibleMoves;
        }
        public double? GetWinner()
        {
            double? winner = board.GetWinner();
            if (this.turn == 220 & !winner.HasValue)
            {
                return 0;
            }
            return winner;
        }
    }
}
//*** SourceCombiner -> original file NeuralGameHelper.cs ***
namespace GameSolution.Game
{
    public class NeuralGameHelper
    {
        public GameState state;
        public NeuralNetwork heroNet1;
        public NeuralNetwork heroNet2;
        public NeuralNetwork heroNet3;
        public NeuralGameHelper(GameState state)
        {
            this.state = state;
            heroNet1 = new NeuralNetwork(4, new int[] { 118, 59, 20, 5 }, 118);
            heroNet2 = new NeuralNetwork(4, new int[] { 118, 59, 20, 5 }, 118);
            heroNet3 = new NeuralNetwork(4, new int[] { 118, 59, 20, 5 }, 118);
        }
        public void ImportNetworkFromFile(string fileName)
        {
            try
            {
                using (var reader = new BinaryReader(new FileStream(fileName, FileMode.Open)))
                {
                    heroNet1 = new NeuralNetwork(reader);
                    heroNet2 = new NeuralNetwork(reader);
                    heroNet3 = new NeuralNetwork(reader);
                }
            }
            catch (Exception){
                ExportNetworkToFile(fileName);//Export if the file doesn't exist
            }
        }
        public void ExportNetworkToFile(string fileName)
        {
            using (var writer = new BinaryWriter(new FileStream(fileName, FileMode.Create)))
            {
                heroNet1.Save(writer);
                heroNet2.Save(writer);
                heroNet3.Save(writer);
            }
        }
        public Move RunNeuralNetwork()
        {
            var game = state;
            Move move = new Move();
            AddMoveForHero(game.board.myHeroes[0], move, heroNet1);
            AddMoveForHero(game.board.myHeroes[1], move, heroNet2);
            AddMoveForHero(game.board.myHeroes[2], move, heroNet3);
            return move;
        }
        public void AddMoveForHero(Hero heroIn, Move move, NeuralNetwork heroNetIn)
        {
            var game = state;
            var distToBoardPiece = new List<Tuple<double, BoardPiece>>();
            foreach (BoardPiece piece in game.board.boardPieces)
            {
                if (piece is Monster || piece is Hero)
                {
                    distToBoardPiece.Add(new Tuple<double, BoardPiece>(heroIn.GetDistance(piece), piece));
                }
            }
            distToBoardPiece = distToBoardPiece.OrderBy(bp => bp.Item1).ToList();
            double[] neuralInputs = new double[118];
            neuralInputs[0] = game.board.myBase.health;
            neuralInputs[1] = game.board.myBase.mana;
            neuralInputs[2] = game.board.myBase.x;
            neuralInputs[3] = game.board.myBase.y;
            neuralInputs[4] = game.board.opponentBase.health;
            neuralInputs[5] = game.board.opponentBase.mana;
            neuralInputs[6] = game.board.opponentBase.x;
            neuralInputs[7] = game.board.opponentBase.y;
            var neuralIndex = 8;
            for (int i = 0; i < 10; i++)
            {
                if (distToBoardPiece.Count > i)
                {
                    var boardpiece = distToBoardPiece[i].Item2;
                    if (boardpiece is Monster)
                    {
                        var monster = boardpiece as Monster;
                        neuralInputs[neuralIndex++] = monster.health;
                        neuralInputs[neuralIndex++] = monster.id;
                        neuralInputs[neuralIndex++] = monster.isControlled ? 1 : 0;
                        neuralInputs[neuralIndex++] = monster.isNearBase ? 1 : 0;
                        neuralInputs[neuralIndex++] = monster.shieldLife;
                        neuralInputs[neuralIndex++] = monster.vx;
                        neuralInputs[neuralIndex++] = monster.vy;
                        neuralInputs[neuralIndex++] = 0;//Type 0 = monster
                        neuralInputs[neuralIndex++] = monster.threatForMax.HasValue ? monster.threatForMax.Value ? 1 : 2 : 0;
                        neuralInputs[neuralIndex++] = monster.x;
                        neuralInputs[neuralIndex++] = monster.y;
                    }
                    else
                    {
                        var hero = distToBoardPiece[i].Item2;
                        neuralInputs[neuralIndex++] = 0;//heroes don't have health
                        neuralInputs[neuralIndex++] = hero.id;
                        neuralInputs[neuralIndex++] = hero.isControlled ? 1 : 0;
                        neuralInputs[neuralIndex++] = hero.isNearBase ? 1 : 0;
                        neuralInputs[neuralIndex++] = hero.shieldLife;
                        neuralInputs[neuralIndex++] = hero.vx;
                        neuralInputs[neuralIndex++] = hero.vy;
                        neuralInputs[neuralIndex++] = hero.isMax.Value ? 1 : 2;//Type 1 = my hero, 2 = opponent hero
                        neuralInputs[neuralIndex++] = -1;
                        neuralInputs[neuralIndex++] = hero.x;
                        neuralInputs[neuralIndex++] = hero.y;
                    }
                }
                else
                {
                    for (int j = 0; j < 10; j++)
                    {
                        neuralInputs[neuralIndex++] = 0;
                    }
                }
            }
            var output1 = heroNetIn.output(neuralInputs);
            int moveType = (int)(output1[0] * 3);
            int x1 = (int)(output1[1] * 17630);
            int y1 = (int)(output1[2] * 9000);
            int spellType = (int)(output1[3] * 3);
            int entityId = distToBoardPiece[(int)(output1[4] * distToBoardPiece.Count)].Item2.id;
            switch (moveType)
            {
                case (int)MoveType.MOVE:
                    move.AddHeroMove(x1, y1);
                    break;
                case (int)MoveType.SPELL:
                    move.AddSpellMove(x1, y1, (SpellType)spellType, entityId);
                    break;
                case (int)MoveType.WAIT:
                    move.AddWaitMove();
                    break;
            }
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
    static void Main(string[] args)
    {
        bool runNeural = false;
        bool isLive = true;
        string fileName = null;
        if (args.Length > 0)
        {
            runNeural = args[0] == "1";
            isLive = false;
        }
        if(args.Length > 1)
        {
            fileName = args[1];
        }
        List<BoardPiece> pieces = new List<BoardPiece>();
        GameState state = new GameState();
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int baseX = int.Parse(inputs[0]); // The corner of the map representing your base
        int baseY = int.Parse(inputs[1]);
        int heroesPerPlayer = int.Parse(Console.ReadLine()); // Always 3
        int enemyX = baseX == 0 ? 17630 : 0;
        int enemyY = baseY == 0 ? 9000 : 0;
        bool isFirstRound = true;
        // game loop
        while (true)
        {
            pieces.Clear();
            for (int i = 0; i < 2; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int health = int.Parse(inputs[0]); // Your base health
                int mana = int.Parse(inputs[1]); // Ignore in the first league; Spend ten mana to cast a spell
                Base b;
                if(i == 0)
                {
                    b = new Base(-1, baseX, baseY, true, health, mana);
                }
                else
                {
                    b = new Base(-2, enemyX, enemyY, false, health, mana);
                }
                pieces.Add(b);
            }
            int entityCount = int.Parse(Console.ReadLine()); // Amount of heros and monsters you can see
            for (int i = 0; i < entityCount; i++)
            {
                BoardPiece p = null;
                inputs = Console.ReadLine().Split(' ');
                int id = int.Parse(inputs[0]); // Unique identifier
                int type = int.Parse(inputs[1]); // 0=monster, 1=your hero, 2=opponent hero
                int x = int.Parse(inputs[2]); // Position of this entity
                int y = int.Parse(inputs[3]);
                int shieldLife = int.Parse(inputs[4]); // Ignore for this league; Count down until shield spell fades
                int isControlled = int.Parse(inputs[5]); // Ignore for this league; Equals 1 when this entity is under a control spell
                int health = int.Parse(inputs[6]); // Remaining health of this monster
                int vx = int.Parse(inputs[7]); // Trajectory of this monster
                int vy = int.Parse(inputs[8]);
                int nearBase = int.Parse(inputs[9]); // 0=monster with no target yet, 1=monster targeting a base
                int threatFor = int.Parse(inputs[10]); // Given this monster's trajectory, is it a threat to 1=your base, 2=your opponent's base, 0=neither
                switch (type)
                {
                    case 0:
                        bool? isThreatForMax = null;
                        if (threatFor == 1)
                            isThreatForMax = true;
                        else if (threatFor == 2)
                            isThreatForMax = false;
                        p = new Monster(id, x, y, null, health, shieldLife, isControlled == 1, vx, vy, nearBase == 1, isThreatForMax);
                        break;
                    case 1:
                        p = new Hero(id, x, y, true, shieldLife, isControlled == 1, vx, vy, BoardPiece.GetDistance(baseX, x, baseY, y) < 5000);
                        break;
                    case 2:
                        p = new Hero(id, x, y, false, shieldLife, isControlled == 1, vx, vy, BoardPiece.GetDistance(baseX, x, baseY, y) < 5000);
                        break;
                }
                if(p != null)
                    pieces.Add(p);
            }
            state.SetNextTurn(new Board(pieces));
            /*
            Stopwatch watch = new Stopwatch();
            watch.Start();
            Console.Error.WriteLine("Move count: " + state.GetPossibleMoves(true).Count);
            watch.Stop();
            Console.Error.WriteLine(watch.ElapsedMilliseconds);
            */
            Move move;
            if (!runNeural)
            {
                GameHelper game = new GameHelper();
                move = game.GetBestMove(state);
            }
            else
            {
                NeuralGameHelper game = new NeuralGameHelper(state);
                if(!isLive && isFirstRound)
                {
                    game.ImportNetworkFromFile(fileName);
                }
                move = game.RunNeuralNetwork();
            }
            int limit = isFirstRound ? 998 : 48;
            Console.Write(move);
            isFirstRound = false;
        }
    }
}
