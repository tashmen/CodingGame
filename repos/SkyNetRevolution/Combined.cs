/*
 * File generated by SourceCombiner.exe using 3 source files.
 * Created On: 8/7/2021 3:01:11 PM
*/
using GameSolution.Utility;
using System;
using System.Collections.Generic;
using System.Linq;
//*** SourceCombiner -> original file GraphLinks.cs ***
namespace GameSolution.Utility
{
    public class GraphLinks
    {
        public Dictionary<int, List<Node>> Links { get; set; }
        public Dictionary<int, Dictionary<int, List<Node>>> Paths { get; set; }
        public GraphLinks()
        {
            Links = new Dictionary<int, List<Node>>();
        }
        /// <summary>
        /// Adds a link to the list
        /// </summary>
        /// <param name="factory1">First factory id</param>
        /// <param name="factory2">Second factory id</param>
        /// <param name="distance">The distance between the two factories</param>
        public void AddLink(int factory1, int factory2, int distance)
        {
            Console.Error.WriteLine(factory1 + " " + factory2 + " " + distance);
            AddLinkInternal(factory1, factory2, distance);
            AddLinkInternal(factory2, factory1, distance);
        }
        public void RemoveLink(int id1, int id2)
        {
            Links[id1].RemoveAll(n => n.Id == id2);
            Links[id2].RemoveAll(n => n.Id == id1);
        }
        /// <summary>
        /// Calculates all of the shortest paths in the factory links
        /// </summary>
        public void CalculateShortestPaths()
        {
            Paths = new Dictionary<int, Dictionary<int, List<Node>>>();
            List<int> vertices = Links.Keys.ToList();
            int vertexCount = vertices.Count;
            foreach (int vertex in vertices)
            {
                CalculateShortestPathFromStartNode(vertex, vertexCount);
            }
        }
        /// <summary>
        /// Calculates the shortest paths from the start node to all other nodes
        /// </summary>
        /// <param name="startNode">The starting factory id</param>
        /// <param name="vertexCount">The number of factories</param>
        private void CalculateShortestPathFromStartNode(int startNode, int vertexCount)
        {
            List<Node> minimumSpanningTree = new List<Node>();
            //Console.Error.WriteLine("Starting with " + startNode);
            int currentDist = 0;
            Paths[startNode] = new Dictionary<int, List<Node>>();
            minimumSpanningTree.Add(new Node(startNode, currentDist));
            while (minimumSpanningTree.Count < vertexCount)
            {
                int minDist = 99999;
                Node bestNode = null;
                Node parentNode = null;
                foreach (Node currentNode in minimumSpanningTree)
                {
                    currentDist = currentNode.Distance;
                    //Console.Error.WriteLine("Inspecting: " + currentNode.FactoryId + " distance " + currentDist);
                    foreach (Node adjacent in GetLinks(currentNode.Id))
                    {
                        if (minimumSpanningTree.Where(n => n.Id == adjacent.Id).Any())
                        {
                            continue;//skip factories already in minimum spanning tree
                        }
                        int distance = currentDist + adjacent.Distance;
                        if (distance < minDist)
                        {
                            minDist = distance;
                            bestNode = adjacent.CreateAtDistance(currentDist);
                            parentNode = currentNode;
                        }
                        else if (distance == minDist)//When the distances are equivalent pick the one with the shortest path
                        {
                            Paths[startNode].TryGetValue(currentNode.Id, out List<Node> pathCurrent);
                            int lengthCurrent = pathCurrent == null ? 0 : pathCurrent.Count;
                            Paths[startNode].TryGetValue(parentNode.Id, out List<Node> pathPrevious);
                            int lengthPrevious = pathPrevious == null ? 0 : pathPrevious.Count;
                            if (lengthCurrent > lengthPrevious)
                            {
                                minDist = distance;
                                bestNode = adjacent.CreateAtDistance(currentDist);
                                parentNode = currentNode;
                            }
                        }
                    }
                }
                if (parentNode == null)
                {
                    return;//no possible paths
                }
                minimumSpanningTree.Add(bestNode);
                List<Node> currentPath = null;
                if (parentNode.Id != startNode)
                {
                    Paths[startNode].TryGetValue(parentNode.Id, out currentPath);
                }
                if (currentPath == null)
                {
                    currentPath = new List<Node>();
                }
                else
                {
                    currentPath = new List<Node>(currentPath);
                }
                Paths[startNode].Add(bestNode.Id, currentPath);
                currentPath.Add(bestNode);
                /*
                if (startNode == 0)
                {
                    Console.Error.WriteLine("Parent node: " + parentNode.FactoryId + " distance: " + parentNode.Distance);
                    Console.Error.WriteLine("Shortest Node: " + bestNode.FactoryId + " distance: " + bestNode.Distance);
                }
                */
            }
        }
        /// <summary>
        /// Retrieves the links that are adjacent to the given factory
        /// </summary>
        /// <param name="factory">The factory id</param>
        /// <returns></returns>
        public List<Node> GetLinks(int factoryId)
        {
            return Links[factoryId];
        }
        /// <summary>
        /// Retrieves the straight line distance from start to end
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The distance from start to end</returns>
        public int GetDistance(int startId, int endId)
        {
            return GetLinks(startId).Where(l => l.Id == endId).First().Distance;
        }
        /// <summary>
        /// Retrieves the distance following the shortest path from start to end.
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The distance along the shortest path</returns>
        public int GetShortestPathDistance(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if(endPoints == null)
            {
                return 99999;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                return 99999;
            }
            return paths.Last().Distance;
        }
        /// <summary>
        /// Retrieves the next factory along the path from start to end
        /// </summary>
        /// <param name="startId">The starting factory id</param>
        /// <param name="endId">The ending factory id</param>
        /// <returns>The factory id that is first in the path</returns>
        public int GetShortestPath(int startId, int endId)
        {
            Paths.TryGetValue(startId, out Dictionary<int, List<Node>> endPoints);
            if (endPoints == null)
            {
                Console.Error.WriteLine("|||Start not found: " + startId);
                return endId;
            }
            endPoints.TryGetValue(endId, out List<Node> paths);
            if (paths == null)
            {
                Console.Error.WriteLine("|||End not found: " + endId + " start: " + startId);
                return endId;
            }
            int shortest = paths.First().Id;
            Console.Error.WriteLine("|||Shortest: " + shortest + " from: " + startId + " to: " + endId);
            return shortest;
        }
        //Adds links to the factory links
        public void AddLinkInternal(int startFactory, int destinationFactory, int distance)
        {
            List<Node> factoryLinks = null;
            if (Links.ContainsKey(startFactory))
            {
                factoryLinks = Links[startFactory];
            }
            else
            {
                factoryLinks = new List<Node>();
                Links[startFactory] = factoryLinks;
            }
            factoryLinks.Add(new Node(destinationFactory, distance));
        }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player
{
    static void Main(string[] args)
    {
        GraphLinks links = new GraphLinks();
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int N = int.Parse(inputs[0]); // the total number of nodes in the level, including the gateways
        int L = int.Parse(inputs[1]); // the number of links
        int E = int.Parse(inputs[2]); // the number of exit gateways
        for (int i = 0; i < L; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            int N1 = int.Parse(inputs[0]); // N1 and N2 defines a link between these nodes
            int N2 = int.Parse(inputs[1]);
            links.AddLink(N1, N2, 1);
        }
        IList<int> gateways = new List<int>();
        for (int i = 0; i < E; i++)
        {
            int EI = int.Parse(Console.ReadLine()); // the index of a gateway node
            gateways.Add(EI);
        }
        links.CalculateShortestPaths();
        GraphLinks graph2 = new GraphLinks();
        foreach (int link in links.Links.Keys)
        {
            foreach (Node n in links.Links[link])
            {
                int dist = 1;
                foreach (int gateway in gateways)
                {
                    if (gateway == link || gateway == n.Id)
                    {
                        dist = 9999999;
                    }
                    else
                    {
                        int i1 = links.GetShortestPathDistance(gateway, link);
                        int i2 = links.GetShortestPathDistance(gateway, n.Id);
                        if (i2 == 1)
                        {
                            dist = 0;
                        }
                    }
                }
                graph2.AddLinkInternal(link, n.Id, dist);
            }
        }
        graph2.CalculateShortestPaths();
        // game loop
        while (true)
        {
            int SI = int.Parse(Console.ReadLine()); // The index of the node on which the Skynet agent is positioned this turn
            links.CalculateShortestPaths();
            int minDist = 99999;
            int minStart = -1;
            int minEnd = -1;
            Dictionary<int, int> gatewayLinkToCount = new Dictionary<int, int>();
            foreach (int gateway in gateways)
            {
                Console.Error.WriteLine($"Checking: {gateway}");
                int start = gateway;
                int end = links.GetShortestPath(gateway, SI);
                if (gatewayLinkToCount.ContainsKey(end))
                {
                    gatewayLinkToCount[end] += 1;
                }
                else
                {
                    gatewayLinkToCount[end] = 0;
                }
            }
            foreach(int gateway in gateways)
            {
                int start = gateway;
                int end = links.GetShortestPath(gateway, SI);
                int dist = links.GetShortestPathDistance(gateway, SI);
                if (dist < minDist || (minEnd != -1 && dist == minDist && gatewayLinkToCount[minEnd] < gatewayLinkToCount[end]))
                {
                    minEnd = end;
                    minDist = dist;
                    minStart = start;
                    Console.Error.WriteLine($"min path: {minStart}, {minEnd}, {minDist}");
                }
            }
            if(minDist > 1)
            {
                int minDist2 = 99999;
                int minStart2 = -1;
                int minEnd2 = -1;
                foreach(int gateway in gateways)
                {
                    foreach(int gateway2 in gateways)
                    {
                        if (gateway == gateway2)
                            continue;
                        int start = gateway;
                        int end = links.GetShortestPath(gateway, gateway2);
                        int dist = links.GetShortestPathDistance(gateway, gateway2);
                        if(dist < minDist2)
                        {
                            minEnd2 = end;
                            minStart2 = start;
                            minDist2 = dist;
                        }
                        else if(dist == minDist2)
                        {
                            int i1 = graph2.GetShortestPathDistance(SI, end);
                            int i2 = graph2.GetShortestPathDistance(SI, minEnd2);
                            Console.Error.WriteLine($"SI: {SI}, end: {end}, minEnd2: {minEnd2}");
                            Console.Error.WriteLine($"i1: {i1}, i2: {i2}");
                            if(i1 < i2)
                            {
                                minEnd2 = end;
                                minStart2 = start;
                                minDist2 = dist;
                            }
                        }
                    }
                }
                if(minEnd2 != -1)
                {
                    minEnd = minEnd2;
                    minStart = minStart2;
                    minDist = minDist2;
                }
            }
            links.RemoveLink(minStart, minEnd);
            // Example: 0 1 are the indices of the nodes you wish to sever the link between
            Console.WriteLine(minStart + " " + minEnd);
        }
    }
}
//*** SourceCombiner -> original file Node.cs ***
namespace GameSolution.Utility
{
    public class Node
    {
        public int Id { get; set; }
        public int Distance { get; set; }
        public Node(int factory, int distance)
        {
            Id = factory;
            Distance = distance;
        }
        /// <summary>
        /// Creates a clone of the node from the current distance.  This is used while building the minimum spanning tree.
        /// </summary>
        /// <param name="currentDist">The current distance from the starting factory</param>
        /// <returns>A clone of the node with the proper distance</returns>
        public Node CreateAtDistance(int currentDist)
        {
            return new Node(Id, currentDist + Distance);
        }
    }
}
